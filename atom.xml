<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FinLab 量化實驗室</title>
  
  <subtitle>回測與選股教學部落格</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.finlab.tw/"/>
  <updated>2020-04-23T22:45:34.421Z</updated>
  <id>https://www.finlab.tw/</id>
  
  <author>
    <name>koreal6803</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用Python理財(3)：比特幣交易策略訊號實做</title>
    <link href="https://www.finlab.tw/btc-trading-signal/"/>
    <id>https://www.finlab.tw/btc-trading-signal/</id>
    <published>2020-04-23T20:20:56.000Z</published>
    <updated>2020-04-23T22:45:34.421Z</updated>
    
    <content type="html"><![CDATA[<p>這篇文章中，<br>我們將用 pandas 來做一個簡易的交易訊號，</p><center><img src="/btc-trading-signal/thumbnail.jpeg" title="thumbnail"></center><p>pandas 是一個 python 的 package，<br>專門用來做資料處理，<br>你可以想像它是 python 裡面的 excel，<br>可以產生並且處理各式各樣的表格</p><h3 id="Pandas-操作介紹"><a href="#Pandas-操作介紹" class="headerlink" title="Pandas 操作介紹"></a>Pandas 操作介紹</h3><p>承接著<a href="/btc-crawler-py/">上一篇文章</a>，<br>我們繼續在 <a href="https://colab.research.google.com/" rel="external nofollow noopener noreferrer" target="_blank">google colab</a> 上進行程式的實驗<br>此時的 <code>df</code> 已經是歷史資料</p><center><img src="/btc-trading-signal/df.png" title="dataframe"></center><p>就是一個 <code>pandas.DataFrame</code> 物件<br>這個物件就像是 excel 表格一樣<br>有很多的行跟列</p><p>每一個列都可以簡單的呼叫出來，<br>以我們的例子，每一列都是一個時間序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.Close</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/series.png" title="時間序列"></center><p>由上圖可知，每一列也是一種物件<br>叫做 <code>pd.Series</code>，<br>這種物件，就是一條序列，<br>可以想像是excel的單一一列的意思</p><h3 id="製作簡易的均線策略"><a href="#製作簡易的均線策略" class="headerlink" title="製作簡易的均線策略"></a>製作簡易的均線策略</h3><p><code>pd.Series</code>有很多特別的功能<br>例如計算移動窗格，我們可以用<br><code>pd.Series.rolling()</code><br>來產生移動窗格，並且用<br><code>pd.Series.rolling().mean()</code><br>來產生這個移動窗格的平均數<br>從時間序列的角度<br>這個就是「均線」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sma1 = df.Close.rolling(<span class="number">20</span>).mean()</span><br><span class="line">sma2 = df.Close.rolling(<span class="number">60</span>).mean()</span><br><span class="line"></span><br><span class="line">df.Close.plot()</span><br><span class="line">sma1.plot()</span><br><span class="line">sma2.plot()</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/sma_plot.png" title="SMA"></center><p>上圖中，我們將<code>BTCUSDT</code>的歷史紀錄 與兩條均線畫出來<br>會發現，時間跨度太大，導致價格跟均線看不清楚，<br>我們可以額外 zoom in 選取「某年」來觀察，<br>可以使用中括號來選取時間範圍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.Close[<span class="string">'2020'</span>].plot()</span><br><span class="line">sma1[<span class="string">'2020'</span>].plot()</span><br><span class="line">sma2[<span class="string">'2020'</span>].plot()</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/sma_plot2019.png" title="2019SMA"></center><p>接下來，我們來設計交易訊號<br>我們希望做一個簡單的均線策略：</p><p>假如短週期均線 <code>sma1</code> 超過 長週期 <code>sma2</code> -&gt; 做多<br>反之做空</p><p>要怎麼做出這樣的訊號呢？我們可以用不等式來進行，</p><h3 id="不等式條件"><a href="#不等式條件" class="headerlink" title="不等式條件"></a>不等式條件</h3><p>不等式，就是所謂的「大於等於小於」，<br>我們假如將兩條時間序列做不等式運算，</p><p>在這兩條時間序列中，每一個元素會被一一拿出來比對，<br>並且產生出新的「布林」時間序列：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">condition = sma1 &gt; sma2</span><br><span class="line">condition</span><br></pre></td></tr></table></figure></p><center><img src="/btc-trading-signal/condition.png" title="布林序列"></center><p>上圖中就是布林時間序列，每個時間點對映到「Ture」或是「False」<br>假如今天條件成立，也就是「sma1 &gt; sma2」的話<br>該時間點對映到的就會是 True<br>反之則是 False</p><p>因為我們是均線突破策略，<br>要怎麼結合不等式，來產生均線突破條件呢？我們還需要<br><code>pd.Series.shift</code><br>這個功能</p><h3 id="調用「昨天」的價格-pd-Series-shift"><a href="#調用「昨天」的價格-pd-Series-shift" class="headerlink" title="調用「昨天」的價格 pd.Series.shift"></a>調用「昨天」的價格 pd.Series.shift</h3><p><code>pd.Series.shift</code>是一個好用的function，<br>可以將時間序列全部都往後延遲一天，例如以下的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(df.Close)</span><br><span class="line">print(df.Close.shift(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/shift.png" title="shift範例"></center><p>你會發現兩者相差一天，<br>所以在做策略時，我會傾向於，將<code>pd.Series.shift(n)</code><br>當作是「n個時間單位前的價格」，<br>這邊我們用的是 ‘4h’ 4小時的歷史價格<br>所以<br><code>pd.Series.shift(1)</code><br>就是4小時前，<br>而<br><code>pd.Series.shift(2)</code><br>就是8小時前<br>以此類推</p><p>假如我們只使用<br><code>pd.Series.shift()</code><br>n 不設定參數的話<br>pandas 會預設 <code>n=1</code> 喔！</p><h3 id="結合上述的範例，產生策略訊號"><a href="#結合上述的範例，產生策略訊號" class="headerlink" title="結合上述的範例，產生策略訊號"></a>結合上述的範例，產生策略訊號</h3><p>我們希望的做出來的邏輯：<br>做多: 當(今天短週期均線 &gt; 今天長週期均線) 且 (昨天短週期均線 &lt; 昨天長週期均線)<br>做空: 當(今天短週期均線 &lt; 今天長週期均線) 且 (昨天短週期均線 &gt; 昨天長週期均線)</p><p>我們可以將上述中文，對映到以下的程式碼：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal_long = (sma1 &gt; sma2) &amp; (sma1.shift() &lt; sma2.shift())</span><br><span class="line">signal_short = (sma1 &lt; sma2) &amp; (sma1.shift() &gt; sma2.shift())</span><br></pre></td></tr></table></figure></p><p>上述程式碼中的 <code>&amp;</code> 就是「且」的意思</p><p>我們可以將訊號繪製出來：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal_long.astype(int).plot()</span><br><span class="line">(-signal_short.astype(int)).plot()</span><br></pre></td></tr></table></figure></p><center><img src="/btc-trading-signal/signal.png" title="交易訊號"></center><p>以上這張圖我用 -1 顯示 賣出訊號，而 1 是買進訊號<br>當我們將 True False 轉換成 int 時，<br>會轉換成「1」跟「0」的數值</p><h3 id="製作策略"><a href="#製作策略" class="headerlink" title="製作策略"></a>製作策略</h3><p>然而我們怎麼知道<br>照著這個交易訊號操作<br>實際的績效是怎麼樣呢？<br>下一個單元中，會教大家怎麼用 <a href="https://github.com/kernc/backtesting.py" rel="external nofollow noopener noreferrer" target="_blank">backtesting</a> 這個 package<br>來實做回測，<br>模擬這個策略的績效<br>敬請期待！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這篇文章中，&lt;br&gt;我們將用 pandas 來做一個簡易的交易訊號，&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/btc-trading-signal/thumbnail.jpeg&quot; title=&quot;thumbnail&quot;&gt;&lt;/center&gt;

&lt;p&gt;pandas 是一個 
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python理財：比特幣(2)用爬蟲下載歷史數據</title>
    <link href="https://www.finlab.tw/btc-crawler-py/"/>
    <id>https://www.finlab.tw/btc-crawler-py/</id>
    <published>2020-04-22T20:42:33.000Z</published>
    <updated>2020-04-24T18:48:45.005Z</updated>
    
    <content type="html"><![CDATA[<p>這個單元，<br>分享如何獲取比特幣歷史價格</p><p>可以打開<a href="https://colab.research.google.com/" rel="external nofollow noopener noreferrer" target="_blank">colab</a>線上編輯python跟我們一起做實驗吧！<br>colab 是 google 提供，線上運行 python 的平台<br>打開後，新增一個notebook<br>直接一步步貼上下面的代碼<br>程式就會順利運行了</p><center><img src="/btc-crawler-py/thumbnail.png" title="info"></center><h3 id="獲取-python-函式庫"><a href="#獲取-python-函式庫" class="headerlink" title="獲取 python 函式庫"></a>獲取 python 函式庫</h3><p>首先，我們要先獲取幫大家寫好的 package 可以到github上下載<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!git clone https://github.com/koreal6803/crypto_backtrader.git</span><br><span class="line">cd crypto_backtrader</span><br></pre></td></tr></table></figure></p><p>上面的指令，會先將預先寫好的程式從 github 上下載下來<br>並且將目錄切換到 crypto_backtrader<br>也就是下載下來的資料夾中</p><h3 id="安裝一些必要的packages"><a href="#安裝一些必要的packages" class="headerlink" title="安裝一些必要的packages"></a>安裝一些必要的packages</h3><p>接下來我們來安裝一些必要的 dependencies<br>這樣等會才能順利執行程式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!pip install python-binance</span><br><span class="line">!pip install bitmex</span><br><span class="line">!pip install Backtesting</span><br><span class="line">!pip install backtrader</span><br></pre></td></tr></table></figure><h3 id="加密貨幣命名方法"><a href="#加密貨幣命名方法" class="headerlink" title="加密貨幣命名方法"></a>加密貨幣命名方法</h3><p>這篇文章中，我們爬取 <code>BTCUSDT</code> 的價格<br><code>BTCUSDT</code> 這個 symbol 可以拆逞兩個部分<br>一個是 <code>BTC</code>、另一個是 <code>USDT</code><br><code>BTCUSDT</code> 代表，<code>BTC</code> 的價格，以 <code>USDT</code> 為單位，<br>這邊為什麼我們要用 <code>USDT</code> 呢？因為他是跟 <code>USD</code> 是美元是表兄弟，<br><code>USDT</code> 是一種跟 <code>USD</code> 約略 1:1 兌換的穩定虛擬貨幣<br><code>USDT</code> 的好處是</p><p>在交易時，假如用 加密貨幣 <-> 法定貨幣（美元）<br>這種方式交易，手續費會非常高昂<br>例如我們以 Maicoin 買入跟賣出手續費約高達 1%，</-></p><p>今天我們假如使用 <code>BTCUSDT</code> pair 來交易<br>由於同樣是加密貨幣，所以手續費算是大幅的降低，<br>目前手續費在各平台，一般的標準是0.1%，根據平台的優惠、交易量可以打折，<br>成本算是低很多，</p><p><a href="http://blog.udn.com/mashmoro980727/121661372" rel="external nofollow noopener noreferrer" target="_blank">交易對(trading pair)的相關介紹</a></p><p>那廢話不多說，趕快來下載歷史資料吧！</p><h3 id="使用幫大家寫好的函式庫"><a href="#使用幫大家寫好的函式庫" class="headerlink" title="使用幫大家寫好的函式庫"></a>使用幫大家寫好的函式庫</h3><p>我們可以使用<br><code>from finlab import crypto</code><br>將一些好用的 function 給叫進來</p><p>然後用<br><code>crypto.get_all_binance</code> 這個 function<br>來獲取交易對(trading pair)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from finlab import crypto</span><br><span class="line">df = crypto.get_all_binance(&apos;BTCUSDT&apos;, &apos;4h&apos;)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><center><img src="/btc-crawler-py/df.png" title="dataframe 結果"></center><p>上述這個 <code>get_all_binance</code><br>除了幫你整理好下載資料外，<br>還會將這些資料資料，存在 <code>crypto_backtrader/history/crypto/</code> 當中<br>以 <code>csv</code> 的方式存起來<br>方便你用 <code>excel</code>、<code>multicharts</code> 等程式來打開</p><p>你也可以輸入不同的 trading pair 名稱，可以<a href="https://www.binance.com/tw/markets" rel="external nofollow noopener noreferrer" target="_blank">binance官網</a>查找</p><p>下一步，我們會分享<br>怎麼用 Python 回測一個簡單的 <code>BTCUSDT</code> 交易策略！<br>敬請期待！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這個單元，&lt;br&gt;分享如何獲取比特幣歷史價格&lt;/p&gt;
&lt;p&gt;可以打開&lt;a href=&quot;https://colab.research.google.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python理財：比特幣交易自動化(1)</title>
    <link href="https://www.finlab.tw/python-bitcoin-trading-why-bitcoin/"/>
    <id>https://www.finlab.tw/python-bitcoin-trading-why-bitcoin/</id>
    <published>2020-04-20T06:09:14.000Z</published>
    <updated>2020-04-20T08:11:25.793Z</updated>
    
    <content type="html"><![CDATA[<p>原本想說開一個課程<br>介紹加密貨幣做portfolio selection<br>不過因為種種因素<br>決定還是寫成免費一系列的文章<br>介紹用 Python 建置 比特幣 交易系統</p><p>新科技<br>如 machine learning、blockchain，<br>或許可以說「有缺點」、「不成熟」、「尚未完善」<br>但同時也是<strong>充滿機會</strong>的地方！<br>不論這是投資還是投機<br>我都會想要試試看<br>這可以說是<br>我對於<strong>程式和科技的執著</strong>吧！</p><p>我想研究比特幣 可以分成三個原因：</p><h3 id="1-隨著時間推移"><a href="#1-隨著時間推移" class="headerlink" title="1. 隨著時間推移"></a>1. 隨著時間推移</h3><h3 id="科技的進步是很可怕的！"><a href="#科技的進步是很可怕的！" class="headerlink" title="科技的進步是很可怕的！"></a>科技的進步是很可怕的！</h3><p>你絕對沒辦法想像<br>30年前，大家對個人電腦嗤之以鼻：<br>「翻書1秒鐘，開機卻要3分鐘！」<br>「書 比 電腦 要方便太多了！」<br>「沒有理由大家需要電腦呀！」</p><p>今天，每個人口袋都有一台…</p><p><strong>加密貨幣，會不會就是30年前的筆電呢？</strong><br>可能會，可能不會，</p><p>不過可以當作是買保險，因為</p><h3 id="2-我們生活在安逸的年代"><a href="#2-我們生活在安逸的年代" class="headerlink" title="2. 我們生活在安逸的年代"></a>2. 我們生活在安逸的年代</h3><h3 id="居安思危是很重要的"><a href="#居安思危是很重要的" class="headerlink" title="居安思危是很重要的"></a>居安思危是很重要的</h3><p>人類的歷史，充滿戰爭，<br>很多人因此顛沛流離，<br>這80年以來，是世界上最和平的一段日子，<br>究竟是人類越來越文明？<br>還是說世界的動盪 就像是經濟一樣會循環，<br>我們剛好處在和平的週期？</p><p>設想你最糟糕的狀況：<br>房子被強制徵收、國家貨幣大幅貶值、<br>臨時離開住所，輕裝逃往其他國家，</p><p>要是這些事情都發生了，<br>你可以什麼都沒有 什麼都不帶<br><strong>只要腦海中有比特幣的公鑰私鑰(帳號密碼)，</strong><br><strong>一切都能卷土重來</strong></p><p>一百年後 國家會興亡 貨幣會貶值<br>但不論如何 只要人類文明尚在<br>比特幣也會一直存在</p><h3 id="3-比特幣的特性"><a href="#3-比特幣的特性" class="headerlink" title="3. 比特幣的特性"></a>3. 比特幣的特性</h3><p>可以舉貨幣的四種特徵<br>「易於辨識」、「易於分割且品質一致」、「易於儲存運送」、「普遍接受性」</p><h4 id="易於辨識"><a href="#易於辨識" class="headerlink" title="易於辨識"></a>易於辨識</h4><p>做偽鈔用於便利商店很難<br>但破解人類最先進的密碼學 更難</p><h4 id="易於分割且品質一致"><a href="#易於分割且品質一致" class="headerlink" title="易於分割且品質一致"></a>易於分割且品質一致</h4><p>比特幣支援「億」分之一</p><h4 id="易於儲存運送"><a href="#易於儲存運送" class="headerlink" title="易於儲存運送"></a>易於儲存運送</h4><p>只要有公私鑰在腦中，世界上任何地方都能使用，<br>轉帳費用非常低廉</p><h4 id="普遍接受性"><a href="#普遍接受性" class="headerlink" title="普遍接受性"></a>普遍接受性</h4><p>比特幣最為人詬病的點<br>就是大家認為 法定貨幣、黃金的特性已經足夠<br>加密貨幣只是多此一舉</p><p>另外，因為比特幣難監管，<br>導致各國剛開始時非常排斥<br>（但最近變成是愛恨交織就是了XD）<br>加密貨幣存在的意義<br>就是要等時間來慢慢證明了</p><h3 id="究竟時間要等多久？"><a href="#究竟時間要等多久？" class="headerlink" title="究竟時間要等多久？"></a>究竟時間要等多久？</h3><p>我粗淺認為<br>從微觀的角度 比特幣是可以被取代的<br>但是從鴻觀的角度 也就是100年為跨度<br>考慮了國家的興亡 和世界的動盪<br>它的價值會慢慢被體現<br>這邊的價值 比較著重在<br>應用於日常生活的價值！</p><p>在或近或遠的未來<br>比特幣應該存在著某種地位</p><p>以這樣的角度思考<br>則目前市值約為黃金的 1/50 倍<br>有點太低了</p><p>所以以個人濁見 是有一些投資的機會的<br>但投資跟投機往往一線之間<br>當前比特幣的波動非常大！<br>持有時加密貨幣一定要</p><ol><li>少部位</li><li>用量化分析降低風險</li></ol><p>要怎麼知道資金要投入多少呢？<br>簡單的方式：想像，你「單一天」可以承受最大虧損？</p><p>差不多就投資這麼多吧XDD<br>因為比特幣下跌個70％ 80％都是有發生過的！</p><p>接下來就來建置 Python 交易系統<br>讓我們投資的風險 可防可控！</p><p>歡迎追蹤<a href="https://www.facebook.com/finlab.python/" rel="external nofollow noopener noreferrer" target="_blank">粉專</a><br>來訂閱最新的教學分享喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原本想說開一個課程&lt;br&gt;介紹加密貨幣做portfolio selection&lt;br&gt;不過因為種種因素&lt;br&gt;決定還是寫成免費一系列的文章&lt;br&gt;介紹用 Python 建置 比特幣 交易系統&lt;/p&gt;
&lt;p&gt;新科技&lt;br&gt;如 machine learning、blockcha
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>台北最抗跌公寓在哪？ Python 告訴你 (Part 3)</title>
    <link href="https://www.finlab.tw/real-state-best-district-old-buildings-taipei/"/>
    <id>https://www.finlab.tw/real-state-best-district-old-buildings-taipei/</id>
    <published>2019-11-28T07:24:28.000Z</published>
    <updated>2020-04-20T08:10:29.849Z</updated>
    
    <content type="html"><![CDATA[<p>文末告訴你買哪裡？多少年齡的公寓？比較好<br>（結果滿出乎意料）</p><center><img src="/real-state-best-district-old-buildings-taipei/thumbnail.png" title="投資房產"></center><p>根據專家的說法，<br>由於人口老化的關係，<br>房價未來比較悲觀，<br>假如我們要自住買房怎麼辦？</p><p>有一個家的好處是<br>畢竟每個人生活習慣不同<br>要客制化專屬的生活空間<br>只有擁有房子才辦得到</p><p>但是，房子保值的年代已經過去了<br>幾年前台北的房價被炒的很高<br>有些地方明顯就是太貴了<br>這幾年慢慢的顯現出來</p><p>假如你因為工作需求，<br>需要再台北買一個自己的家<br>要買在哪裡比較保值？<br>對，保值而已，不求上漲，<br>只求不要跌太多</p><p>打開實價登錄，<br>不論是<a href="https://price.houseprice.tw/" rel="external nofollow noopener noreferrer" target="_blank">實價網</a>、<a href="https://www.rakuya.com.tw/realprice/result" rel="external nofollow noopener noreferrer" target="_blank">樂屋網</a>、或其他的網站<br>在功能上，都有很多進步的空間！</p><p>原因在於這些網站，都只提供進幾年的數據，<br>而且無法統計以及繪圖功能，<br>大部分都只提供近一兩年的比較，<br>但一般人自住買房，關心的是10年後的房價，<br>而不只是短期的上漲下跌，</p><p>所以只好來用 Python 做一點功課了</p><p>首先，我們根據之前的介紹，我們可以</p><ul><li><a href="/real-estate-analysis1/">爬到實價登錄歷史資料</a></li><li><a href="/real-estate-analasys-histograms/">將資料整理成 dataframe</a><br>可以先進行以上兩個步驟，然後就可以接著來寫 code 囉！</li></ul><p>這次的主題是「公寓」<br>我們假設某個人想買台北的房子<br>但是由於金錢考量，只能選擇公寓，</p><p>「究竟要怎麼選呢？」</p><h3 id="1-用區域來選"><a href="#1-用區域來選" class="headerlink" title="1. 用區域來選"></a>1. 用區域來選</h3><p>首先我們想要算出，台北市「公寓」的歷史走勢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># plt.rcParams['font.sans-serif'] = ['Noto Sans TC Regular'] # 有支援中文的字體</span></span><br><span class="line"><span class="comment"># plt.rcParams['axes.unicode_minus']=False</span></span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> dis <span class="keyword">in</span> set(df[<span class="string">'鄉鎮市區'</span>]):</span><br><span class="line"></span><br><span class="line">    condition1 = df[<span class="string">'土地區段位置/建物區段門牌'</span>].notna()</span><br><span class="line">    condition2 = df[<span class="string">'建物型態'</span>] == <span class="string">'公寓(5樓含以下無電梯)'</span></span><br><span class="line">    condition3 = (df[<span class="string">'鄉鎮市區'</span>] == dis)</span><br><span class="line">    </span><br><span class="line">    df_local = df[condition3 &amp; condition2]</span><br><span class="line">    result[dis] = df_local[<span class="string">'單價元坪'</span>].groupby(df_local.index.year).mean()</span><br><span class="line"></span><br><span class="line">k = pd.DataFrame(result).loc[<span class="number">2012</span>:]</span><br><span class="line">k.plot()</span><br></pre></td></tr></table></figure><center><img src="/real-state-best-district-old-buildings-taipei/dis-price.png" title="投資房產"></center><p>這張圖可以看出很多端倪，<br>自從政府調整法令後，<br>炒房投資客有明顯減少，<br>所以貴的地區房價下跌，</p><p>另外也因為台北交通便利，<br>（ubike、公車、捷運）<br>所以不論房價高低，<br>其實生活便利程度相差無幾<br>使得便宜的區域房價上漲，</p><p>房價差距越來越小，<br>平均來說，各區房價都越來越往 50～60W/坪 的價格趨近。</p><p>另外，除了肉眼來判別外，<br>我們也可以由價格標準差得知，<br>台北市各區，房價差異慢慢縮小，</p><center><img src="/real-state-best-district-old-buildings-taipei/std.png" title="投資房產"></center><p>由上面的分析，我們可以得到一個結論<br>對於「公寓」而言，我們應該選擇<br>「房價目前較低的地區」<br>因為這些地區的房價，會慢慢往平均（50～60W/坪）移動</p><p>所以假如是買公寓的話，要選哪裡呢？<br>以條件來分析的話，可以這樣選</p><ol><li>2019年房價 &lt; 平均的區域（價格低的）</li><li>2019年房價 &gt; 2018年的區域（看近期有漲的）</li></ol><p>以下就是程式碼以及選出來的區域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p2019 = k.loc[<span class="number">2019</span>]</span><br><span class="line">p2018 = k.loc[<span class="number">2018</span>]</span><br><span class="line"></span><br><span class="line">good_district = (p2019 &gt; p2018) &amp; (p2019 &lt; p2019.mean())</span><br><span class="line">p2019[good_district].sort_values()</span><br></pre></td></tr></table></figure><center><img src="/real-state-best-district-old-buildings-taipei/ranking.png" title="投資房產"></center><p>2. 用屋齡來判斷</p><p>大家都說越老的房子會折舊，<br>越老的房子應該要越便宜，<br>然而事情真的是這樣嗎？</p><p>實價登錄的資料令人跌破眼鏡！<br>根據數據的分析，每個區域都適用：<br>在屋齡「40～50」年的房子，竟然還會往上漲！？<br>不論哪一個區域，哪一年，都可以觀察到這個現象！</p><p>舉個例子，以下我們來繪圖「中山區」房價</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2012</span>, <span class="number">2020</span>):</span><br><span class="line">    df_local = df[(df[<span class="string">'鄉鎮市區'</span>] == <span class="string">'中山區'</span>) &amp; (df[<span class="string">'year'</span>] == i)]</span><br><span class="line">    df_local[<span class="string">'房屋年齡'</span>] = ((<span class="number">2019</span> - pd.to_numeric(df_local[<span class="string">'建築完成年月'</span>].str[:<span class="number">3</span>]) - <span class="number">1911</span>)).astype(int, errors=<span class="string">'ignore'</span>)</span><br><span class="line">    df_local[<span class="string">'房屋年齡'</span>] = pd.to_numeric(df_local[<span class="string">'房屋年齡'</span>] /<span class="number">10</span>).round()</span><br><span class="line">    df_local[<span class="string">'單價元坪'</span>].groupby(df_local[<span class="string">'房屋年齡'</span>]).mean().plot()</span><br></pre></td></tr></table></figure><center><img src="/real-state-best-district-old-buildings-taipei/age.png" title="投資房產"></center><p>上圖每一條線的意思是<br>每一年「不同屋齡的公寓價格」<br>我們可以觀察到幾個現象：</p><ol><li>年輕的公寓下跌的比較快</li><li>老公寓在40～50歲時，還會往上漲</li></ol><p>第二點尤其的詭異，<br>可能是因為都更的關係？<br>不只是中山區，<br>台北的任一區都可以觀察到這個現象<br>大家可以回去跑跑看</p><p>總之，至少老公寓折舊的速度，<br>是比想像中還要慢的，<br>（或可能是老公寓都賣不出去，除<br>非特別地段、特別地點，導致樣本有偏差？<br>還需要再研究）</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>這邊還是要提醒大家，<br>這個是針對「老公寓」做的研究，<br>假如是「新成屋」、「華廈」等屋型，<br>還需要額外去研究才能更清楚。</p><p>數據只是一部分的幫助，<br>買到好房子還是必需要做很多其他功課<br>例如：附近的捷運、生活機能、嫌惡設施 等等<br>都很重要<br>另外，看房技巧、談價格 也不能忽略，</p><p>不過以統計的觀點來說</p><p>保值地區首選順序：<br>「萬華區、文山區、內湖區、南港區」</p><p>保值屋齡首選：<br>「20～40歲以上」公寓</p><p>假如你要在台北買房，<br>而且想要買舊公寓重新裝潢，<br>希望這篇文章可以幫助到你！</p><p>也歡迎分享給有在看房的朋友哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文末告訴你買哪裡？多少年齡的公寓？比較好&lt;br&gt;（結果滿出乎意料）&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/real-state-best-district-old-buildings-taipei/thumbnail.png&quot; title=&quot;投資房產&quot;&gt;&lt;/cent
      
    
    </summary>
    
      <category term="實價登入" scheme="https://www.finlab.tw/categories/%E5%AF%A6%E5%83%B9%E7%99%BB%E5%85%A5/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="房地產" scheme="https://www.finlab.tw/tags/%E6%88%BF%E5%9C%B0%E7%94%A2/"/>
    
  </entry>
  
  <entry>
    <title>機器學習無法預測股價！</title>
    <link href="https://www.finlab.tw/ml-can-not-predict-price/"/>
    <id>https://www.finlab.tw/ml-can-not-predict-price/</id>
    <published>2019-11-06T19:57:11.000Z</published>
    <updated>2019-11-08T04:44:47.693Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/ml-can-not-predict-price/thumbnail.png" title="delay"></center><p>很多我非常尊敬的前輩，說機器學習有一些缺點，拿來投資很危險，<br>這些我都認同，畢竟要做出好的模型是很有挑戰的，<br>且回測模擬跟實際投資的狀況不一樣，非常認同！</p><h3 id="但有時候真的稍微有那麼一點激烈"><a href="#但有時候真的稍微有那麼一點激烈" class="headerlink" title="但有時候真的稍微有那麼一點激烈"></a>但有時候真的稍微有那麼一點激烈</h3><p>另一位我很尊敬的前輩，暗指用AI投資的人：<br>「他們的想像力都消失了，他們只是在耗著老天爺給他們的天賦，<br>  或是青春給他們能犯錯的空間，在那邊浪費生命。」<br>「很多人都被工具綁架邏輯，沒有一點想像力」<br>「做出來的只是垃圾，臭不可聞」</p><h3 id="嗯…"><a href="#嗯…" class="headerlink" title="嗯…"></a>嗯…</h3><p>「究竟跟AI有多深的怨念？」XD<br>我不知道是不是哪裡有不小心得罪或冒犯，<br>才讓他對於使用 AI 投資的人這麼嗤之以鼻<br>以我來說，我最早之前，是做價值投資的研究，後來加入了點技術指標，價量，到現在研究機器學習，</p><p>我覺得<br>每個人投資方法不同，<br>有價值型投資，技術指標，短線、極短線、中長線、存股<br>不論是哪些方法，都有很多人賺錢，更多人賠錢</p><p>不論如何</p><h4 id="可以長期穩定獲利的就是好工具。"><a href="#可以長期穩定獲利的就是好工具。" class="headerlink" title="可以長期穩定獲利的就是好工具。"></a>可以長期穩定獲利的就是好工具。</h4><p>這些對 AI 不屑前輩的口中，總是有著這麼一句話：</p><h3 id="機器學習無法預測價格"><a href="#機器學習無法預測價格" class="headerlink" title="機器學習無法預測價格"></a>機器學習無法預測價格</h3><p>這句話，以我自己的經驗來說，是舉雙手認同的，<br>但就算是認同，我也絕對不敢斷定，或直接了當的大肆宣揚，<br>畢竟這個世界有太多東西要學習了，</p><p>不過我們就先「假設」機器學習無法預測股價好了</p><h4 id="難道想獲利一定要預測股價嗎？"><a href="#難道想獲利一定要預測股價嗎？" class="headerlink" title="難道想獲利一定要預測股價嗎？"></a>難道想獲利一定要預測股價嗎？</h4><p>你不需要懂機器學習，也知道：</p><h4 id="通常撰寫策略，從來不用預測股價"><a href="#通常撰寫策略，從來不用預測股價" class="headerlink" title="通常撰寫策略，從來不用預測股價"></a>通常撰寫策略，從來不用預測股價</h4><p>只要產生的交易訊號，也就是買賣時機點就可以了，<br>照著操作，被動的投資，而不是主動的預測，<br>對於機器學習也是同樣的道理。</p><p>所以正確的使用機器學習的方法是：</p><h3 id="不要用機器學習預測股價，而是用來直接產生交易訊號！"><a href="#不要用機器學習預測股價，而是用來直接產生交易訊號！" class="headerlink" title="不要用機器學習預測股價，而是用來直接產生交易訊號！"></a>不要用機器學習預測股價，而是用來直接產生交易訊號！</h3><p>既然大家都有這樣的知識，為何還要執著於「機器學習無法預測股價」所以「機器學習沒有用」這件事情上呢？<br>就像是你測量羽毛跟保齡球落下，時間不一樣，難道就說牛頓第二運動定律是錯的了嗎？<br>比較有可能是實驗做錯了啦～</p><p>為何大家都說機器學習無法預測股價，先簡單的說明一下</p><h3 id="最為人所知的機器學習障礙-預測延遲"><a href="#最為人所知的機器學習障礙-預測延遲" class="headerlink" title="最為人所知的機器學習障礙 - 預測延遲"></a>最為人所知的機器學習障礙 - 預測延遲</h3><p>簡單來說，就是下圖中，藍色的為股價，而紅色的是機器學習預測的數值，<br>可以看到紅色永遠比藍色線慢半拍，晚一步才轉折<br>雖然藍色跟紅色非常接近，但離「預測」其實差得很遠，回測後就會發現，是不能拿來交易的，</p><p><center><img src="/ml-can-not-predict-price/delay.png" title="delay"></center><br>這個就是大家所說，機器學習的預測延遲<br>說真的，這類有小瑕疵的文章或論文是真的滿多的，<br>例如 <a href="https://towardsdatascience.com/predicting-stock-price-with-lstm-13af86a74944" rel="external nofollow noopener noreferrer" target="_blank">這篇</a><br>就連我們的部落格，也有<a href="https://www.finlab.tw/%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E5%B9%AB%E4%BD%A0%E8%A7%A3%E6%9E%90K%E7%B7%9A%E5%9C%96%EF%BC%81/">這類的文章</a></p><p>你只要搜尋「machine learning predict stock price」<br>就可以找到滿坑滿谷的文章，都有這個缺點</p><p>之所以會有這樣的問題，不難理解，因為股價並不是stationary time series，所以機器學習直接預測股價很容易失真<br>導致最後落入 overfitting 的窘境，且預測結果常常會有 bias</p><p>所以</p><h3 id="我自己寫的文章，沒有任何一篇是教大家預測股價的"><a href="#我自己寫的文章，沒有任何一篇是教大家預測股價的" class="headerlink" title="我自己寫的文章，沒有任何一篇是教大家預測股價的"></a>我自己寫的文章，沒有任何一篇是教大家預測股價的</h3><p>我想提供大家真的能夠獲利的程式碼，<br>用來展示機器學習真的可以用來投資，<br>我不是蹭AI的熱潮，東拼西湊，只求程式可以跑，<br>而是盡力做出一個希望能夠獲利的模型，又讓大家可以學到新的演算法<br>並把這個模型分享給大家，然而AI不是神，沒有一個策略保證一定賺錢，<br>但我至少做到問心無愧，目前績效看起來也還OK，</p><h3 id="機器學習策略-我認為有效的方法"><a href="#機器學習策略-我認為有效的方法" class="headerlink" title="機器學習策略 - 我認為有效的方法"></a>機器學習策略 - 我認為有效的方法</h3><p>接下來舉一個，我認為有用的方法，<br>首先利用<br>Integrating a Piecewise Linear Representation Method and a Neural Network Model for Stock Trading Points Prediction<br>這篇 paper 當中的方式產生交易訊號<br>並且讓機器學習模型模仿，找出轉折點，以下是簡略的數據：</p><ul><li>商品：台股加權指數，取每15分鐘的收盤價</li><li>製作特徵：利用各種技術指標當作features</li><li>預測訊號：利用上述的 paper 產生交易訊號</li><li>利用2015年以前的資料產生模型，</li></ul><p>用一個最普通的神經網路，就可以有不錯的效果，以下是2019年5月的範例圖，<br>其中</p><ul><li>紅色為股價</li><li>藍色為多方轉折的發生機率</li><li>紫色為空方轉折的發生機率（負值）</li></ul><p>可以看出來，當藍色飆高時，通常是底部的多方轉折<br>而紫色飆高時，則是相反，是頭部的空方轉折</p><p><center><img src="/ml-can-not-predict-price/better.png" title="better"></center><br>2019年五月</p><p><center><img src="/ml-can-not-predict-price/better2.png" title="better2"></center><br>2019年六月<br>看不出有延遲，幾乎都是直接實時反應，<br>看起來還抓的算滿OK的，可以用來逆勢操作</p><p>雖然看似有用，但</p><h3 id="機器學習不適用於所有人，因為很難很複雜"><a href="#機器學習不適用於所有人，因為很難很複雜" class="headerlink" title="機器學習不適用於所有人，因為很難很複雜"></a>機器學習不適用於所有人，因為很難很複雜</h3><h3 id="付出與收穫可能不成正比"><a href="#付出與收穫可能不成正比" class="headerlink" title="付出與收穫可能不成正比"></a>付出與收穫可能不成正比</h3><p>假如你不喜歡折磨自己<br>其實簡單的策略也可以賺錢的，<br>所以說你不一定要用機器學習來投資，</p><h3 id="然而每個人各有喜好，"><a href="#然而每個人各有喜好，" class="headerlink" title="然而每個人各有喜好，"></a>然而每個人各有喜好，</h3><p>以我而言，我喜歡<strong>追求和分享新的科技</strong>，<br>並且幫助大家學習新知識之餘，幸運的話還可以賺點錢，<br>然而走在科技的前沿，特立獨行，本來就是會有很多的支持和反對<br>我不敢說這條路走的正確，但我們能走多遠是多遠，<br>這一切紛擾，只能用對帳單來證明了（XDD努力生產中）<br>（雖然我們早在一年前開始就把模擬結果<a href="https://ai.finlab.tw/strategy/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%20-%20%E8%B2%A1%E5%8B%99%E5%A0%B1%E8%A1%A8%E9%81%B8%E8%82%A1" rel="external nofollow noopener noreferrer" target="_blank">每天都放上網</a>，但看來對帳單還是必須的呀！）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/ml-can-not-predict-price/thumbnail.png&quot; title=&quot;delay&quot;&gt;&lt;/center&gt;

&lt;p&gt;很多我非常尊敬的前輩，說機器學習有一些缺點，拿來投資很危險，&lt;br&gt;這些我都認同，畢竟要做出好的模型是很有
      
    
    </summary>
    
      <category term="AI看股票" scheme="https://www.finlab.tw/categories/AI%E7%9C%8B%E8%82%A1%E7%A5%A8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Machine Learning" scheme="https://www.finlab.tw/tags/Machine-Learning/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="量化投資" scheme="https://www.finlab.tw/tags/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B3%87/"/>
    
  </entry>
  
  <entry>
    <title>投資組合 Paper Trading 1分鐘就上手（Cmoney 大富翁股票 API）</title>
    <link href="https://www.finlab.tw/cmoney-paper-trading/"/>
    <id>https://www.finlab.tw/cmoney-paper-trading/</id>
    <published>2019-11-02T05:07:19.000Z</published>
    <updated>2019-11-09T16:54:10.057Z</updated>
    
    <content type="html"><![CDATA[<p>沒有錢投資嗎？想要鍛鍊投資技巧又不虧錢嗎？<br>除了回測外，想要有接近真實情況的投資模擬嗎？<br>那你一定要試試看我寫的這個小程式：CmoneyVirtualAccount<br>他可以幫你模擬股票買賣的獲利狀況，讓你在沒有錢的時候，可以拿來做練習。</p><center><img src="/cmoney-paper-trading/thumbnail.png" title="thumbnail"></center><h3 id="為什麼要用-Paper-Trading"><a href="#為什麼要用-Paper-Trading" class="headerlink" title="為什麼要用 Paper Trading"></a>為什麼要用 Paper Trading</h3><p>Paper Trading 可以幫助我們更理解市場上投資的真實狀況，<br>顯示我們「假如」持有某種資產組合的報酬率，<br>我們可以自行設定投資金額，例如100萬，並且測試看看，自己精心研發的策略有沒有用</p><h3 id="為什麼不用回測就好了？"><a href="#為什麼不用回測就好了？" class="headerlink" title="為什麼不用回測就好了？"></a>為什麼不用回測就好了？</h3><p>簡單講，大部分寫Python的人，回測框架要達到非常嚴謹，是非常困難的，<br>所以通常我們都「大概測一測」，比較少考慮的部分有：</p><ol><li>胃納量（有些股票根本沒成交量，怎麼可能買很多張？）</li><li>不小心使用到未來數據（財報、月營收）</li><li>摩擦成本（手續費、證交稅）</li><li>忘記把已下市股票給納入回測中</li><li>太多了…以後再整理給大家</li></ol><p>除了更精密的模擬外，Paper Trading還能夠</p><h3 id="幫助投資人檢視策略的「微觀效果」"><a href="#幫助投資人檢視策略的「微觀效果」" class="headerlink" title="幫助投資人檢視策略的「微觀效果」"></a>幫助投資人檢視策略的「微觀效果」</h3><p>Paper Trading 可以讓你對於投資更有感覺，回測只是看長年下來的獲利績效，<br>雖然你可能覺得長期績效很好，但是這是個宏觀角度（好幾年），也就是最後得到的總報酬率，<br>然而我們真正投資的時候，是深處於微觀的世界（每天），會覺得每天的起伏都很劇烈！<br>有時候會讓你疑神疑鬼，想要調整策略，覺得這個策略可能失效了，<br>變得說常常在優化策略，但是都是無謂的優化<br>Paper Trading 另一個關鍵是，你要把它當成真的$（雖然很難），<br>這樣操作的時候，除了模擬獲利，也模擬自己面對報酬率的心態，</p><p>接下來我們就進行三個步驟來做 Paper Trading 吧！</p><h3 id="1-安裝"><a href="#1-安裝" class="headerlink" title="1. 安裝"></a>1. 安裝</h3><p>這個程式沒什麼特別的安裝方法，可以打開anaconda prompt 輸入以下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/koreal6803/CmoneyVirtualAccount.git</span><br><span class="line"></span><br><span class="line"># mac 使用的指令</span><br><span class="line">mv CmoneyVirtualAccount/cmoneyVirtualAccount ./cmoney</span><br><span class="line"></span><br><span class="line"># windows 使用的指令</span><br><span class="line">move CmoneyVirtualAccount/cmoneyVirtualAccount ./cmoney</span><br></pre></td></tr></table></figure></p><h3 id="2-申請帳號"><a href="#2-申請帳號" class="headerlink" title="2. 申請帳號"></a>2. 申請帳號</h3><p>我們要到 Cmoney 的平台來申請帳號密碼：<br><a href="https://www.cmoney.tw/vt/" rel="external nofollow noopener noreferrer" target="_blank">https://www.cmoney.tw/vt/</a><br>這邊值得注意的是，假如你有用FB登入，請還是要設定一個密碼，這樣等等才可以使用 Python 操控 Cmoney 的模擬平台喔！(右上角使用者名稱-&gt;基本資料)</p><h3 id="3-用程式操控"><a href="#3-用程式操控" class="headerlink" title="3. 用程式操控"></a>3. 用程式操控</h3><p>然後就可以在此資料夾中，使用 Python 來做 Paper trading 囉！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cmoney.stock <span class="keyword">import</span> VirtualStockAccount</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登入</span></span><br><span class="line">vs = VirtualStockAccount(<span class="string">'your_account'</span>, <span class="string">'your_password'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切換子帳號</span></span><br><span class="line">vs.aid = <span class="string">'123456'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ #</span></span><br><span class="line"><span class="comment"># 查看帳戶</span></span><br><span class="line"><span class="comment"># ------ # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到某檔股票的資料：</span></span><br><span class="line">vs.get_price(<span class="string">'2330'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目前帳戶持有的股票</span></span><br><span class="line">vs.status()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看現有資金</span></span><br><span class="line">vs.info()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ #</span></span><br><span class="line"><span class="comment"># 操作帳戶</span></span><br><span class="line"><span class="comment"># ------ # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 買一張台積電（強迫現價或開盤價買入）</span></span><br><span class="line">vs.buy(<span class="string">'2330'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 賣出一張台積電（強迫現價或開盤賣出）</span></span><br><span class="line">vs.sell(<span class="string">'2330'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ #</span></span><br><span class="line"><span class="comment"># 批次操作</span></span><br><span class="line"><span class="comment"># ------ # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 買一張台積電、一張聯發科</span></span><br><span class="line">vs.buy(&#123;<span class="string">'2330'</span>: <span class="number">1</span>, <span class="string">'2454'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出清所有股票</span></span><br><span class="line">vs.sell_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將所有帳戶持股設定成：「一張台積電」、「一張聯發科」</span></span><br><span class="line"><span class="comment"># （會先賣出股票，並且買「一張台積電」、「一張聯發科」)</span></span><br><span class="line">vs.rebalance(&#123;<span class="string">'2330'</span>: <span class="number">1</span>, <span class="string">'2454'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自動分配持股（平均分散總資產）（通常我會用這個）</span></span><br><span class="line">vs.sync([<span class="string">'1101'</span>, <span class="string">'2330'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ #</span></span><br><span class="line"><span class="comment"># 委託操作</span></span><br><span class="line"><span class="comment"># ------ # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目前的委託單</span></span><br><span class="line">vs.get_orders()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除所有委託單</span></span><br><span class="line">vs.cancel_all_orders()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="課程同學-Bonus"><a href="#課程同學-Bonus" class="headerlink" title="課程同學 Bonus!"></a>課程同學 Bonus!</h3><p>假如有上<a href="https://hahow.in/cr/python-finance" rel="external nofollow noopener noreferrer" target="_blank">「小資族選股策略」</a>的同學，想要paper trade你的策略，配合最後的優等生策略，可以直接使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.sync(strategy(data))</span><br></pre></td></tr></table></figure><p>來 paper trade 任何選股策略喔！</p><p>這支程式放在倉庫裡很久了，最近想要用又把它拿出來，想說修理一下分享給大家！<br>也歡迎大家來 push 新功能喔～（缺 unit test 呀XD）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;沒有錢投資嗎？想要鍛鍊投資技巧又不虧錢嗎？&lt;br&gt;除了回測外，想要有接近真實情況的投資模擬嗎？&lt;br&gt;那你一定要試試看我寫的這個小程式：CmoneyVirtualAccount&lt;br&gt;他可以幫你模擬股票買賣的獲利狀況，讓你在沒有錢的時候，可以拿來做練習。&lt;/p&gt;
&lt;cent
      
    
    </summary>
    
      <category term="財經Python教" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99/"/>
    
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>只用一行程式碼分析數據!?（實用的 Python Package）</title>
    <link href="https://www.finlab.tw/one-line-info-dataframe/"/>
    <id>https://www.finlab.tw/one-line-info-dataframe/</id>
    <published>2019-09-30T13:46:49.000Z</published>
    <updated>2019-10-08T07:30:49.856Z</updated>
    
    <content type="html"><![CDATA[<p>這篇文章介紹一個好用的 package，只要一行，就可以做出精美、詳細的圖表分析<br>還可以幫你查看資料是否有缺漏和錯誤的情況！</p><center><img src="/one-line-info-dataframe/thumbnail.jpeg" title="thumbnail"></center><p>今天的程式碼成果：</p><center><img src="/one-line-info-dataframe/profile_df.gif" title="profile_df"></center><h1 id="先取得要分析之資料"><a href="#先取得要分析之資料" class="headerlink" title="先取得要分析之資料"></a>先取得要分析之資料</h1><p>今天我們來分析一下股票的本益比、股價淨值比和殖利率，<br>先提供給大家一個爬蟲，讓大家可以直接把資料爬下來：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">import</span> pandas_profiling</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawler</span><span class="params">(date)</span>:</span></span><br><span class="line">    datestr = date.strftime(<span class="string">'%Y%m%d'</span>)</span><br><span class="line">    url = <span class="string">'https://www.twse.com.tw/exchangeReport/BWIBBU_d?response=csv&amp;date='</span>+datestr+<span class="string">'&amp;selectType=ALL'</span></span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    df = pd.read_csv(StringIO(res.text), header=<span class="number">1</span>)</span><br><span class="line">    df[<span class="string">'本益比'</span>] = pd.to_numeric(df[<span class="string">'本益比'</span>], errors=<span class="string">'coerce'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> df.dropna(thresh=<span class="number">3</span>).dropna(thresh=<span class="number">0.8</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>接下來我們就呼叫 <code>crawler</code> 這個函式，就可以將財務數據資料都爬取下來囉！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = crawler(datetime.date(<span class="number">2019</span>,<span class="number">10</span>,<span class="number">7</span>))</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><center><img src="/one-line-info-dataframe/head.png" title="df_head"></center><h3 id="1-用舊的方法來分析資料"><a href="#1-用舊的方法來分析資料" class="headerlink" title="1. 用舊的方法來分析資料"></a>1. 用舊的方法來分析資料</h3><p>最簡單的方式，假如有用過 <code>pandas</code> 的大家應該都知道，<br>可以使用 <code>df.describe()</code> 來大致上觀察數據的樣貌<br>假如你對 pandas 不太熟悉，它有點像是拿來處理表格的資料，<br>就像是 python 界的 excel 一樣，雖然它非常好用，但是有點太古老（無聊）了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.describe()</span><br></pre></td></tr></table></figure><center><img src="/one-line-info-dataframe/describe.png" title="df_describe"></center><h3 id="2-酷炫的方法資料分析"><a href="#2-酷炫的方法資料分析" class="headerlink" title="2. 酷炫的方法資料分析"></a>2. 酷炫的方法資料分析</h3><p>首先我們可以安裝 pandas_profiling</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas_profiling</span><br></pre></td></tr></table></figure><p>接下來就可以直接來使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_profiling</span><br><span class="line">df = crawler(datetime.date(<span class="number">2019</span>,<span class="number">10</span>,<span class="number">7</span>))</span><br><span class="line">df.profile_report()</span><br></pre></td></tr></table></figure><p>然後我們就會看到超精美的圖表！</p><h4 id="找出資料的缺漏或問題"><a href="#找出資料的缺漏或問題" class="headerlink" title="找出資料的缺漏或問題"></a>找出資料的缺漏或問題</h4><p>我覺得 <code>pandas_profiling</code> 很棒的地方在於，<br>可以將資料一口氣全部統整給我們，方便我們去做資料前處理，<br>例如下圖中的左下角，就可以看到每一個column有哪些警告，</p><center><img src="/one-line-info-dataframe/profile.png" title="profile"></center><ul><li>本益比有 20.4 % 是缺漏的：這是正常情況，因為本益比小於零不顯示</li><li>殖利率有 20.0 % 是 0：這也是正常情況，因為公司不一定有發股利股息</li><li>財報都是用第 2 季的財報：這也是正常的！</li></ul><p>有了這種檢驗，更能夠讓我們知道資料的可靠程度，真的非常非常棒！<br>除了上述的檢驗外，我們還可以</p><h4 id="輕鬆檢視每一個-column-的資料"><a href="#輕鬆檢視每一個-column-的資料" class="headerlink" title="輕鬆檢視每一個 column 的資料"></a>輕鬆檢視每一個 column 的資料</h4><p>這邊可以看到每一種資料的分佈，可以讓我們更好的掌握數據分佈型態</p><center><img src="/one-line-info-dataframe/hist.png" title="histogram"></center><h4 id="檢視資料相關性"><a href="#檢視資料相關性" class="headerlink" title="檢視資料相關性"></a>檢視資料相關性</h4><p>這邊還可以檢視資料的相關性，這邊有些複雜的名詞，哪天再來跟各位介紹</p><center><img src="/one-line-info-dataframe/corr.png" title="correlation"></center><p><code>pandas_profiling</code> 真的是很不錯的 package，<br>可以幫我們進一步的認識資料，<br>假如你也覺得這個 package 很實用，<br>也歡迎你分享給大家喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這篇文章介紹一個好用的 package，只要一行，就可以做出精美、詳細的圖表分析&lt;br&gt;還可以幫你查看資料是否有缺漏和錯誤的情況！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/one-line-info-dataframe/thumbnail.jpeg&quot; title=&quot;t
      
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Python" scheme="https://www.finlab.tw/tags/Python/"/>
    
      <category term="dataframe" scheme="https://www.finlab.tw/tags/dataframe/"/>
    
      <category term="資料分析" scheme="https://www.finlab.tw/tags/%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>用程式分析房地產可行嗎（2）房價分析</title>
    <link href="https://www.finlab.tw/real-estate-analasys-histograms/"/>
    <id>https://www.finlab.tw/real-estate-analasys-histograms/</id>
    <published>2019-08-29T00:58:05.000Z</published>
    <updated>2020-04-20T08:10:36.678Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/real-estate-analasys-histograms/fb11.png" title="distribution"></center><p>大家都在說房價市場恢復景氣，然而真的是這樣子嗎？<br>你有沒有覺得，怎麼每個人說的話都不一樣？<br>數據雖然都是實價登錄，但有些人就是看到漲，有些人就是看跌？<br>究竟誰說的對，還是必須要親自研究一下數據，才會知道</p><h1 id="數據是拿來「調整」的？！"><a href="#數據是拿來「調整」的？！" class="headerlink" title="數據是拿來「調整」的？！"></a>數據是拿來「調整」的？！</h1><p>身為一個「曾經」產出學術文章寫手，就會知道這些數據是有很多「可以操作空間」<br>（這樣講對嗎？XD）<br>不要相信任何人幫你統計的數據<br>因為任何人的數據都有可能想達成某種目的<br>例如某人要增加流量和公信力，就可以危言聳聽一點，用數據製作房價都在下跌的結論<br>某房仲想要刺激房地產，就會製作止跌回升的訊號，</p><h1 id="難道數據造假？！"><a href="#難道數據造假？！" class="headerlink" title="難道數據造假？！"></a>難道數據造假？！</h1><p>不論上漲下跌，相信這些數據都是對的，<br>都是從政府的實價登錄而得到<br>但分析方式不同，就會產生不同的結果！</p><p>所以數據是用來「感覺」的，而不是單看少數「專家」的結論<br>只能多做一點實驗，盡量讓實驗客觀公正，</p><p>這篇文章總共分成三個部分：</p><ol><li>獲取實價登錄</li><li>房價歷史走勢圖</li><li>房價分佈圖</li></ol><p>所以接下來我們就用 Python 來跟大家一起分析實價登錄的資料吧！</p><h1 id="取得實價登錄資料"><a href="#取得實價登錄資料" class="headerlink" title="取得實價登錄資料"></a>取得實價登錄資料</h1><p>首先跟上次一樣，<br><a href="/real-estate-analysis1/">爬取了實價登入所有歷史數據</a>，這次我們爬取csv檔：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">real_estate_crawler</span><span class="params">(year, season)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> year &gt; <span class="number">1000</span>:</span><br><span class="line">        year -= <span class="number">1911</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># download real estate zip file</span></span><br><span class="line">    res = requests.get(<span class="string">"https://plvr.land.moi.gov.tw//DownloadSeason?season="</span>+str(year)+<span class="string">"S"</span>+str(season)+<span class="string">"&amp;type=zip&amp;fileName=lvr_landcsv.zip"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># save content to file</span></span><br><span class="line">    fname = str(year)+str(season)+<span class="string">'.zip'</span></span><br><span class="line">    open(fname, <span class="string">'wb'</span>).write(res.content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make additional folder for files to extract</span></span><br><span class="line">    folder = <span class="string">'real_estate'</span> + str(year) + str(season)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(folder):</span><br><span class="line">        os.mkdir(folder)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># extract files to the folder</span></span><br><span class="line">    <span class="keyword">with</span> zipfile.ZipFile(fname, <span class="string">'r'</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">        zip_ref.extractall(folder)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>有了上述這個 function 我們可以將實價登錄資訊全部爬取下來：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">real_estate_crawler(<span class="number">101</span>, <span class="number">3</span>)</span><br><span class="line">real_estate_crawler(<span class="number">101</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> range(<span class="number">102</span>, <span class="number">108</span>):</span><br><span class="line">    <span class="keyword">for</span> season <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        print(year, season)</span><br><span class="line">        real_estate_crawler(year, season)</span><br><span class="line"></span><br><span class="line">real_estate_crawler(<span class="number">108</span>, <span class="number">1</span>)</span><br><span class="line">real_estate_crawler(<span class="number">108</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>下載完後，會看到每一年每一季的實價登錄資料夾<br>裡面有很多檔案，主要可以分成以下三種：</p><ul><li>x_lvr_land_a：房屋買賣交易</li><li>x_lvr_land_b：新成屋交易</li><li>x_lvr_land_c：租房交易</li></ul><p>其中 x 是一個英文字母，代表每個縣市，也就是你身份證字號的開頭<br>例如台北，就是「a」，新北市就是「f」，以此類推</p><h1 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h1><p>接下來我們以台北市為例子，看看能不能找到台北市便宜的好房子，<br>首先我們將歷年資料都讀進來：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 歷年資料夾</span></span><br><span class="line">dirs = [d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir() <span class="keyword">if</span> d[:<span class="number">4</span>] == <span class="string">'real'</span>]</span><br><span class="line"></span><br><span class="line">dfs = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> dirs:</span><br><span class="line">    print(d)</span><br><span class="line">    df = pd.read_csv(os.path.join(d,<span class="string">'a_lvr_land_a.csv'</span>), index_col=<span class="keyword">False</span>)</span><br><span class="line">    df[<span class="string">'Q'</span>] = d[<span class="number">-1</span>]</span><br><span class="line">    dfs.append(df.iloc[<span class="number">1</span>:])</span><br><span class="line">    </span><br><span class="line">df = pd.concat(dfs, sort=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/dfhead.png" title="dataframe"></center><p>然而這些資訊還必須再經過處理，才會讓我們待會的資料分析更好下手</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增交易年份</span></span><br><span class="line">df[<span class="string">'year'</span>] = df[<span class="string">'交易年月日'</span>].str[:<span class="number">-4</span>].astype(int) + <span class="number">1911</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同名稱同項目資料合併</span></span><br><span class="line">df[<span class="string">'單價元平方公尺'</span>].fillna(df[<span class="string">'單價元/平方公尺'</span>], inplace=<span class="keyword">True</span>)</span><br><span class="line">df.drop(columns=<span class="string">'單價元/平方公尺'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平方公尺換成坪</span></span><br><span class="line">df[<span class="string">'單價元平方公尺'</span>] = df[<span class="string">'單價元平方公尺'</span>].astype(float)</span><br><span class="line">df[<span class="string">'單價元坪'</span>] = df[<span class="string">'單價元平方公尺'</span>] * <span class="number">3.30579</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建物型態</span></span><br><span class="line">df[<span class="string">'建物型態2'</span>] = df[<span class="string">'建物型態'</span>].str.split(<span class="string">'('</span>).str[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除有備註之交易（多為親友交易、價格不正常之交易）</span></span><br><span class="line">df = df[df[<span class="string">'備註'</span>].isnull()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將index改成年月日</span></span><br><span class="line">df.index = pd.to_datetime((df[<span class="string">'交易年月日'</span>].str[:<span class="number">-4</span>].astype(int) + <span class="number">1911</span>).astype(str) + df[<span class="string">'交易年月日'</span>].str[<span class="number">-4</span>:] ,errors=<span class="string">'coerce'</span>)</span><br></pre></td></tr></table></figure><p>接下來我們可以來看一下這些資料有哪些欄位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.columns</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/dfcolumn.png" title="columns"></center><p>上圖我們比較在意的是：</p><ul><li>單價元坪：每坪房價是多少</li><li>物件型態：<code>住宅大樓</code>, <code>倉庫</code>, <code>公寓</code>, <code>套房</code>…等</li><li>鄉鎮市區：<code>中山區</code>, <code>中正區</code>, <code>信義區</code>, <code>內湖區</code>…等</li><li>每年房價的變化</li></ul><p>接下來我們就來將上述這些數據，變化成一些圖表，<br>方便我們以視覺化的方式來理解資料</p><h1 id="圖表分析"><a href="#圖表分析" class="headerlink" title="圖表分析"></a>圖表分析</h1><p>老實說，每個建商給的房價走勢圖好像都不太一樣，<br>我不知道他們是怎麼處理這些數據，有時候走勢都好棒棒的感覺<br>至少finlab的處理的方式，是完全透明，攤在陽光下讓大家知道<br>我覺得「公佈程式」就是一種比較公正、透明、公開的方式<br>讓大家檢驗這樣的計算是否公正，<br>假如哪裡可以再改進，也可以跟我說！</p><h2 id="每年房價走勢圖"><a href="#每年房價走勢圖" class="headerlink" title="每年房價走勢圖"></a>每年房價走勢圖</h2><p>下圖我們就來計算歷年房價的走勢圖，我們希望每一區可以分開畫<br>方便我們瞭解<code>地區</code>、<code>時間</code>這兩個因子對於房價的差異</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">prices = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> district <span class="keyword">in</span> set(df[<span class="string">'鄉鎮市區'</span>]):</span><br><span class="line">    cond = (</span><br><span class="line">        (df[<span class="string">'主要用途'</span>] == <span class="string">'住家用'</span>)</span><br><span class="line">        &amp; (df[<span class="string">'鄉鎮市區'</span>] == district)</span><br><span class="line">        &amp; (df[<span class="string">'單價元坪'</span>] &lt; df[<span class="string">"單價元坪"</span>].quantile(<span class="number">0.95</span>))</span><br><span class="line">        &amp; (df[<span class="string">'單價元坪'</span>] &gt; df[<span class="string">"單價元坪"</span>].quantile(<span class="number">0.05</span>))</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    groups = df[cond][<span class="string">'year'</span>]</span><br><span class="line">    </span><br><span class="line">    prices[district] = df[cond][<span class="string">'單價元坪'</span>].astype(float).groupby(groups).mean().loc[<span class="number">2012</span>:]</span><br><span class="line">    </span><br><span class="line">price_history = pd.DataFrame(prices)</span><br><span class="line">price_history.plot()</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/dts.png" title="房價走勢圖"></center><p>上圖中我們可以看出來，雖然房價會隨著時間波動，但地段的優勢還是非常的明顯，<br>例如大安區還是很可怕的，一坪最高可以到90萬元（平均後的數字）<br>然而以2019年來說，可以發現，</p><p>高價位地段 -&gt; 稍微下跌<br>低價位地段 -&gt; 稍微上漲</p><p>畢竟台北的大眾交通工具也算是還OK，住哪裡應該都不至於太不方便<br>所以在幾乎沒有炒作空間的狀況下，不同地區的差異性慢慢降低，感覺是合理的</p><h2 id="那總體來說呢？"><a href="#那總體來說呢？" class="headerlink" title="那總體來說呢？"></a>那總體來說呢？</h2><p>我們可以粗略的用簡單的「平均」的方式，將所有地區的房價平均起來：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price_history.mean(axis=<span class="number">1</span>).plot()</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/dtsm.png" title="平均房價"></center><p>就會看到2014年高峰後，台北市房價就處於下跌的狀態</p><h2 id="不是有人說2019年房價回升了嗎？"><a href="#不是有人說2019年房價回升了嗎？" class="headerlink" title="不是有人說2019年房價回升了嗎？"></a>不是有人說2019年房價回升了嗎？</h2><p>刪除outlier的方式不同，可以得出不同的結論，<br>也是有一些實驗中 2019 年平均房價比 2018 年高，<br>所以目前也有很多人說止跌回升是有可能的</p><h2 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h2><p>整體的大趨勢來說，從2014年以後開始下跌至今，似乎跌幅沒有像當初這麼重，<br>甚至有止跌的跡象，但究竟房價有沒有回升，還需要謹慎評估</p><p>甚至還有報導說，某些地段回到了2014、2015高點，這都是拿單一區段來當結論，見樹不見林的方式，背後居心自然是眾人皆知。</p><p>思考一下，為何現在都在推新建案？有很多節目，專家們都宣導，買公寓（舊房子）比較可能選到有壁癌、排水系統不好、貸款成數較低…等等，鼓吹大家買新建案。</p><p>當然他們很有可能是為了消費者著想，這些都是實話，不過也有可能是因為新房子比起公寓，更能賣出好價錢，進而維持房價不衰退，所以接下來我們就來分析一下</p><h1 id="建物型態"><a href="#建物型態" class="headerlink" title="建物型態"></a>建物型態</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">building_type_prices = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> building_type <span class="keyword">in</span> set(df[<span class="string">'建物型態2'</span>]):</span><br><span class="line">    cond = (</span><br><span class="line">        (df[<span class="string">'主要用途'</span>] == <span class="string">'住家用'</span>)</span><br><span class="line">        &amp; (df[<span class="string">'單價元坪'</span>] &lt; df[<span class="string">"單價元坪"</span>].quantile(<span class="number">0.8</span>))</span><br><span class="line">        &amp; (df[<span class="string">'單價元坪'</span>] &gt; df[<span class="string">"單價元坪"</span>].quantile(<span class="number">0.2</span>))</span><br><span class="line">        &amp; (df[<span class="string">'建物型態2'</span>] == building_type)</span><br><span class="line">        )</span><br><span class="line">    building_type_prices[building_type] = df[cond][<span class="string">'單價元坪'</span>].groupby(df[cond][<span class="string">'year'</span>]).mean().loc[<span class="number">2012</span>:]</span><br><span class="line">pd.DataFrame(building_type_prices)[[<span class="string">'公寓'</span>, <span class="string">'住宅大樓'</span>, <span class="string">'套房'</span>, <span class="string">'華廈'</span>]].plot()</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/tts.png" title="types_real_estate"></center><p>上圖中我們可以發現，老舊公寓的價格真的會不太理想，比起一般的大樓住宅或是住宅，近年價差越來越明顯，當價差到達一定的程度，買新房不一定比較好，舊房不一定這麼一無是處。</p><p>但是以平均來當作指標，其實也不是這麼精確，我們還是用分佈圖用眼睛來感受一下，才是最好瞭解房價的方法：</p><h2 id="分佈圖"><a href="#分佈圖" class="headerlink" title="分佈圖"></a>分佈圖</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'font.size'</span>] = <span class="number">20</span></span><br><span class="line"><span class="keyword">for</span> district <span class="keyword">in</span> set(df[<span class="string">'鄉鎮市區'</span>]):</span><br><span class="line">    dfdistrict = df[df[<span class="string">'鄉鎮市區'</span>] == district]</span><br><span class="line">    dfdistrict[<span class="string">'單價元坪'</span>][dfdistrict[<span class="string">'單價元坪'</span>] &lt; <span class="number">2000000</span>].hist(bins=<span class="number">120</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">2000000</span>)</span><br><span class="line">plt.legend(set(df[<span class="string">'鄉鎮市區'</span>]))</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/dhis.png" title="distribution"></center><p>上圖中可以明顯感受到，不同地區房價的差異性，例如最右邊的分佈（大安區），大部分單價都比較貴，同時我們也可以看到一些低的詭譎的房價（每坪0萬？！），當然也有很多高的咋舌的單價，<br>甚至一坪200萬都有，只能說富人的世界跟我們一般人還是差距很大呀！</p><p>我們取平均的時候無法將這些怪房價給濾除，但好在人眼可以<br>這就是分佈圖的重要性</p><h2 id="買房使用-Python-簡單的範例"><a href="#買房使用-Python-簡單的範例" class="headerlink" title="買房使用 Python 簡單的範例"></a>買房使用 Python 簡單的範例</h2><p>假如今天我們想在北投買房子，可以將北投的房價單獨拿出來看，並且按照建案型態製作分佈圖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dfdistrict = df[(df[<span class="string">'鄉鎮市區'</span>] == <span class="string">'北投區'</span>) &amp; (df[<span class="string">'year'</span>] &gt;= <span class="number">2018</span>) &amp; (</span><br><span class="line">    (df[<span class="string">'建物型態2'</span>] == <span class="string">'住宅大樓'</span>) | (df[<span class="string">'建物型態2'</span>] == <span class="string">'公寓'</span>) | (df[<span class="string">'建物型態2'</span>] == <span class="string">'套房'</span>)</span><br><span class="line">)]</span><br><span class="line">dfdistrict = dfdistrict[dfdistrict[<span class="string">'單價元坪'</span>] &lt; <span class="number">2000000</span>]</span><br><span class="line"></span><br><span class="line">dfdistrict[<span class="string">'單價元坪'</span>].groupby(dfdistrict[<span class="string">'建物型態2'</span>]).hist(bins=<span class="number">50</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">plt.legend(set(dfdistrict[<span class="string">'建物型態2'</span>]))</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/bhis.png" title="distribution2"></center><p>這樣我們就可以一眼看出來，究竟公寓跟電梯大樓有什麼不一樣<br>方便我們在選擇的時候，多一些考慮<br>讓我們在買房談價格時，可以有更全面的概念！</p><p>有時候買房不是為了投資，而是生活所需而不得不，<br>在這個時代，我們已經無法買的精妙，炒房產呱呱叫，<br>但至少在面對這種重大抉擇時，<br>能有多一份數據輔佐，盡量不要「虧太多」，買到與價格相符的好房！</p><p>假如希望我們未來可以多多發佈類似的文章，<br>可以到<a href="https://www.facebook.com/finlab.python/" rel="external nofollow noopener noreferrer" target="_blank">粉絲團</a><br>幫我們按個讚～！</p><p><a href="https://colab.research.google.com/drive/1MyWsmtsfTakVR3EDtX2B-ZV4WdHtnpt6" rel="external nofollow noopener noreferrer" target="_blank">colab線上編寫此範例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/real-estate-analasys-histograms/fb11.png&quot; title=&quot;distribution&quot;&gt;&lt;/center&gt;

&lt;p&gt;大家都在說房價市場恢復景氣，然而真的是這樣子嗎？&lt;br&gt;你有沒有覺得，怎麼每個人說的話都
      
    
    </summary>
    
      <category term="實價登入" scheme="https://www.finlab.tw/categories/%E5%AF%A6%E5%83%B9%E7%99%BB%E5%85%A5/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="房地產" scheme="https://www.finlab.tw/tags/%E6%88%BF%E5%9C%B0%E7%94%A2/"/>
    
  </entry>
  
  <entry>
    <title>用程式分析房地產可行嗎（1）房地產爬蟲</title>
    <link href="https://www.finlab.tw/real-estate-analysis1/"/>
    <id>https://www.finlab.tw/real-estate-analysis1/</id>
    <published>2019-08-21T02:10:05.000Z</published>
    <updated>2020-04-20T08:10:34.025Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/real-estate-analysis1/thumbnail.png" title="投資房產"></center><p>賺了一輩子的錢，還不如買對一戶房！<br>非常誇張，但又滿有道理的<br>假如一定要買房子，要買在哪裡呢？<br>如何找到抗跌的地段？<br>隨著屋齡不同，房價應該要如何變化呢？</p><p>這些問題，可能只有房地產專家一一為你解惑，<br>但一般人要買房，除了相信專家以外，還能怎麼辦呢？</p><p>利用程式來研究，自己當專家<br>現在台灣有實價登入的法規，這些資訊都是公開透明的<br>（雖然實價不等於真的成交價，但應該還是有正相關）</p><p>要爬取這些資訊，只要很短的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">real_estate_crawler</span><span class="params">(year, season)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> year &gt; <span class="number">1000</span>:</span><br><span class="line">    year -= <span class="number">1911</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># download real estate zip content</span></span><br><span class="line">  res = requests.get(<span class="string">"https://plvr.land.moi.gov.tw//DownloadSeason?season="</span>+str(year)+<span class="string">"S"</span>+str(season)+<span class="string">"&amp;type=zip&amp;fileName=lvr_landcsv.zip"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># save content to file</span></span><br><span class="line">  fname = str(year)+str(season)+<span class="string">'.zip'</span></span><br><span class="line">  open(fname, <span class="string">'wb'</span>).write(res.content)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># make additional folder for files to extract</span></span><br><span class="line">  folder = <span class="string">'real_estate'</span> + str(year) + str(season)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(folder):</span><br><span class="line">    os.mkdir(folder)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># extract files to the folder</span></span><br><span class="line">  <span class="keyword">with</span> zipfile.ZipFile(fname, <span class="string">'r'</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">      zip_ref.extractall(folder)</span><br><span class="line"></span><br><span class="line">  time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>然後我們再寫個 for 迴圈，就可以將近 8 年的房價買賣資訊都爬下來</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">real_estate_crawler(<span class="number">101</span>, <span class="number">3</span>)</span><br><span class="line">real_estate_crawler(<span class="number">101</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> range(<span class="number">102</span>, <span class="number">108</span>):</span><br><span class="line">  <span class="keyword">for</span> season <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    print(year, season)</span><br><span class="line">    real_estate_crawler(year, season)</span><br><span class="line"></span><br><span class="line">real_estate_crawler(<span class="number">108</span>, <span class="number">1</span>)</span><br><span class="line">real_estate_crawler(<span class="number">108</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>這邊就先簡單的放上爬蟲，也有<a href="https://colab.research.google.com/drive/1uDVzXC9e9hXKxoGPK5mryj-B3NSRxNVl" rel="external nofollow noopener noreferrer" target="_blank">線上colab範例直接運行</a></p><p>之後我們會來研究，<br>究竟那邊的房價衰退的比較快？<br>哪裡是比較抗跌的區域？<br>哪裡的房子最便宜又最抗跌？</p><p>假如你對這系列有興趣的話，<br>可以到<a href="https://www.facebook.com/finlab.python/" rel="external nofollow noopener noreferrer" target="_blank">粉絲團</a>的這篇文章按個讚<br>這樣我才知道這是大家想看的<br>才會繼續往下寫喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/real-estate-analysis1/thumbnail.png&quot; title=&quot;投資房產&quot;&gt;&lt;/center&gt;

&lt;p&gt;賺了一輩子的錢，還不如買對一戶房！&lt;br&gt;非常誇張，但又滿有道理的&lt;br&gt;假如一定要買房子，要買在哪裡呢？&lt;br&gt;
      
    
    </summary>
    
      <category term="實價登入" scheme="https://www.finlab.tw/categories/%E5%AF%A6%E5%83%B9%E7%99%BB%E5%85%A5/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="房地產" scheme="https://www.finlab.tw/tags/%E6%88%BF%E5%9C%B0%E7%94%A2/"/>
    
  </entry>
  
  <entry>
    <title>利用機器學習預測漲跌-優化方式（1）</title>
    <link href="https://www.finlab.tw/generate-labels-stop-loss-stop-profit/"/>
    <id>https://www.finlab.tw/generate-labels-stop-loss-stop-profit/</id>
    <published>2019-08-01T02:02:55.000Z</published>
    <updated>2019-08-11T18:33:20.308Z</updated>
    
    <content type="html"><![CDATA[<p>第二堂課程最近也終於走向穩定了，剛開始有一些的bug、RAM的優化上的問題，還請同學們多多擔待，<br>我們也會持許推出新的介紹，讓大家有更多可以加強機器學習的方式，<br>這一篇文章中，我們要針對以往的labeling方式進行優化，讓訓練出來的模型，可以有更準確的預測。<br>沒有參加課程的同學，也可以跟我們一起學習，下方的程式碼都是完全公開的！請大家自行拿取玩玩看喔！</p><center><img src="/generate-labels-stop-loss-stop-profit/thumbnail.png" title="thumbnail"></center><h1 id="機器學習-「features-和-labels」"><a href="#機器學習-「features-和-labels」" class="headerlink" title="機器學習 「features 和 labels」"></a>機器學習 「features 和 labels」</h1><p>假如您不知道Labeling是什麼，那我們這邊還是先簡單的介紹一下supervise機器學習(監督式機器學習)：<br>這一類的機器學習模型，可以想像是一個函式 function f，我們想要計算 <code>y = f(x)</code><br>其中 x 就是 features<br>另外 y 就是 labels<br>假如我們想要預測天氣，則 x 就是 溫度 濕度 等等，而 y 就是 0 或 1 代表是否會下雨<br>假如我們想要預測股價，則 x 就是 技術指標、財報等等，而 y 就是股價<br>機器學習就是產生這麼一個 function f，可以藉由 x 來推估 y，也就是 <code>y = f(x)</code><br>下方就是機器學習用來訓練的資料（x, y）的示意圖，其中 x 就是一些技術指標，而y就是買賣訊號</p><center><img src="/generate-labels-stop-loss-stop-profit/fl.png" title="feature_and_label"></center><p>機器學習模型（f）大部分是一個黑盒子，也就是我們不需要知道 f 的公式是什麼<br>（也不太可能顯示出來，因為太複雜了）</p><p>而我們就會先給一些 x 跟 y，並且讓演算法去產生 f，<br>這個就是 supervise 機器學習模型的基本概念</p><p>假如我們要用機器學習來預測股票，就要先有 x 跟 y，也就是 features 跟 labels<br>假如我們想要預測股價，要怎麼樣來製作 feature 跟 labels 呢？</p><h1 id="製作-Features"><a href="#製作-Features" class="headerlink" title="製作 Features"></a>製作 Features</h1><p>製作 feature 的資料，可以是一些財報、技術指標、我們課程中也有很多製作這些指標的方式，<br>相信網路上也有很多的介紹，由於不是此篇的重點，所以我就不多說明了XD</p><h1 id="製作-Labels"><a href="#製作-Labels" class="headerlink" title="製作 Labels"></a>製作 Labels</h1><p>製作 label 其實是非常至關重要的，假如 label 太難預測的話，模型會無法有效的訓練，<br>以往最基本的 label 製作方式是使用 fixed time horizon 來預測 w 個時間單位後的漲跌，<br>下圖就是 fixed time horizon 的 Labeling 方式</p><center><img src="/generate-labels-stop-loss-stop-profit/fixedtimehorizon.png" title="fixedtimehorizon"></center><p>上圖中在 p(t) 的時候，我們希望預測 p(t+w) 的股價，是比較高還是比較低<br>我們可以使用分類的方式，將股價的漲跌分成三個部分，也就是─1（跌）、0（不漲不跌）、1（漲）<br>這樣子我們就可以讓機器學習來預測，上面圖中，我們可以發現股價比之前的高，所以把它歸類在 1 ，也就是之後會漲</p><h2 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h2><p>然而這種方式有一個缺點，就是當今天模型叫我們買入的時候，一買就是持有 w 個時間單位，<br>不論股價大漲或大跌都必須繼續持有，不能停損停利，這樣就會導致風險無法控制。<br>當然我們可以在事後回測時加上停損停利，但是這樣就跟模型的初衷有違背，模型產生的label明明就是持有 w 個時間單位，沒有停損停利</p><p>為了解決上述問題，<br>[Prado 2018] Advances in Financial Machine Learning<br>提出了以下的新方法</p><h2 id="Triple-Barrier"><a href="#Triple-Barrier" class="headerlink" title="Triple Barrier"></a>Triple Barrier</h2><p>這個方法的示意圖如下：</p><center><img src="/generate-labels-stop-loss-stop-profit/triplebarrier.png" title="triplebarrier"></center><p>乍看之下跟 fixed time horizon 有點類似，不過這個方法將分類的方式做了一些改進，<br>上圖中，用了三種不同顏色的「柵欄」，當股價從 p(t) 開始出發，隨時間不斷延伸<br>一定會碰到三個柵欄中的其中一個，而這三個柵欄分別代表了不同的意義：</p><ul><li>1（停利）</li><li>0（持有 w 個時間單位）</li><li>─1（停損）</li></ul><p>如此一來，我們就可以讓機器學習來預測「包含停損停利獲利狀況」，訓練出來的模型就可以跟回測的設定相符，增加機器學習的可預測性！<br>雖然概念很好理解，但要寫成程式碼還是需要一點功力，尤其是執行速度快一點的程式碼，下面就分享如何產生此類的label</p><h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><p>首先我們可以藉由<a href="/Python新手教學2全球指數一次抓/">股價爬蟲這篇</a>裡面介紹的程式碼，來獲得股價，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = crawl_price(<span class="string">"2354.TW"</span>)</span><br><span class="line">df.Close.plot()</span><br></pre></td></tr></table></figure><center><img src="/generate-labels-stop-loss-stop-profit/price.png" title="price"></center><p>針對以上的程式碼，<br>假如想知道 <code>crawl_price</code> 的實做，可以點入<a href="/Python新手教學2全球指數一次抓/">股價爬蟲這篇</a> </p><p>接下來就可以來製作 labels 了<br>在我們的機器學習影音課程中，使用的是 fixed time horizon 的方式，先來看看效果如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date = <span class="string">'2017'</span></span><br><span class="line">df.Close[date].plot()</span><br><span class="line">(df.Close.shift(<span class="number">-20</span>) / df.Close &gt; <span class="number">1</span>).astype(int)[date].plot(secondary_y=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><center><img src="/generate-labels-stop-loss-stop-profit/signal1.png" title="signal1"></center><p>上圖中藍色的為股價，對應到左邊的y軸，黃色的是訊號，對應到右邊的y軸，<br>也就是機器學習要學的 label，其中 1 代表買入，0 代表賣出，<br>看起來效果有些不OK，因為訊號會在短時間內上下跳動，讓我們不知道到底該買還是賣，<br>所以接下來我們就來試試看剛剛所介紹的 triple barrier 產生出來的 label。</p><p>下面這段是非常珍貴的程式碼<br>就連 Advances in Financial Machine Learning 書中附帶的程式碼，<br>都沒有以下的程式碼更簡潔、更完整、更有效率<br>假如你的 pandas 技巧不夠好的話，請直接拿去使用就可以了XD，不用太深究此 function 中的程式碼</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triple_barrier</span><span class="params">(price, ub, lb, max_period)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end_price</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.append(s[(s / s[<span class="number">0</span>] &gt; ub) | (s / s[<span class="number">0</span>] &lt; lb)], s[<span class="number">-1</span>])[<span class="number">0</span>]/s[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    r = np.array(range(max_period))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end_time</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.append(r[(s / s[<span class="number">0</span>] &gt; ub) | (s / s[<span class="number">0</span>] &lt; lb)], max_period<span class="number">-1</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    p = price.rolling(max_period).apply(end_price, raw=<span class="keyword">True</span>).shift(-max_period+<span class="number">1</span>)</span><br><span class="line">    t = price.rolling(max_period).apply(end_time, raw=<span class="keyword">True</span>).shift(-max_period+<span class="number">1</span>)</span><br><span class="line">    t = pd.Series([t.index[int(k+i)] <span class="keyword">if</span> <span class="keyword">not</span> math.isnan(k+i) <span class="keyword">else</span> np.datetime64(<span class="string">'NaT'</span>) </span><br><span class="line">                   <span class="keyword">for</span> i, k <span class="keyword">in</span> enumerate(t)], index=t.index).dropna()</span><br><span class="line"></span><br><span class="line">    signal = pd.Series(<span class="number">0</span>, p.index)</span><br><span class="line">    signal.loc[p &gt; ub] = <span class="number">1</span></span><br><span class="line">    signal.loc[p &lt; lb] = <span class="number">-1</span></span><br><span class="line">    ret = pd.DataFrame(&#123;<span class="string">'triple_barrier_profit'</span>:p, <span class="string">'triple_barrier_sell_time'</span>:t, <span class="string">'triple_barrier_signal'</span>:signal&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">ret = triple_barrier(df.Close, <span class="number">1.07</span>, <span class="number">0.97</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>這個 function 的使用方法，就是將</p><ul><li>時間序列（程式碼中的<code>df.Close</code>）</li><li>停利(程式碼中<code>1.07</code>是指7％停利）</li><li>停損(程式碼中<code>0.97</code>是指3％停損）</li><li>最大持有時間（20天）</li></ul><p>分別丟入 <code>triple_barrier</code> 函式當中，就可以計算出以下的 <code>Dataframe</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret.head()</span><br></pre></td></tr></table></figure><center><img src="/generate-labels-stop-loss-stop-profit/result.png" title="result"></center><p>上圖中有三條序列，其中 <code>index</code> 是日期，另外三條時間序列分別是：</p><ul><li>triple_barrier_profit 當天買入，直到停損停利後，未來的獲利狀況</li><li>triple_barrier_sell_time 當天買入，未來會持有的時間</li><li>triple_barrier_signal 當天買入，未來觸發的是停損停利</li></ul><p>我們可以將 <code>triple_barrier_signal</code> 訊號跟股價一起畫出來比較一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date = <span class="string">'2017'</span></span><br><span class="line">df.Close[date].plot()</span><br><span class="line">ret.triple_barrier_signal[date].plot(secondary_y=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><center><img src="/generate-labels-stop-loss-stop-profit/signal2.png" title="signal2"></center><p>label 的訊號變得比較乾淨，試試看訓練出更好的模型吧！<br>可以使用 <a href="https://colab.research.google.com/drive/1D_UuxCc7zkfv_FkHig29SXTxwlxhle6u" rel="external nofollow noopener noreferrer" target="_blank">google colab 線上編輯此代碼</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第二堂課程最近也終於走向穩定了，剛開始有一些的bug、RAM的優化上的問題，還請同學們多多擔待，&lt;br&gt;我們也會持許推出新的介紹，讓大家有更多可以加強機器學習的方式，&lt;br&gt;這一篇文章中，我們要針對以往的labeling方式進行優化，讓訓練出來的模型，可以有更準確的預測。&lt;
      
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>論文導讀：利用CNN神經網路來交易ETF</title>
    <link href="https://www.finlab.tw/cnn-time-series-image-conversion-approach/"/>
    <id>https://www.finlab.tw/cnn-time-series-image-conversion-approach/</id>
    <published>2019-07-17T09:25:49.000Z</published>
    <updated>2019-08-01T02:00:48.183Z</updated>
    
    <content type="html"><![CDATA[<p>文章導讀：機器學習用來投資一直都是非常熱門的學問，近年來深度學習模型開始受到非常多的矚目，尤其是在電腦視覺方面，所以接下來導讀的這篇文章，就是提供了一個全新的方式，將目前最火紅的 視覺神經網路：Convolutional Neural Network（CNN）用來預測股票的漲跌。實驗解果表示效果比一般的神經網路要好。</p><center><img src="/cnn-time-series-image-conversion-approach/title.png" title="該方法的示意圖"></center><p>你可能會問，以time series來說，明明神經網路可以使用 LSTM，為何要用 CNN？LSTM應該比較適合處理時間序列呀！（畢竟LSTM是拿來處理文字字串的神經網路，字串也是一種時間序列，所以通常預測股價，大家會用LSTM）。但文章中說明，目前CNN用於圖像處理比起其他的模型，被研究的更透徹，也有大量的研發，所以說不定效果更好，所以採用了 CNN 神經網路來預測股價的漲跌</p><p>他們用15個技術指標 X 15 天，產生出一個 15x15 的影像，將這個影像丟入 CNN 神經網路中做訓練，下圖就是神經網路所「看到」的input：</p><center><img src="/cnn-time-series-image-conversion-approach/input.png" title="用眼睛看訊號"></center><p>想想對於人類來說，這個影像對我們來講沒什麼意義，但是對於電腦來說，就可以拿來判斷股價的漲跌喔！還滿酷的！我只是在想為何是15x15為何不將圖像變的大一點？</p><p>我們會將上面這些圖片稱之為features，也就是電腦用來判斷買賣的資訊，電腦用這些資訊，就可以預測交易訊號，也就是這個神經網路的label。作者提供了一個簡單的方式，使用rolling window，去找每段時間的最大值最小值，以下是大致上的程式碼，有興趣的話可以深入研究，不過我們在這邊就點到為止。</p><center><img src="/cnn-time-series-image-conversion-approach/label.png" title="生成label的方式"></center><p>上述的方法，會產生（-1, 0, 1）的訊號，分別代表（賣、不做動作、買），但是由上述程式碼產生出來的訊號，必然會有imbalance的問題，也就是三種class的數量不一致，所以本篇文章使用random resampling的方式，隨機取出相同數量的 label 對應到的 testcase，來避免 0 太多的問題。</p><p>此篇 paper 中用了美股的 ETF 和 道瓊 30 檔成分股當訓練的標的。<br>有了 feature 跟 label，很理所當然的，我們就可以開始訓練了！<br>此篇 paper 的神經網路如下：</p><center><img src="/cnn-time-series-image-conversion-approach/cnn.png" title="神經網路"></center><ul><li>input layer (15x15), </li><li>two convolutional layers (15x15x32, 15x15x64),</li><li>max pooling (7x7x64), </li><li>two dropout (0.25, 0.50), </li><li>fully connected layers (128),</li><li>output layer (3)</li></ul><p>上面的架構中，input就是單純的 15 x 15 的圖片，output 有3個，分別是買、賣、不做動作。<br>中間的 convolutional layers 跟 pooling<br>作者說由於training dataset不大的關係，所以神經網路不用太大，不然會造成overfitting的狀況。</p><p>這篇 paper 使用 walk forward 的方式來測試，好處是可以產生時間較長的回測結果，<br>以下就是他們的回測績效（其中兩檔ETF）：</p><center><img src="/cnn-time-series-image-conversion-approach/backtest.png" title="回測結果"></center><p>而他們也有將效果跟其他的神經網路作比較，幾種常用的方法：</p><ul><li>CNN-TAr 作者使用的方法</li><li>BaHr 所謂的 buy and Hold 長期持有</li><li>RSIr 利用 RSI技術指標做出來的策略</li><li>SMAr 均線策略 </li><li>LSTMr 神經網路策略pip</li><li>MLPr 一般神經網路策略</li></ul><p>下圖就是商品（每一個row）和不同策略（每一個column）所對應到的年報酬率：</p><center><img src="/cnn-time-series-image-conversion-approach/compare.png" title="回測結果"></center><p>可以發現這種神經網路的效果比其他的更好！在大部分的商品都有比較好的年報酬率喔～</p><p>更多內容都可以參考該<a href="https://www.researchgate.net/profile/Omer_Sezer/publication/324802031_Algorithmic_Financial_Trading_with_Deep_Convolutional_Neural_Networks_Time_Series_to_Image_Conversion_Approach/links/5ae4ade9a6fdcc3bea95d2fd/Algorithmic-Financial-Trading-with-Deep-Convolutional-Neural-Networks-Time-Series-to-Image-Conversion-Approach.pdf" rel="external nofollow noopener noreferrer" target="_blank">論文的連結</a>喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章導讀：機器學習用來投資一直都是非常熱門的學問，近年來深度學習模型開始受到非常多的矚目，尤其是在電腦視覺方面，所以接下來導讀的這篇文章，就是提供了一個全新的方式，將目前最火紅的 視覺神經網路：Convolutional Neural Network（CNN）用來預測股票的
      
    
    </summary>
    
      <category term="AI看股票" scheme="https://www.finlab.tw/categories/AI%E7%9C%8B%E8%82%A1%E7%A5%A8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Machine Learning" scheme="https://www.finlab.tw/tags/Machine-Learning/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="選股" scheme="https://www.finlab.tw/tags/%E9%81%B8%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python 低風險高報酬投資組合</title>
    <link href="https://www.finlab.tw/low-risk-fft-spy-strategy/"/>
    <id>https://www.finlab.tw/low-risk-fft-spy-strategy/</id>
    <published>2019-06-13T14:07:22.000Z</published>
    <updated>2019-06-17T09:01:41.646Z</updated>
    
    <content type="html"><![CDATA[<p>投資可以很複雜，超多的商品選擇，分批持有買賣點設定等等，但是每天花這麼多心力，真的有比大盤好嗎？<br>其實投資也可以很簡單的，我們可以稍微更智慧一點，投資「大盤」跟「公債」！</p><center><img src="/low-risk-fft-spy-strategy/big.png" title="thumbnail"></center><p>今天就是要來介紹一個簡單的策略，<br>此策略的 sharpe ratio 高達 1.2 非常高，但其實原理並不難，也不需要太多的技巧<br>用一句話就講完了：</p><h3 id="將資產分兩半：SPY-跟-20年公債"><a href="#將資產分兩半：SPY-跟-20年公債" class="headerlink" title="將資產分兩半：SPY 跟 20年公債"></a>將資產分兩半：SPY 跟 20年公債</h3><ul><li>一半投資「標準普爾500指數ETF」</li><li>一半投資「iShares 20年期以上美國公債ETF〈TLT〉」</li></ul><p>這種策略的大致上的原理就是「找兩個相關係數為負，且會隨時間增值的商品」<br>這樣的策略效果究竟如何呢？一半一半？這樣的比例真的好嗎？<br>我們可以用<a href="/ffn-intro/">上一篇文章 ffn python package</a>，來做回測看看效果如何</p><p>大家可以點<a href="https://colab.research.google.com/drive/1rR3fvVliWQ1Q93xjO9qpd-nOhzfvWY2a" rel="external nofollow noopener noreferrer" target="_blank">這裡到程式碼，並且線上打扣！</a></p><h3 id="安裝-ffn："><a href="#安裝-ffn：" class="headerlink" title="安裝 ffn："></a>安裝 ffn：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install ffn</span><br></pre></td></tr></table></figure><h3 id="獲取資料"><a href="#獲取資料" class="headerlink" title="獲取資料"></a>獲取資料</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ffn</span><br><span class="line">prices = ffn.get(&quot;spy,tlt&quot;, )</span><br><span class="line">prices.plot()</span><br></pre></td></tr></table></figure><center><img src="/low-risk-fft-spy-strategy/spytlt.png" title="spy_and_tlt"></center><p>仔細看這兩個指數確實有呈現一點負相關，特別是 SPY 下跌的時候，TLT會些微的上漲</p><h3 id="將資產分一半，投資回測"><a href="#將資產分一半，投資回測" class="headerlink" title="將資產分一半，投資回測"></a>將資產分一半，投資回測</h3><p>這邊我們只拿「SPY」跟「TLT」，其實有很多的策略組合也會有「石油」、「新興市場」、「黃金」等等<br>大家到時候也可以去自行變化，找出比較好的投資組合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prices.rebase().mean(axis=1).plot()</span><br></pre></td></tr></table></figure><center></center><p>雖然比直接投資sp500還要差，但是整體來說看起來更穩定的感覺<br>究竟我們有沒有辦法橫兩，這樣的組合是否是最好的呢？</p><p>不然我們就暴力計算一下，將幾種組合都寫出來：</p><table><thead><tr><th>策略</th><th>配置1</th><th>配置2</th><th>配置3</th><th>…</th><th>配置10</th><th>配置11</th></tr></thead><tbody><tr><td>SPY</td><td>0</td><td>0.1</td><td>0.2</td><td>…</td><td>0.9</td><td>1.0</td></tr><tr><td>TLT</td><td>1.0</td><td>0.9</td><td>0.8</td><td>…</td><td>0.1</td><td>0</td></tr></tbody></table><p>那我們把這幾種配置都回測一次試試看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">strategies = &#123;&#125;</span><br><span class="line"></span><br><span class="line">for i in np.arange(0, 1.1, 0.1):</span><br><span class="line">    title = &quot;spy: %.1f | tlt: %.1f&quot; % (i, 1-i)</span><br><span class="line">    strategies[title] = (prices.rebase() * [i, 1-i]).mean(axis=1).rebase()</span><br><span class="line"></span><br><span class="line">strategies = pd.DataFrame(strategies)</span><br><span class="line"></span><br><span class="line">strategies.plot()</span><br></pre></td></tr></table></figure><center><img src="/low-risk-fft-spy-strategy/combination.png" title="各種不同的報酬率"></center><p>可以發現TLT比重比較重，則報酬率比較低，<br>SPY比重比較重，則報酬率比較高<br>除了報酬率以外，我們還有哪些指標可以來量化這些策略的績效呢？</p><p>我們可以用 ffn 提供的 <code>calc_stats</code> 來計算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stats = strategies.calc_stats()</span><br><span class="line">stats = pd.DataFrame(</span><br><span class="line">    &#123;</span><br><span class="line">        name:pd.Series(&#123;key:getattr(pf, key) for key in dir(pf) if isinstance(getattr(pf, key), float)&#125;, name=name) </span><br><span class="line">        for name,pf in stats.items()</span><br><span class="line">    &#125;).transpose()</span><br><span class="line"></span><br><span class="line">stats.head()</span><br></pre></td></tr></table></figure></p><center><img src="/low-risk-fft-spy-strategy/performance.png" title="績效檢測"></center><p>這樣我們就有一張策略的績效總表了，這張 dataframe 非常大一張，要怎麼看有哪些分析數據呢？<br>我們可以利用 <code>stats.columns</code> 查看可以比較的策略績效指標：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stats.columns</span><br></pre></td></tr></table></figure></p><center><img src="/low-risk-fft-spy-strategy/plist.png" title="量畫清單"></center><p>我們可以利用 <code>.plot</code> 將不同的績效比較給畫出來，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stats[&apos;daily_sharpe&apos;].plot(rot=10, color=&apos;blue&apos;)</span><br><span class="line">stats[&apos;monthly_vol&apos;].plot(rot=10, color=&apos;red&apos;, secondary_y=True)</span><br></pre></td></tr></table></figure><center><img src="/low-risk-fft-spy-strategy/volsp.png" title="很多sharpeRatio"></center><p>上圖中有兩線，</p><ul><li>藍色的是 <a href="/Python新手教學：風險與報酬/">sharpe ratio</a>，代表 「報酬」/ 「風險」 的比例</li><li>紅色的是「每月報酬」的波動程度，</li></ul><p>可以發現，風險報酬比（藍色）最佳位置，剛好就是在 「一半一半」的資產配置上<br>對應到「每月報酬」最穩定的，也剛好就是在「一半一半」的資產配置上</p><p>這說明了投資好像不用搞太多花俏的東西，直要簡單粗暴就是最好的！<br>上面的 sharpe ratio 是用簡單的「每天」的 sharpe ratio，</p><p>不過假如你是投資長線的話，其實不用太計較每天的 sharpe，應該要看的是每個月，甚至是每年的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stats[&apos;yearly_sharpe&apos;].plot()</span><br><span class="line">stats[&apos;monthly_sharpe&apos;].plot()</span><br><span class="line">stats[&apos;daily_sharpe&apos;].plot()</span><br></pre></td></tr></table></figure><center><img src="/low-risk-fft-spy-strategy/srs.png" title="很多sharpeRatio"></center><p>假如我們不要「每天」跟報酬率計較，而改成是「每個月」或「每年」的時候，<br>由上圖中可以知道，SPY 比例從 0.5~0.7 都是不錯的配置方式<br>不過這 1.3 以上的 sharpe ratio 其實算是滿驚人的（不過沒算上金融海嘯，所以…稍微不準）<br>我平常可能大費周章，搞了半天也弄不出這麼好的資產配置XD</p><p>接下來看平均年報酬率：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stats[&apos;yearly_mean&apos;]</span><br></pre></td></tr></table></figure></p><center><img src="/low-risk-fft-spy-strategy/returns.png" title="每年報酬率"></center><p>還可以！你想想看完全不看盤得到5%以上的獲利，已經非常爽了！<br>老實說這樣的組合還有很多可以玩的地方，例如加入定期權益平衡，<br>也就是每個月去重新調整持股比例，漲多的賣，跌多的買，重新將權重調整回原點。<br>我們下次會來介紹進化版策略的回測，讓這個簡單的策略再進化<br>可以定期追蹤 FinLab 一起來研究投資這件事情吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;投資可以很複雜，超多的商品選擇，分批持有買賣點設定等等，但是每天花這麼多心力，真的有比大盤好嗎？&lt;br&gt;其實投資也可以很簡單的，我們可以稍微更智慧一點，投資「大盤」跟「公債」！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/low-risk-fft-spy-strategy
      
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="簡易策略" scheme="https://www.finlab.tw/tags/%E7%B0%A1%E6%98%93%E7%AD%96%E7%95%A5/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>好用Package：用ffn分析時間序列</title>
    <link href="https://www.finlab.tw/ffn-intro/"/>
    <id>https://www.finlab.tw/ffn-intro/</id>
    <published>2019-06-03T04:42:35.000Z</published>
    <updated>2019-06-13T14:11:05.315Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas 的 DataFrame 可以很方變得幫我們處理時間序列，只需要短短幾行，就能達到在其他程式語言要寫數十行的功能</p><h1 id="但是DataFrame就夠了嗎？"><a href="#但是DataFrame就夠了嗎？" class="headerlink" title="但是DataFrame就夠了嗎？"></a>但是DataFrame就夠了嗎？</h1><p>當我們在處理財務金融時，常常會需要分析時間序列（例如股價），雖然我們可能都知道什麼是maximum dropdown、什麼是sharp ratio，什麼是daily<br>return，但是有時候用dataframe來計算，還是免不了寫一些數學計算，增加程式碼的複雜度，讓閱讀程式碼變得比較辛苦。</p><h1 id="救星：ffn-Financial-Functions-for-Python"><a href="#救星：ffn-Financial-Functions-for-Python" class="headerlink" title="救星：ffn (Financial Functions for Python)"></a>救星：ffn (Financial Functions for Python)</h1><center><img src="/ffn-intro/th.png" title="info"></center><p>所以這時候，你的救星就出現了，叫做<a href="http://pmorissette.github.io/ffn/" rel="external nofollow noopener noreferrer" target="_blank">ffn</a>，ffn是一個分析時間序列的package，只要一import ffn，你的dataframe就會瞬間多了很多能力！接下來我們就來看看是什麼能力吧！</p><p>這次的程式碼都會在<a href="https://colab.research.google.com/drive/1lzqgK-ERM4bH5GYRyQNPURBhFKhQ9x6q" rel="external nofollow noopener noreferrer" target="_blank">google colab</a>上，大家可以直接打開網頁就開始跟我們一起玩耍吧！</p><p>首先，我們必須要先安裝ffn，安裝的方式非常的直覺：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install ffn</span><br></pre></td></tr></table></figure><br>這樣就安裝好囉！上式中的驚嘆號代表我們將這段command line語法，輸入在jupyter來安裝，這又就不需要額外再開啟terminal了！</p><p>安裝好了之後我們就可以開始寫程式囉！</p><h1 id="利用ffn取得股價"><a href="#利用ffn取得股價" class="headerlink" title="利用ffn取得股價"></a>利用ffn取得股價</h1><p>有了ffn我們可以很輕易的取得多檔股票的股價，ffn的底層是使用yahoo api，所以同樣也可以抓台股或其他國際股市喔！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ffn</span><br><span class="line"></span><br><span class="line">prices = ffn.get(&apos;2330.TW, 1101.TW&apos;)</span><br><span class="line">prices.head()</span><br></pre></td></tr></table></figure></p><center><img src="/ffn-intro/1.png" title="股價"></center><p>可以發現這個股價的格是就是我們熟悉的dataframe耶！所以我們一樣可以使用一些dataframe既有的功能，例如「.plot」來繪圖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prices.plot()</span><br></pre></td></tr></table></figure><center><img src="/ffn-intro/2.png" title="股價2"></center><p>繪完圖後發現，雖然我們可以比較「2330」台積電，跟「1101」台泥的股價，但是他們的起始股價是不一樣的，所以無從比較報酬率。</p><p>想要比較報酬率，我們可以用「ffn」新增的額外功能「rebase」：</p><h1 id="ffn提供的functions"><a href="#ffn提供的functions" class="headerlink" title="ffn提供的functions"></a>ffn提供的functions</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prices.rebase().plot()</span><br></pre></td></tr></table></figure><center><img src="/ffn-intro/3.png" title="dropdown"></center><p>這樣就可以讓股價的起始值相同囉！這是ffn提供的眾多功能之一，但你不用額外學一個新的資料表示法，而是直接對dataframe操作就可以了！所以說ffn有點像是dataframe的補充包，讓我們來看看還有哪些好用的功能吧！</p><h1 id="下跌幅度"><a href="#下跌幅度" class="headerlink" title="下跌幅度"></a>下跌幅度</h1><p>我們可以藉由ffn來計算並比較dropdown，也就是比較虧損的幅度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prices.to_drawdown_series().plot()</span><br></pre></td></tr></table></figure><center><img src="/ffn-intro/4.png" title="heat"></center><p>或是我們之前教過的heatmap，也一行就搞定了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prices.plot_corr_heatmap()</span><br></pre></td></tr></table></figure><center><img src="/ffn-intro/5.png" title="heat2"></center><p>最後我們也可以來計算這兩檔股票的歷史數據分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stats = prices.calc_stats()</span><br><span class="line">stats.display()</span><br></pre></td></tr></table></figure><center><img src="/ffn-intro/6.png" title="info"></center><p>這個輕量級的package有很多簡單的語法，可以快速幫助我們進行報酬率的分析<br>而且所有的功能都是使用dataframe擴增，所以不用擔心要學新的結構，滿小巧可愛的！<br>大家可以安裝起來玩玩看喔！  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Pandas 的 DataFrame 可以很方變得幫我們處理時間序列，只需要短短幾行，就能達到在其他程式語言要寫數十行的功能&lt;/p&gt;
&lt;h1 id=&quot;但是DataFrame就夠了嗎？&quot;&gt;&lt;a href=&quot;#但是DataFrame就夠了嗎？&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(7)：策略優化</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%EF%BC%9A%E7%AD%96%E7%95%A5%E5%84%AA%E5%8C%96/"/>
    <id>https://www.finlab.tw/Python新手教學：策略優化/</id>
    <published>2019-02-25T08:04:20.000Z</published>
    <updated>2019-03-09T13:17:45.370Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中，帶大家寫了一個簡單的策略，<br>然而，在現實生活中並沒有這麼管用，20年才賺三倍！？</p><p>所以這篇文章將帶介紹如何利用修改參數，來調整策略，進而達到更好的績效<br>但是人工調整參數很浪費時間，所以我們先使用簡單暴力法，來調整參數試試看。</p><p>成果如下：</p><center><img src="/Python新手教學：策略優化/result.png" title="最終成果2"></center><h3 id="先回顧上次的策略"><a href="#先回顧上次的策略" class="headerlink" title="先回顧上次的策略"></a>先回顧上次的策略</h3><p>由於這是系列文章，要完成到上次的步驟其實有點煩瑣，<br>所以這邊就簡單的前情提要一下<br>總共有三個步驟：</p><ol><li>下載台股大盤資料</li><li>編寫台股的sharpe ratio</li><li>利用sharpe ratio製作回測</li></ol><p>這邊就不厭其煩的先把上次的code拿來，方便大家直接複製貼上</p><h3 id="1-下載台股大盤資料"><a href="#1-下載台股大盤資料" class="headerlink" title="1. 下載台股大盤資料"></a>1. 下載台股大盤資料</h3><p>以下這段程式，已經於「<a href="/Python新手教學2全球指數一次抓/">全球指數一次抓</a>」講過了，<br>假如想瞭解的話，可以去爬個文，這邊就不贅述了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.style.use(<span class="string">'ggplot'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_price</span><span class="params">(stock_id)</span>:</span></span><br><span class="line">    now = int(datetime.datetime.now().timestamp())+<span class="number">86400</span></span><br><span class="line">    url = <span class="string">"https://query1.finance.yahoo.com/v7/finance/download/"</span> + stock_id + <span class="string">"?period1=0&amp;period2="</span> + str(now) + <span class="string">"&amp;interval=1d&amp;events=history&amp;crumb=hP2rOschxO0"</span></span><br><span class="line"></span><br><span class="line">    response = requests.post(url)</span><br><span class="line"></span><br><span class="line">    f = io.StringIO(response.text)</span><br><span class="line">    df = pd.read_csv(f, index_col=<span class="string">'Date'</span>, parse_dates=[<span class="string">'Date'</span>] )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">twii = crawl_price(<span class="string">"^TWII"</span>)</span><br><span class="line">twii.head()</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學：策略優化/2.png" title="台股"></center><h3 id="2-編寫台股的sharpe-ratio"><a href="#2-編寫台股的sharpe-ratio" class="headerlink" title="2. 編寫台股的sharpe ratio"></a>2. 編寫台股的sharpe ratio</h3><p>接下來我們就來計算sharpe ratio，這邊同樣於「<a href="/Python新手教學：風險與報酬/">Python新手教學：風險與報酬</a>」講過了<br>就請有興趣的大家多多複習囉！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mean = twii[<span class="string">'Adj Close'</span>].pct_change().rolling(<span class="number">252</span>).mean()</span><br><span class="line">std = twii[<span class="string">'Adj Close'</span>].pct_change().rolling(<span class="number">252</span>).std()</span><br><span class="line"></span><br><span class="line">sharpe = mean / std</span><br><span class="line"></span><br><span class="line">twii.Close.plot()</span><br><span class="line">sharpe.plot(secondary_y=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學：策略優化/3.png" title="夏普"></center><h3 id="3-編寫台股sharpe-ratio策略"><a href="#3-編寫台股sharpe-ratio策略" class="headerlink" title="3. 編寫台股sharpe ratio策略"></a>3. 編寫台股sharpe ratio策略</h3><p>接下來就是編寫sharpe ratio 的策略了，同樣可以到<a href="python新手教學：夏普指數策略/">python新手教學：夏普指數策略</a><br>這篇文章中，得到更詳細的解釋</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># sharpe ratio 平滑</span></span><br><span class="line">sr = sharpe</span><br><span class="line">srsma = sr.rolling(<span class="number">60</span>).mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># sharpe ratio 的斜率</span></span><br><span class="line">srsmadiff = srsma.diff()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算買入賣出點</span></span><br><span class="line">buy = (srsmadiff &gt; <span class="number">0</span>) &amp; (srsmadiff.shift() &lt; <span class="number">0</span>)</span><br><span class="line">sell = (srsmadiff &lt; <span class="number">0</span>) &amp; (srsmadiff.shift() &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算持有時間</span></span><br><span class="line">hold = pd.Series(np.nan, index=buy.index)</span><br><span class="line">hold[buy] = <span class="number">1</span></span><br><span class="line">hold[sell] = <span class="number">0</span></span><br><span class="line">hold.ffill(inplace=<span class="keyword">True</span>)</span><br><span class="line">hold.plot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 持有時候的績效</span></span><br><span class="line">adj = twii[<span class="string">'Adj Close'</span>][buy.index]</span><br><span class="line">(adj.pct_change().shift(<span class="number">-1</span>)+<span class="number">1</span>).fillna(<span class="number">1</span>)[hold == <span class="number">1</span>].cumprod().plot()</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學：策略優化/5.png" title="回測結果"></center><h3 id="別轉台，終於要開始參數最佳化了"><a href="#別轉台，終於要開始參數最佳化了" class="headerlink" title="別轉台，終於要開始參數最佳化了"></a>別轉台，終於要開始參數最佳化了</h3><p>我們將上面的程式碼包成一個函示如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtest</span><span class="params">(a, b, c, d)</span>:</span></span><br><span class="line">    sr = sharpe</span><br><span class="line">    srsma = sr.rolling(a).mean()</span><br><span class="line"></span><br><span class="line">    srsmadiff = srsma.diff() * <span class="number">100</span></span><br><span class="line">    ub = srsmadiff.quantile(b)</span><br><span class="line">    lb = srsmadiff.quantile(c)</span><br><span class="line">    </span><br><span class="line">    buy = ((srsmadiff.shift(d) &lt; lb) &amp; (srsmadiff &gt; ub))</span><br><span class="line">    sell = ((srsmadiff.shift(d) &gt; ub) &amp; (srsmadiff &lt; lb))</span><br><span class="line"></span><br><span class="line">    hold = pd.Series(np.nan, index=buy.index)</span><br><span class="line">    hold[buy] = <span class="number">1</span></span><br><span class="line">    hold[sell] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    hold.ffill(inplace=<span class="keyword">True</span>)</span><br><span class="line">    </span><br><span class="line">    adj = twii[<span class="string">'Adj Close'</span>][buy.index]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># eq = (adj.pct_change().shift(-1)+1).fillna(1)[hold == 1].cumprod().plot()</span></span><br><span class="line">    <span class="comment"># hold.plot()</span></span><br><span class="line">    eq = (adj.pct_change().shift(<span class="number">-1</span>)+<span class="number">1</span>).fillna(<span class="number">1</span>)[hold == <span class="number">1</span>].cumprod()</span><br><span class="line">    <span class="keyword">if</span> len(eq) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> eq.iloc[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">backtest(<span class="number">252</span>,<span class="number">0.4</span>,<span class="number">0.6</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>可以發現，這個function傳入了四個參數「a,b,c,d」，<br>而這四個參數是做什麼的呢？是拿來取代原本的數字的，<br>可以發現原本的常數部分，都被換成了代數，這樣我們到時候在呼叫時，就可以帶入不同的參數<br>而我們最後的回傳值，原本是一張圖片，但此function中被改成了這20年的報酬率<br>所以當我們執行「backtest(252,0.4,0.6,4)」的時候，<br>這20年的報酬就是9.1%，非常爛<br>所以我們才需要做參數優化</p><h3 id="參數枚舉優化"><a href="#參數枚舉優化" class="headerlink" title="參數枚舉優化"></a>參數枚舉優化</h3><p>我們使用暴力法，將所有的可能的參數都找一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">maxeq = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">100</span>,<span class="number">200</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> np.arange(<span class="number">0.3</span>, <span class="number">0.9</span>, <span class="number">0.03</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> np.arange(<span class="number">0.3</span>, <span class="number">0.6</span>, <span class="number">0.03</span>):</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> range(<span class="number">60</span>, <span class="number">180</span>, <span class="number">10</span>):</span><br><span class="line">                </span><br><span class="line">                eq = backtest(a,b,c,d)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> maxeq &lt; eq:</span><br><span class="line">                    maxeq = eq</span><br><span class="line">                    print(eq, a,b,c,d)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學：策略優化/3.png" title="最終成果"></center><p>上面第8行，即是我們執行backtest的結果，<br>假如我們發現eq，有最高報酬率，<br>則將新的最高報酬率print出來，並且print它的參數<br>我們就可以看到數字不斷增加的感覺，滿開心的！<br>不過上述程式要跑滿久的，請耐心等待，</p><p>最後成果滿不錯的，算是一個懶人投資策略：</p><center><img src="/Python新手教學：策略優化/4.png" title="最終成果"></center><p>有興趣的可以到<a href="https://www.facebook.com/finlab.python/?ref=bookmarks" rel="external nofollow noopener noreferrer" target="_blank">粉絲團</a>按讚，才不會錯過接下來精彩文章喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章中，帶大家寫了一個簡單的策略，&lt;br&gt;然而，在現實生活中並沒有這麼管用，20年才賺三倍！？&lt;/p&gt;
&lt;p&gt;所以這篇文章將帶介紹如何利用修改參數，來調整策略，進而達到更好的績效&lt;br&gt;但是人工調整參數很浪費時間，所以我們先使用簡單暴力法，來調整參數試試看。&lt;/p&gt;

      
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python新手教學(6)：夏普指數策略</title>
    <link href="https://www.finlab.tw/python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%EF%BC%9A%E5%A4%8F%E6%99%AE%E6%8C%87%E6%95%B8%E7%AD%96%E7%95%A5/"/>
    <id>https://www.finlab.tw/python新手教學：夏普指數策略/</id>
    <published>2019-02-19T12:46:47.000Z</published>
    <updated>2019-03-11T11:17:28.518Z</updated>
    
    <content type="html"><![CDATA[<p>上一集我們介紹了Sharpe ratio，可以用來衡量風險跟報酬的指標（也就是報酬 / 風險），這集我們就利用Sharpe ratio來進行台股的模擬買賣，假裝我們這20年來，都使用sharpe ratio的策略，可以得到多少獲利呢？</p><a id="more"></a><center><img src="/python新手教學：夏普指數策略/6.png" title="績效計算"></center><h3 id="為何Sharpe-ratio幾乎都小於一"><a href="#為何Sharpe-ratio幾乎都小於一" class="headerlink" title="為何Sharpe ratio幾乎都小於一"></a>為何Sharpe ratio幾乎都小於一</h3><p>上次有人問我，夏普指標小於一，代表風險（分母）大於獲利（分子），而為什麼市面上所有的指數，其sharpe ratio都小於一，難道股票都不能賺錢嗎？</p><p>這只是代表，在股市中，我們為了要獲利，往往需要承受很大的風險！但不代表長期投資下來是不能獲利的。我們必須要找到sharpe ratio比較高的策略，才能使風險降低，獲利升高。</p><h3 id="利用Python研發一個策略"><a href="#利用Python研發一個策略" class="headerlink" title="利用Python研發一個策略"></a>利用Python研發一個策略</h3><p>首先，我們得準備台股的歷史紀錄，還有台股的夏普指標，假如之前沒有跟上，可以到<a href="/Python新手教學：風險與報酬/">上一個單元</a>複習一下喔！：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adjclose[<span class="string">'TSEC weighted index'</span>].plot()</span><br><span class="line">sharpe[<span class="string">'TSEC weighted index'</span>].plot(secondary_y=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><center><img src="/python新手教學：夏普指數策略/1.png" title="台灣指數以及夏普"></center><p>可以發現，當sharpe ratio比較低時，台股也都是在比較低點，<br>可以發現，當sharpe ratio比較高時，台股也都是在比較高點，<br>當sharpe ratio 轉折時，通常也是台股會轉折的時候</p><p>利用這個觀察，我們就可以來編寫一個策略：</p><ol><li>當sharpe ratio往上轉折時，則買入</li><li>當sharpe ratio往下轉折時，則賣出</li></ol><h3 id="利用Python快速編寫"><a href="#利用Python快速編寫" class="headerlink" title="利用Python快速編寫"></a>利用Python快速編寫</h3><p>為了找出轉折點，我們必須做一點資料處理：</p><ol><li>時間序列的平滑</li><li>時間序列的斜率</li><li>找出斜率由正到負，或由負到正的訊號</li></ol><p>為了使用python寫出上述的策略，我們要先將夏普值平滑一下，不然雜訊太多了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sr = sharpe[<span class="string">'TSEC weighted index'</span>].dropna()</span><br><span class="line"></span><br><span class="line">d = <span class="number">60</span></span><br><span class="line">srsma = sr.rolling(d).mean()</span><br><span class="line">sr.plot()</span><br><span class="line">srsma.plot()</span><br></pre></td></tr></table></figure><center><img src="/python新手教學：夏普指數策略/2.png" title="sma後"></center><p>來色的線是我們就將sharpe ratio做移動窗格的平均，可以發現平均之後，時間序列比較平滑，這樣子我們找轉折點比較方便，所謂的轉折點，就是斜率由正到負，或由負到正的瞬間，所以我們要先找出夏普曲線的斜率。</p><h3 id="夏普曲線的斜率"><a href="#夏普曲線的斜率" class="headerlink" title="夏普曲線的斜率"></a>夏普曲線的斜率</h3><p>斜率非常簡單，可以使用<code>diff</code>這個功能：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">srsma = sr.rolling(d).mean()</span><br><span class="line">srsmadiff = srsma.diff()</span><br><span class="line">srsma.plot()</span><br><span class="line">srsmadiff.plot(secondary_y=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><center><img src="/python新手教學：夏普指數策略/3.png" title="計算斜率"></center><p>可以發現上圖中，橘色的為sharpe ratio，藍色的為斜率，當橘色線由上而下轉折時，藍色的線會快速向下穿越0，有了這個特性，我們就可以來找轉折點了！</p><h3 id="找轉折點"><a href="#找轉折點" class="headerlink" title="找轉折點"></a>找轉折點</h3><p>接下來我們可以來找轉折點了，就是斜率由正到負，或由負到正的瞬間。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buy = (srsmadiff &gt; <span class="number">0</span>) &amp; (srsmadiff.shift() &lt; <span class="number">0</span>)</span><br><span class="line">sell = (srsmadiff &lt; <span class="number">0</span>) &amp; (srsmadiff.shift() &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">(buy * <span class="number">1</span>).plot()</span><br><span class="line">(sell * <span class="number">-1</span>).plot()</span><br></pre></td></tr></table></figure><center><img src="/python新手教學：夏普指數策略/4.png" title="找出訊號"></center><p>以上就是簡單的訊號產生</p><h3 id="找出持有的時段"><a href="#找出持有的時段" class="headerlink" title="找出持有的時段"></a>找出持有的時段</h3><p>那我們就可以來看一下，假如天都用一樣的方式來產生這些訊號，當 <code>buy</code>訊號為<code>True</code>時，買入，而當<code>sell=True</code>時空手，如此執行20年的持有加權指數的時段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">hold = pd.Series(np.nan, index=buy.index)</span><br><span class="line">hold[buy] = <span class="number">1</span></span><br><span class="line">hold[sell] = <span class="number">-1</span></span><br><span class="line">hold.ffill(inplace=<span class="keyword">True</span>)</span><br><span class="line">hold.plot()</span><br></pre></td></tr></table></figure><center><img src="/python新手教學：夏普指數策略/5.png" title="找出持股時間"></center><p>交易頻率似乎有點高，不過沒關係，我們之後還會再做調整<br>接來是回測</p><h3 id="回測"><a href="#回測" class="headerlink" title="回測"></a>回測</h3><p>今天我們先簡單算一算，不考慮手續費，但是真實情況是必須考慮的喔！請謹記在心</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">twii = adjclose[<span class="string">'TSEC weighted index'</span>][buy.index]</span><br><span class="line"></span><br><span class="line">pct_change = twii.pct_change()</span><br><span class="line">pct_ratio = (pct_change.shift(<span class="number">-1</span>)+<span class="number">1</span>) <span class="comment"># 今天到明天的價格變化</span></span><br><span class="line"></span><br><span class="line">pct_ratio.fillna(<span class="number">1</span>)[hold == <span class="number">1</span>].cumprod().plot()</span><br></pre></td></tr></table></figure><p>這段程式碼，有點複雜，當中的<code>pct_change</code>是一個每天獲利上下 x％。<br>而<code>pct_ratio</code>代表買入之後每天的變化（不漲不跌是1，大於1則漲，小於1則跌）<br>我們希望將「持有」時間段的<code>pct_ratio</code>全部都乘起來，代表獲利。</p><center><img src="/python新手教學：夏普指數策略/6.png" title="計算績效"></center><p>可以發現，這個策略效果並不是很好，不過別擔心<br><a href="/Python新手教學：策略優化/">下個單元</a>，我們使用參數最佳化，從5000種組合中，找出最好的策略！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一集我們介紹了Sharpe ratio，可以用來衡量風險跟報酬的指標（也就是報酬 / 風險），這集我們就利用Sharpe ratio來進行台股的模擬買賣，假裝我們這20年來，都使用sharpe ratio的策略，可以得到多少獲利呢？&lt;/p&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(5)如何衡量風險與報酬？</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%EF%BC%9A%E9%A2%A8%E9%9A%AA%E8%88%87%E5%A0%B1%E9%85%AC/"/>
    <id>https://www.finlab.tw/Python新手教學：風險與報酬/</id>
    <published>2019-02-14T05:09:43.000Z</published>
    <updated>2019-05-06T12:43:00.185Z</updated>
    
    <content type="html"><![CDATA[<p>今天我們來看一下市場上常見的風險與報酬指標：夏普比率（sharpe ratio），這是一個風險跟報酬的比例，有了夏普比率，你就知道為什麼要投資美股而不是台股了！</p><a id="more"></a><center><img src="/Python新手教學：風險與報酬/thumbnail.png" title="報酬與風險"></center><h3 id="sharp-ratio-簡單講，就是「報酬-風險」！"><a href="#sharp-ratio-簡單講，就是「報酬-風險」！" class="headerlink" title="sharp ratio 簡單講，就是「報酬 / 風險」！"></a>sharp ratio 簡單講，就是「報酬 / 風險」！</h3><p>以這著比率，可以想像，sharp ratio 越高，代表獲利大於風險，<br>而sharp ratio 越低，代表風險大於獲利，那就會有點危險了！<br>所以找一個sharp ratio 越高的指數，就等於找出了「獲利大且風險相對小」的指數喔！</p><h3 id="如何定義獲利？"><a href="#如何定義獲利？" class="headerlink" title="如何定義獲利？"></a>如何定義獲利？</h3><p>獲利可以用每天平均的漲跌來代表，也就是今天漲1％，明天跌1％，平均獲利就是0％，<br>接下來我們就用python來計算每天平均獲利吧</p><p>首先，記得回去前一個單元，找出上次的adjclose：</p><center><img src="/Python新手教學：風險與報酬/1.png" title="adjclose"></center><p>接下來，我們就可以來計算獲利：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pct_change = adjclose.pct_change()</span><br><span class="line">profit = pct_change.mean()</span><br><span class="line">profit.sort_values()</span><br></pre></td></tr></table></figure><br>上方的程式碼，<br>第一行，有好用的功能，叫做<code>adjclose.pct_change()</code>，這個函示會計算今天漲了x％，並且以x/100來表示，將整個table中的每一條時間序列都進行計算喔！<br>第二行，針對每一檔指數，將每一天的漲跌都平均起來，<br>第三行，進行由小到大的排序</p><center><img src="/Python新手教學：風險與報酬/2.png" title="報酬"></center><p>以平均獲利來說，看到台股（TSEC weighted index）竟然排在倒數第三位，<br>可以見台灣投資人多麼可憐XDD</p><h3 id="如何衡量風險"><a href="#如何衡量風險" class="headerlink" title="如何衡量風險"></a>如何衡量風險</h3><p>風險通常會用標準差（standard deviation）來計算，標準差，可以想像是股票震盪的程度，例如金融海嘯的時候，股票上上下下的比較劇烈，標準差很大。今天就不折磨各位了，有興趣請參考<a href="https://zh.wikipedia.org/zh-tw/%E6%A8%99%E6%BA%96%E5%B7%AE" rel="external nofollow noopener noreferrer" target="_blank">wiki介紹</a>，我們直接用 python 當中現有的程式碼來計算即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">risk = pct_change.std()</span><br></pre></td></tr></table></figure><h3 id="計算sharpe-ratio"><a href="#計算sharpe-ratio" class="headerlink" title="計算sharpe ratio"></a>計算sharpe ratio</h3><p>這個就更簡單了，直接相除即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sharpe = profit / risk * (<span class="number">252</span> ** <span class="number">0.5</span>)</span><br><span class="line">sharpe.sort_values()</span><br></pre></td></tr></table></figure><br>可以看到上述程式，我們額外乘了一個「252 ** 0.5」<br>因為我們希望算年化 annual sharpe ratio，<br>其中的252是一年大約的交易天數，<br>而「**」是「次方」的意思。<br>為什麼要乘這個常數？最主要是因為大家幫自己的歷史回測計算sharpe ratio時候，都有乘上這個數字，要乘了才有辦法跟別人比較XD，<br>當然這背後可能有更深層的數學邏輯，但我傾向於這樣理解（懶）。</p><center><img src="/Python新手教學：風險與報酬/6.png" title="夏普值"></center><p>你會發現</p><h3 id="台股竟然倒數第三名！"><a href="#台股竟然倒數第三名！" class="headerlink" title="台股竟然倒數第三名！"></a>台股竟然倒數第三名！</h3><p>可以發現台股真的好慘，慘不忍睹，為什麼會這樣呢，我們可以將歷史圖表畫出來：</p><center><img src="/Python新手教學：風險與報酬/3.png" title="台股"></center><p>可以發現因為我們是從1998年開始計算的，那個時候剛好也上萬點，跟現在的萬點是同一個萬點，反觀我們來看美股：</p><center><img src="/Python新手教學：風險與報酬/4.png" title="美股"></center><p>可以看到從1998年開始，直到現在漲了將近3倍！<br>可見台股的獲利不理想是導致於sharpe ratio比較低的很大的因素。</p><p>我們目前計算的sharpe ratio，是所有歷史資料的平均值，<br>然而我們知道，雖然台股總平均來說很爛，但是應該有時也有可圈可點之處，<br>我們希望用時間移動窗格，每日都計算252天以前的sharpe值，</p><p>來找出台股表現比較好的時段</p><h3 id="移動窗格"><a href="#移動窗格" class="headerlink" title="移動窗格"></a>移動窗格</h3><p>你以為這個很難嗎？其實超簡單，跟上面幾乎一樣，只要做一點小更改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># before</span></span><br><span class="line">profit = pct_change.mean()</span><br><span class="line">risk = pct_change.std()</span><br><span class="line">sharpe = profit / risk * (<span class="number">252</span> ** <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># after</span></span><br><span class="line">profit = pct_change.rolling(<span class="number">252</span>).mean()</span><br><span class="line">risk = pct_change.rolling(<span class="number">252</span>).std()</span><br><span class="line">sharpe = profit / risk * (<span class="number">252</span> ** <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>幾乎長的一模一樣對吧？唯一不一樣的是<code>rolling(252)</code>這個功能，<br>這是移動窗格252天的意思。<br>額外要注意的是，之前的寫法中，sharpe是一個series，index為指數名稱，而在現在的寫法中，sharpe變成了一個dataframe（table），其index代表日期，而columns代表每檔指數，其中的數值是 252 天的 sharpe ratio，神奇吧！</p><p>這就是python跟R最強大的資料處理功能！</p><p>有了這個移動窗格版的sharpe ratio，我們做圖後，就可以來看一些端倪：</p><h3 id="做圖看端倪"><a href="#做圖看端倪" class="headerlink" title="做圖看端倪"></a>做圖看端倪</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adjclose[<span class="string">'TSEC weighted index'</span>].plot()</span><br><span class="line">sharpe[<span class="string">'TSEC weighted index'</span>].plot(secondary_y=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>以上的代碼可以繪出下面這張圖，其中藍色的為加權指數，而黃色的為sharpe ratio，由於這兩個時間序列的數值差非常多，台股可能是在4000～10000左右，而sharpe可能是在-2～2左右，所以上方第二行程式中，我們用<code>secondary_y=True</code>這個參數，來將兩個數值的座標分開，所以下方的圖中，可以看到sharpe ratio的大小標示在右邊。</p><center><img src="/Python新手教學：風險與報酬/5.png" title="夏普與加權指數"></center><p>可以看到，sharpe ratio （黃）在台股加權指數（藍）高點時，會比較大，而台股低點時，會比較低<br>圖中還可以看出，在大盤高點時，sharpe ratio會領先大盤往下落，接下來我們就可以利用這個特點，來模擬一些買賣的實驗。</p><p>下次我們就來創造一個夏普策略吧！<br>其實程式碼已經寫好了，但還沒時間寫文章<br>接下來就可以進入<a href="/python新手教學：夏普指數策略/">下一單元</a>，我們利用sharpe ratio來寫一個策略吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我們來看一下市場上常見的風險與報酬指標：夏普比率（sharpe ratio），這是一個風險跟報酬的比例，有了夏普比率，你就知道為什麼要投資美股而不是台股了！&lt;/p&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(4)台股跟哪國指數最相關？</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B84%E7%9B%B8%E9%97%9C%E6%80%A7%E5%88%86%E6%9E%90/"/>
    <id>https://www.finlab.tw/Python新手教學4相關性分析/</id>
    <published>2019-02-10T03:10:58.000Z</published>
    <updated>2020-03-22T13:26:13.863Z</updated>
    
    <content type="html"><![CDATA[<p>為什麼美股大跌，在台灣的投資人要很緊張？原因就是相關性！想知道台股跟哪國指數最同步嗎？不是S&amp;P 500美國指數，也不是深圳指數，那究竟是哪國呢？這篇文章我們就來研究一下吧！</p><a id="more"></a><center><img src="/Python新手教學4相關性分析/last.png" title="全球指數相關性"></center><h3 id="相關性最白話"><a href="#相關性最白話" class="headerlink" title="相關性最白話"></a>相關性最白話</h3><p>首先我們先介紹什麼是相關性，<br>相關性最白話，你可以想像，看到天空烏雲密佈，代表可能要下雨了，<br>代表天空的顏色跟下雨機率有相關，<br>你可以由一個現象，去預測另一個現象，這就是相關性！</p><h3 id="相關性稍微數學一點"><a href="#相關性稍微數學一點" class="headerlink" title="相關性稍微數學一點"></a>相關性稍微數學一點</h3><p>相關性也可以更數值化的方式表示，先用以下例子講解：</p><center><img src="/Python新手教學4相關性分析/2.png" title="天氣溫度相關性"></center><p>這張圖中：</p><ul><li><p>我們可以看上方左側圖，天氣溫度跟買冰棒人數的變化圖，可以想像某人每一天記錄天氣溫度與冰棒人數，每天畫一個黃點，時間久了，就可以看出黃點之間的關係，也就是天氣越熱，越有人會想要買冰棒！</p></li><li><p>同理，上方中間那張圖，某人也可以記錄每天生病的人數，此時就發現，天氣越冷，越多人會感冒！</p></li><li><p>當然某人覺得有趣，於是又記錄了溫度與擲筊的關係，最後發現：沒什麼關連</p></li></ul><p>好了，某人已將觀測值變成數字記錄起來了，但每次都必須畫這麼多點，才能看出相關性，也太累了吧？能不能用一個數字取代呢？</p><p>這時就可以用</p><h3 id="correlation-coefficient-（相關性係數）"><a href="#correlation-coefficient-（相關性係數）" class="headerlink" title="correlation coefficient （相關性係數）"></a>correlation coefficient （相關性係數）</h3><p>有人可能覺得太多點點了，有密集恐懼症，希望可以將上方這三張圖，每張圖用一個數字代表就好，這樣就不需要看到這麼多點點。</p><p>所以某人提出了 correlation coefficient ，從上面第一張圖開始從左而又，分別可以用 1、-1、0來代表：</p><ul><li>1 代表正相關，也就是X越高Y越高，X越低Y越低（成正比）</li><li>─1 代表負相關，也就是X越高Y越低，或X越低Y越高（成反比）</li><li>0 代表無相關性</li></ul><p>上述只是化簡後的例子<br>事實上相關性係數不是整數，而是會介於─1～1間，代表正負相關的程度！</p><p>讀到這裡，你可能會問，</p><h3 id="所以跟投資有什麼關係？"><a href="#所以跟投資有什麼關係？" class="headerlink" title="所以跟投資有什麼關係？"></a>所以跟投資有什麼關係？</h3><p>投資就是預測未來現象與當下現象的相關性！<br>就像你看到天空烏雲密佈，就能預測接下來會下雨，<br>我們也可以將相關性係數用於全球指數，</p><p>為什麼美股大跌，在台灣的投資人要很緊張？原因就是相關性！<br>台股跟美股有正相關。</p><p>我們可以用Python將相關性畫出來，</p><h2 id="首先我們可以看一下上個單元的一些元素："><a href="#首先我們可以看一下上個單元的一些元素：" class="headerlink" title="首先我們可以看一下上個單元的一些元素："></a>首先我們可以看一下上個單元的一些元素：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(world_index_history[<span class="string">'S&amp;P 500'</span>].head())</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學4相關性分析/3.png" title="回顧指數"></center><p>還記得<code>world_index_history</code>嗎？它是一個dictionary，根據不同的字串，例如<code>S&amp;P 500</code>，可以叫出相對應的表格（dataframe）</p><p>有了 <code>world_index_history</code> 我們就可以將國際指數的相關性給畫出來，但首先，我們要先來瞭解</p><h3 id="Adj-Close跟Close的差異？"><a href="#Adj-Close跟Close的差異？" class="headerlink" title="Adj Close跟Close的差異？"></a><code>Adj Close</code>跟<code>Close</code>的差異？</h3><p><code>close</code> 就是收盤價，每天股市休盤瞬間的最後數字。那<code>Adj Close</code>呢？<br>我們用圖會比較好解說，先將 <code>S&amp;P500</code> 指數的 <code>Adj Close</code> 跟 <code>Close</code> 畫出來</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp500 = world_index_history[<span class="string">'S&amp;P 500'</span>]</span><br><span class="line">sp500[<span class="string">'Close'</span>].plot(color=<span class="string">'red'</span>)</span><br><span class="line">sp500[<span class="string">'Adj Close'</span>].plot(color=<span class="string">'blue'</span>)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學4相關性分析/4.png" title="收盤價與調整後收盤價"></center><p>上圖中紅色的為<code>Close</code>而藍色的為<code>Adj Close</code>，兩者幾乎重疊，因為<code>Adj Close</code>其實跟<code>Close</code>很像，但是有點不同，台灣叫做「調整後收盤價」，你有時候也會看到「復權收盤價」。這個價格的好處是，它移除了除權息和增減資的價格波動，更準確的反映了「股票價值」的變化。</p><h3 id="簡單的例子"><a href="#簡單的例子" class="headerlink" title="簡單的例子"></a>簡單的例子</h3><p>當除權息、增減資時，一般股價會有大波動，以除權息為例，股票價格瞬間下跌<br>然而帳戶裡的股票張數會變多（例如領股利）<br>或是帳戶資金量變多（領股息）<br>總體來講是不賺不賠的</p><p>所以當除權息時，<br>收盤價 <code>Close</code> 會突然下跌很多，<br>而調整後收盤價 <code>Adj Close</code> 不會因為除權息有巨幅下跌<br>更能夠精確的反映股票價值，跟投資的獲利狀況！<br>所以我們在做相關性分析，可以用 <code>Adj Close</code>！</p><h3 id="Python-終於開始了"><a href="#Python-終於開始了" class="headerlink" title="Python 終於開始了"></a>Python 終於開始了</h3><p>首先我們先將所有指數的 <code>Adj Close</code> 先集合起來，變成一張表格(dataframe)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adjclose = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> name, price <span class="keyword">in</span> world_index_history.items():</span><br><span class="line">    <span class="keyword">if</span> price.index.is_unique:</span><br><span class="line">        adjclose[name] = price[<span class="string">'Adj Close'</span>]</span><br><span class="line">    </span><br><span class="line">adjclose = pd.DataFrame(adjclose)</span><br><span class="line">adjclose</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學4相關性分析/5.png" title="調整後收盤價的表格"></center><p>接下來就可以來觀察每檔指數的 <code>Adj Close</code> 相關性，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corr = adjclose.corr()</span><br><span class="line">print(corr)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學4相關性分析/6.png" title="相關性matrix"></center><p>上圖可以看到一個二維的表，就是每個指數跟每個指數之間的相關性，<br>上圖中可以發現，指數自己跟自己的相關性一定是1，代表完全正相關！<br>而這張表會是symmetric matrix，也就是做對角線會是對稱的。</p><p>接下來我們可以用更視覺化的方式來表示，假如沒有sns的package，要記得先去安裝<code>pip install sns</code>即可，想瞭解如何安裝，可以到<a href="/Python股票投資/">此安裝教學</a>的下半部分，有簡單的教學喔！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.heatmap(corr, square=<span class="keyword">True</span> ,vmax=<span class="number">1.0</span>, linecolor=<span class="string">'white'</span>, annot=<span class="keyword">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><center><img src="/Python新手教學4相關性分析/last.png" title="相關性圖"></center><p>假如你發現圖比我的小，字看不清楚，可以改成以下程式碼</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># set figure size</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">18</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># original code</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.heatmap(corr, square=<span class="keyword">True</span> ,vmax=<span class="number">1.0</span>, linecolor=<span class="string">'white'</span>, annot=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>有了以上的code，我們就可以知道</p><h3 id="台灣股票跟誰最連動"><a href="#台灣股票跟誰最連動" class="headerlink" title="台灣股票跟誰最連動"></a>台灣股票跟誰最連動</h3><p>我們可以人眼觀察，發現台灣指數<code>TSEC weighted index</code>跟英國前一百大<code>Cboe UK 100</code>超像！相關係數高達0.9，代表非常非常像</p><p>我們可以將這兩個指數畫出來檢查一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adjclose[<span class="string">'Cboe UK 100 Price Return'</span>][<span class="string">'2015'</span>:].plot()</span><br><span class="line">adjclose[<span class="string">'TSEC weighted index'</span>][<span class="string">'2015'</span>:].plot()</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學4相關性分析/7.png" title="英國指數與台灣指數"></center><p>雖然價格不同，但是趨勢還真的頗像的耶！</p><h3 id="如何用於交易？"><a href="#如何用於交易？" class="headerlink" title="如何用於交易？"></a>如何用於交易？</h3><p>兩個相關性很高的股票，可以拿來做pair trading配對交易，但也不是只看相關性，<br>這個就容我們之後再慢慢分析吧！<br>這個單元會一直帶你從零開始，慢慢學習，直到機器學習的部分喔！敬請期待～<br>下一個單元中，我們來看一下<a href="/Python新手教學：風險與報酬/">要怎麼控制報酬與風險</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;為什麼美股大跌，在台灣的投資人要很緊張？原因就是相關性！想知道台股跟哪國指數最同步嗎？不是S&amp;amp;P 500美國指數，也不是深圳指數，那究竟是哪國呢？這篇文章我們就來研究一下吧！&lt;/p&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="爬蟲" scheme="https://www.finlab.tw/tags/%E7%88%AC%E8%9F%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(3)全球指數歷史數據</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B83%E5%85%A8%E7%90%83%E6%8C%87%E6%95%B8%E6%AD%B7%E5%8F%B2%E6%95%B8%E6%93%9A/"/>
    <id>https://www.finlab.tw/Python新手教學3全球指數歷史數據/</id>
    <published>2019-02-06T01:57:32.000Z</published>
    <updated>2020-03-22T13:24:23.358Z</updated>
    
    <content type="html"><![CDATA[<p>這個單元我們要利用 for 迴圈將所有的歷史數據爬下來，並且繪製所有的歷史股價。我們也會介紹一些 for 迴圈的進階技巧，並且將這些技巧結合起來，完成這次的功能，想要學習python，就慢慢跟著我們一步一步來吧！</p><a id="more"></a><center><img src="/Python新手教學3全球指數歷史數據/thumbnail.png" title="全球爬蟲"></center><p>延續上個單元，我們應該已經爬取了<code>world_index</code>這張表格：</p><center><img src="/Python新手教學3全球指數歷史數據/1.png" title="全球指數表格"></center><p>然後還有一個我們寫好的function</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_price</span><span class="params">(stock_id)</span>:</span></span><br><span class="line"></span><br><span class="line">    url = <span class="string">"https://query1.finance.yahoo.com/v8/finance/chart/"</span>+stock_id+<span class="string">"?period1=0&amp;period2=1549258857&amp;interval=1d&amp;events=history&amp;=hP2rOschxO0"</span></span><br><span class="line"></span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    data = json.loads(res.text)</span><br><span class="line">    df = pd.DataFrame(data[<span class="string">'chart'</span>][<span class="string">'result'</span>][<span class="number">0</span>][<span class="string">'indicators'</span>][<span class="string">'quote'</span>][<span class="number">0</span>], index=pd.to_datetime(np.array(data[<span class="string">'chart'</span>][<span class="string">'result'</span>][<span class="number">0</span>][<span class="string">'timestamp'</span>])*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>))</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下來就可以將他們結合，來爬取歷史資料了！在爬取資料之前，有幾個程式的小技巧必須要學會</p><h3 id="1-for-迴圈"><a href="#1-for-迴圈" class="headerlink" title="1. for 迴圈"></a>1. for 迴圈</h3><p>假如我們要執行重複性的動作，通常第一件事情就是想到for 迴圈，例如我們想要印出1～9，不用for迴圈，我們可以寫成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">1</span>)</span><br><span class="line">print(<span class="number">2</span>)</span><br><span class="line">print(<span class="number">3</span>)</span><br><span class="line">print(<span class="number">4</span>)</span><br><span class="line">print(<span class="number">5</span>)</span><br><span class="line">print(<span class="number">6</span>)</span><br><span class="line">print(<span class="number">7</span>)</span><br><span class="line">print(<span class="number">8</span>)</span><br><span class="line">print(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學3全球指數歷史數據/2.png" title="印出1到9"></center><p>但很明顯我們就已經快要中風了，所以改成for迴圈後<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p><center><img src="/Python新手教學3全球指數歷史數據/3.png" title="印出1到9FOR迴圈"></center><p>這樣短短的就寫完了！其中<br>第一行：我們有一個變數i，他會從1～9不斷變換，並且執行下方的print(i)。第二行要記得加上前方四個空白，通常叫做縮排「indent」，當第一行有<code>for</code>這個標示後，之後就必須用縮排indent直到寫完for迴圈裡的內容為止。</p><p>但有時候我們希望同時做兩個迴圈呢？</p><h3 id="使用zip"><a href="#使用zip" class="headerlink" title="使用zip"></a>使用zip</h3><p>我們可以使用zip，一次執行兩個list：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> number, letter <span class="keyword">in</span> zip([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]):</span><br><span class="line">    print(number, letter)</span><br></pre></td></tr></table></figure></p><center><img src="/Python新手教學3全球指數歷史數據/4.png" title="使用zip"></center><p>最後，我們要使用 dictionary 將全球的指數給存起來。</p><h3 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h3><p>這邊先示範最簡單的用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line">d[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找</span></span><br><span class="line">print(d[<span class="string">'b'</span>]) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迴圈</span></span><br><span class="line"><span class="comment"># 其中，d.items 有點像是zip的感覺，</span></span><br><span class="line"><span class="comment"># 針對dictionary中的['a', 'b']和[1,2]進行迴圈）</span></span><br><span class="line"><span class="keyword">for</span> letter, number <span class="keyword">in</span> d.items():</span><br><span class="line">    print(letter, number)</span><br><span class="line"><span class="comment"># a 1</span></span><br><span class="line"><span class="comment"># b 2</span></span><br></pre></td></tr></table></figure></p><center><img src="/Python新手教學3全球指數歷史數據/6.png" title="使用zip"></center><p>結合上述的小功能，就可以寫一個程式將世界指數都抓下來了！<br>我建議你自己試試看～<br>寫完之後再往下拉看範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">world_index_history = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> symbol, name <span class="keyword">in</span> zip(world_index[<span class="string">'Symbol'</span>], world_index[<span class="string">'Name'</span>]):</span><br><span class="line">    </span><br><span class="line">    print(name)</span><br><span class="line">    </span><br><span class="line">    world_index_history[name] = crawl_price(symbol)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學3全球指數歷史數據/5.png" title="全球歷史股價"></center><p>假如你有認真研究前三點功能，相信這些代碼應該難不倒你！其中沒有教到的是，我們利用<code>time.sleep(5)</code>，來休息一下，不要抓的太頻繁，不然會被封鎖，除此之外，上述代碼非常簡單，寫一個for迴圈，將所有的指數都抓下來，存在<code>world_index_history</code>中。</p><h3 id="繪製指數"><a href="#繪製指數" class="headerlink" title="繪製指數"></a>繪製指數</h3><p>接下來，我們可以用一樣的for迴圈，來將指數給畫出來</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, history <span class="keyword">in</span> world_index_history.items():</span><br><span class="line">    history.Close.plot()</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學3全球指數歷史數據/f.png" title="全球歷史股價"></center><h3 id="有了指數，接下來要做什麼呢？"><a href="#有了指數，接下來要做什麼呢？" class="headerlink" title="有了指數，接下來要做什麼呢？"></a>有了指數，接下來要做什麼呢？</h3><p><a href="/Python新手教學4相關性分析/">下個單元</a>，我們要來分析一下這些指數，看看哪些適合投資，哪些不適合，敬請期待～</p><p>這一系列是我們影音課程的化簡版，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這個單元我們要利用 for 迴圈將所有的歷史數據爬下來，並且繪製所有的歷史股價。我們也會介紹一些 for 迴圈的進階技巧，並且將這些技巧結合起來，完成這次的功能，想要學習python，就慢慢跟著我們一步一步來吧！&lt;/p&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="爬蟲" scheme="https://www.finlab.tw/tags/%E7%88%AC%E8%9F%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(2)全球指數一次抓</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B82%E5%85%A8%E7%90%83%E6%8C%87%E6%95%B8%E4%B8%80%E6%AC%A1%E6%8A%93/"/>
    <id>https://www.finlab.tw/Python新手教學2全球指數一次抓/</id>
    <published>2019-02-05T14:55:54.000Z</published>
    <updated>2020-03-22T13:23:13.679Z</updated>
    
    <content type="html"><![CDATA[<p>我們已經知道怎麼抓取任意一檔股票歷史價格了，但有時候我們一次需要很多檔股票，怎麼辦呢？難道每個股票我們都要寫這麼多行，才能抓下來嗎？今天我們教你如何將上一次的功能包裝成 function，然後一次下載全球指數！</p><a id="more"></a><center><img src="/Python新手教學2全球指數一次抓/thumbnail.png" title="全球爬蟲"></center><h3 id="上次的程式碼爬取台積電"><a href="#上次的程式碼爬取台積電" class="headerlink" title="上次的程式碼爬取台積電"></a>上次的程式碼爬取台積電</h3><p>首先，我們上次已經教了怎麼樣爬取一檔股票：「台積電2330」，這次我們重新複習一下，下方的程式，假如有任何一個部分忘記了，都可以去<a href="/用爬蟲爬全世界股價/">前一個單元</a>複習喔！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://query1.finance.yahoo.com/v8/finance/chart/2330.TW?period1=0&amp;period2=1549258857&amp;interval=1d&amp;events=history&amp;=hP2rOschxO0"</span></span><br><span class="line"></span><br><span class="line">res = requests.get(url)</span><br><span class="line">data = json.loads(res.text)</span><br><span class="line">df = pd.DataFrame(data[<span class="string">'chart'</span>][<span class="string">'result'</span>][<span class="number">0</span>][<span class="string">'indicators'</span>][<span class="string">'quote'</span>][<span class="number">0</span>], index=pd.to_datetime(np.array(data[<span class="string">'chart'</span>][<span class="string">'result'</span>][<span class="number">0</span>][<span class="string">'timestamp'</span>])*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>))</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學2全球指數一次抓/1.png" title="歷史股價爬蟲"></center><p>但是以上的程式碼只能爬「台積電」的股價，我想要爬其他的指數怎麼辦呢？</p><h3 id="將上述程式碼打包成function"><a href="#將上述程式碼打包成function" class="headerlink" title="將上述程式碼打包成function"></a>將上述程式碼打包成function</h3><p>我們可以用<code>function</code>將上面的程式碼打包起來，方便我們多次使用，變成下面這樣，其實跟之前長的非常像，可以先比較一下：首先，第一行多了<code>def crawl_price(stock_id):</code>，這行的意思就是宣告一個可呼叫的程式區塊，叫做<code>crawl_price(stock_id)</code>，再來，原本的程式碼前方都被加了4個空白格，代表這些功能是同一個<code>function</code>中被執行的代碼。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_price</span><span class="params">(stock_id)</span>:</span></span><br><span class="line"></span><br><span class="line">    url = <span class="string">"https://query1.finance.yahoo.com/v8/finance/chart/"</span>+stock_id+<span class="string">"?period1=0&amp;period2=1549258857&amp;interval=1d&amp;events=history&amp;=hP2rOschxO0"</span></span><br><span class="line"></span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    data = json.loads(res.text)</span><br><span class="line">    df = pd.DataFrame(data[<span class="string">'chart'</span>][<span class="string">'result'</span>][<span class="number">0</span>][<span class="string">'indicators'</span>][<span class="string">'quote'</span>][<span class="number">0</span>], index=pd.to_datetime(np.array(data[<span class="string">'chart'</span>][<span class="string">'result'</span>][<span class="number">0</span>][<span class="string">'timestamp'</span>])*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>))</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代碼中，有個特別可以注意的變數：<code>stock_id</code>，當今天<code>stock_id</code>被傳進<code>function</code>中的時候，url就會隨著<code>stock_id</code>的不同，而出現不同的<code>url</code>所以我們就可以爬到不同的股票歷史股價！</p><p>既然我們已經寫好了此<code>function</code>，接下來就可以呼叫它，得到不同股票的歷史股價</p><h3 id="使用function"><a href="#使用function" class="headerlink" title="使用function"></a>使用function</h3><p>假如以後我們需要爬取不同的股票，例如「鴻海2354」，我們就可以寫：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = crawl_price(<span class="string">"2354.TW"</span>)</span><br><span class="line">df.Close.plot()</span><br></pre></td></tr></table></figure><br>就可以順利將鴻海的股票爬取下來喔！</p><center><img src="/Python新手教學2全球指數一次抓/2.png" title="歷史股價爬蟲鴻海"></center><p>接下來我們就來爬取世界上重要的指數吧！</p><h3 id="國際重要指數清單"><a href="#國際重要指數清單" class="headerlink" title="國際重要指數清單"></a>國際重要指數清單</h3><p>首先我們必須要爬取到國際重要指數清單，可以到以下網址來獲取：<br><a href="https://finance.yahoo.com/world-indices/" rel="external nofollow noopener noreferrer" target="_blank">https://finance.yahoo.com/world-indices/</a></p><center><img src="/Python新手教學2全球指數一次抓/3.png" title="yahoo國際指數"></center><p>接下來我們就可以將上述清單給手動複製起來？！<br>不，我們要用更炫的方法，當然是要用程式來爬呀：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"https://finance.yahoo.com/world-indices/"</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line">f = io.StringIO(response.text)</span><br><span class="line">dfs = pd.read_html(f)</span><br><span class="line">world_index = dfs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>上述的程式碼，剛開始很簡單，就是用<code>requests.get</code>來獲取此網頁的資料，網頁中的資料都存在<code>response.text</code>中，跟之前一模一樣。</p><p>不過第5行有點不一樣，我們使用<code>io.StringIO(response.text)</code>將資料存成檔案<code>f</code><br>第6行，我們將此文件利用<code>pd.read_html(f)</code>來分析網頁<code>f</code>中的表格，將所有的表格存成 a list of dataframe<br>第7行，我們將第一張dataframe給拿出來。</p><center><img src="/Python新手教學2全球指數一次抓/4.png" title="國際指數清單"></center><p>這樣我們就有了此表格中的symbol和name，以供之後歷史股價的爬取</p><h3 id="最後，終於要爬取全球股價了！"><a href="#最後，終於要爬取全球股價了！" class="headerlink" title="最後，終於要爬取全球股價了！"></a>最後，終於要爬取全球股價了！</h3><p>萬事俱備！只欠東風，不過由於這次的教學已經很多了，所以大家可以自己練習看看，或是前往<a href="/Python新手教學3全球指數歷史數據/">下一個單元</a>，來爬取所有的歷史指數吧！</p><p>這一系列是我們影音課程的化簡版，<br>假如對此教程有興趣，歡迎點選下方影音課程，會豐富到炸裂喔～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我們已經知道怎麼抓取任意一檔股票歷史價格了，但有時候我們一次需要很多檔股票，怎麼辦呢？難道每個股票我們都要寫這麼多行，才能抓下來嗎？今天我們教你如何將上一次的功能包裝成 function，然後一次下載全球指數！&lt;/p&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="爬蟲" scheme="https://www.finlab.tw/tags/%E7%88%AC%E8%9F%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(0)為何用Python投資？</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B80%E7%82%BA%E4%BD%95%E7%94%A8Python%E6%8A%95%E8%B3%87/"/>
    <id>https://www.finlab.tw/Python新手教學0為何用Python投資/</id>
    <published>2019-02-05T10:24:05.000Z</published>
    <updated>2019-02-10T14:21:06.253Z</updated>
    
    <content type="html"><![CDATA[<p>你為什麼要用Python投資？Python投資有什麼好處？處在訊息萬千的時代中，如何不被淘汰？雖然本blog都一直在宣揚python，但是我們似乎漏掉了最重要的一點，「為何要用Python來投資」？那今天就讓我娓娓道來吧！</p><center><img src="/Python新手教學0為何用Python投資/thumbnail.png" title="全球股價爬蟲"></center><a id="more"></a><p>其實在2019年</p><h3 id="程式化投資並不新奇，已經有各種解決方案，MT4、XQ、Multicharts…"><a href="#程式化投資並不新奇，已經有各種解決方案，MT4、XQ、Multicharts…" class="headerlink" title="程式化投資並不新奇，已經有各種解決方案，MT4、XQ、Multicharts…"></a>程式化投資並不新奇，已經有各種解決方案，MT4、XQ、Multicharts…</h3><p>現在市面上已經充斥著很多的回測或量化系統了，像是以外匯為主的MT4、以股票為主的XQ、以期貨為主的Multicharts，然而這些系統雖然有其優點，然而我還是不會去使用它們，最主要的原因是</p><h3 id="雖然使用上輕鬆簡單，然而大部分是必須要付費的！"><a href="#雖然使用上輕鬆簡單，然而大部分是必須要付費的！" class="headerlink" title="雖然使用上輕鬆簡單，然而大部分是必須要付費的！"></a>雖然使用上輕鬆簡單，然而大部分是必須要付費的！</h3><p>以台灣最火紅的Multicharts和XQ全球贏家來說，最便宜的券商版，每個月需要額外花費1千元，要是你的總投資金額只有10萬，那每個月相當於損失1％的金額喔！也就是一年下來12％就白白花費了。</p><h3 id="MT4-不用錢呀，但程式碼複雜"><a href="#MT4-不用錢呀，但程式碼複雜" class="headerlink" title="MT4 不用錢呀，但程式碼複雜"></a>MT4 不用錢呀，但程式碼複雜</h3><p>MT4算是裡面非常佛心的軟體，下載歷史數據完全免費，而且還可以回測，但是缺點就是程式碼非常複雜，光是寫一個簡單的策略，就可以耗盡一個下午了。</p><p>這些軟體雖然都是寫代碼，但是有一個非常大的缺點，就是</p><h3 id="商用軟體自由度不夠"><a href="#商用軟體自由度不夠" class="headerlink" title="商用軟體自由度不夠"></a>商用軟體自由度不夠</h3><p>假如今天想要搭建機器學習的策略，那使用上述付費軟體其實是非常困難的，因為程式都已經包裝好了，可以用的語法就那些，沒辦法跟上近期華麗展開的AI產業。</p><p>另外，這些軟體在不同的商品上，各有所長，例如XQ針對股票、Multicharts針對期貨。但是缺乏一個更上層的資金控管系統，將所有的部位做一個有效的規劃。將多個策略整合，是有難度的。</p><p>究竟如何才能「不用花錢」、並享有「最新演算法」、又有最高的「自由度」呢？</p><h3 id="Python-與-R-程式語言崛起"><a href="#Python-與-R-程式語言崛起" class="headerlink" title="Python 與 R 程式語言崛起"></a>Python 與 R 程式語言崛起</h3><p>由於機器學習、資料科學的崛起，Python 與 R 是最大的受惠者！為何我覺得傳統的金融回測軟體幾乎都可以用 Python 與 R 來取代，原因在於：</p><h3 id="程式碼簡單、功能強大"><a href="#程式碼簡單、功能強大" class="headerlink" title="程式碼簡單、功能強大"></a>程式碼簡單、功能強大</h3><p>傳統開源的程式語言，如C++、Java，針對大量金融數據的函示庫比較少，通常得徒手寫，花非常多的時間。然而Python與R就是專門處理各種大量的資料，可以短短幾行代碼，就完成C++需要數百行的資料處理代碼。</p><p>於是 Python 與 R 在資料的處理上，雖然可能沒有比Multicharts 或 XQ 那麼簡單一兩行就撰寫策略，不過也相差不遠了（至少我自己的回測軟體已經化簡到到不相上下）。</p><h3 id="免費且開源"><a href="#免費且開源" class="headerlink" title="免費且開源"></a>免費且開源</h3><p>每個月省1000元，累積起來也不少！Python 與 R 除了程式語言是免費的以外，還有非常多機器學習演算法，也都是免費的！想要跑回測嗎？只要上網搜尋「backtest python github」，就可以撈到一堆開源回測項目來搭建！另外Python 與 R 都支援 dll 檔案，所以與券商的串接基本上是沒有問題的。<br>（Mac心碎）</p><h3 id="不只拿來交易"><a href="#不只拿來交易" class="headerlink" title="不只拿來交易"></a>不只拿來交易</h3><p>學了XQ、Multichart、MT4，就是拿來寫賺錢程式，但對於我來說，Python除了拿來投資，還有非常多的功能，不論是架設網站、平常寫一些小工具，或是求職，學會了 Python 或 R 絕對是只有加分不會扣分。</p><p>特別是Python已經是連續好幾年都是最熱門程式語言了，為何它不可撼動？因為大部分機器學習研究、產品研發，都會使用Python進行，簡單、快速、有效。R語言也不錯，有很多學術單位、金融研究單位也會使用R語言。不過以趨勢的熱門程度，以及package的豐富程度，我個人還是偏愛使用Python就是了。</p><p>新的一年不知道學什麼？就來學Python吧！<br>假如你喜歡做研究，而且覺得寫程式除了賺錢外，對你來說還有別的樂趣，那真的可以好好研究一下Python了！</p><p>這一系列文章將帶你從0開始，使用Python做投資！<br>下一單元，我們就來<a href="/用爬蟲爬全世界股價/">爬取股價資料</a>吧！</p><p>這一系列是我們影音課程的化簡版，<br>假如對此教程有興趣，歡迎點選下方影音課程，會豐富到炸裂喔～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你為什麼要用Python投資？Python投資有什麼好處？處在訊息萬千的時代中，如何不被淘汰？雖然本blog都一直在宣揚python，但是我們似乎漏掉了最重要的一點，「為何要用Python來投資」？那今天就讓我娓娓道來吧！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/Python新手教學0為何用Python投資/thumbnail.png&quot; title=&quot;全球股價爬蟲&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
  </entry>
  
</feed>
