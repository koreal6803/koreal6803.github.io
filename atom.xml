<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FinLab 量化實驗室</title>
  
  <subtitle>回測與選股教學部落格</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.finlab.tw/"/>
  <updated>2020-06-23T09:07:15.328Z</updated>
  <id>https://www.finlab.tw/</id>
  
  <author>
    <name>koreal6803</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>策略最佳化是有效的嗎？（附程式碼）</title>
    <link href="https://www.finlab.tw/backtesting-key-optimization/"/>
    <id>https://www.finlab.tw/backtesting-key-optimization/</id>
    <published>2020-06-23T06:22:59.000Z</published>
    <updated>2020-06-23T09:07:15.328Z</updated>
    
    <content type="html"><![CDATA[<p>你有沒有用過 Python 、 Multicharts、R 等等的回測工具嗎？<br>工具越來越強大，伴隨著平行運算，參數最佳化變得越來越容易<br>但有時候，這些強大的工具，反而是一種陷阱！<br>讓我們一步步走進陷阱而不自知</p><h4 id="就連學術期刊都如此！"><a href="#就連學術期刊都如此！" class="headerlink" title="就連學術期刊都如此！"></a>就連學術期刊都如此！</h4><p>一個策略可能有很多的參數，可以用來進行最佳化<br>你會發現，當參數越多，越有可能會找到很好的回測結果<br>但是，這樣的回測結果，<a href="https://www.economist.com/briefing/2013/10/18/trouble-at-the-lab" rel="external nofollow noopener noreferrer" target="_blank">究竟能不能在未來「重現」基本上是非常有疑慮的</a></p><h4 id="舉一個例子"><a href="#舉一個例子" class="headerlink" title="舉一個例子"></a>舉一個例子</h4><p>假設我們有一個簡單的均線策略，當均線黃金交叉買入，死亡交叉賣出，<br>在這個策略中，我們會有兩個參數，分別是均線的長短週期，分別叫做 n1 和 n2<br>假如我們現在要來最佳化，以下有兩種方法，你會選哪個呢？</p><h5 id="第一種最佳化方法："><a href="#第一種最佳化方法：" class="headerlink" title="第一種最佳化方法："></a>第一種最佳化方法：</h5><ol><li>n1 從 10 ~ 100</li><li>n2 從 10 ~ 100</li></ol><p>分別枚舉（暴力列舉）n1 跟 n2 在上述範圍內的所有可能，並且找最佳化後的結果</p><h5 id="第二種最佳化方法"><a href="#第二種最佳化方法" class="headerlink" title="第二種最佳化方法"></a>第二種最佳化方法</h5><p>跟上面雷同，但是 n1 跟 n2 只能從以下的數字枚舉</p><ol><li>n1 從 [2, 5, 13, 21, 34, 55, 89]</li><li>n2 從 [2, 5, 13, 21, 34, 55, 89]</li></ol><p>選好了嗎？以下開始解說</p><p><strong>假如你想找到最佳的報酬率，當然會選第一種方案呀！</strong><br>畢竟枚舉的數量多了，自然會找到更好的最佳解！<br>而且現在電腦運算這麼快，第一種方法跟第二種方法，<br>實際上都只需要幾秒鐘而已，<br>只是多幾秒鐘，績效變高20％多好呀！</p><h4 id="但方案一真的那麼好嗎？"><a href="#但方案一真的那麼好嗎？" class="headerlink" title="但方案一真的那麼好嗎？"></a>但方案一真的那麼好嗎？</h4><p>事實是，使用第一種方法，<strong>找到過擬合（overfitting）的模型機率也非常高！</strong><br>你可以想像下面這三張圖，圖中每一個點，都代表著價格，<br>一個能預測價格的模型，應該像中間這張圖，<br><strong>也就是模型跟價格實際的曲線非常接近，</strong><br>但假如我們求好心切，用各種方式，為模型增加各種變數，暴力枚舉，<br>最後有可能會變成右邊那張圖片，連歷史的雜訊都給預測了，<br><strong>最後實際使用的時候，反而效果大打折扣。</strong></p><center><img src="/backtesting-key-optimization/thumbnail.png" title="info"></center><p>為了避免產生 overfitting 的結果，<br><strong>我們在做參數最佳化時，就必需要非常小心，並且不要做過多優化</strong><br>什麼叫做「過多優化」？要怎麼樣才能避免呢？</p><h4 id="我們將用更客觀的角度，量化上述兩個最佳化的實驗，哪一個比較好！"><a href="#我們將用更客觀的角度，量化上述兩個最佳化的實驗，哪一個比較好！" class="headerlink" title="我們將用更客觀的角度，量化上述兩個最佳化的實驗，哪一個比較好！"></a>我們將用更客觀的角度，量化上述兩個最佳化的實驗，哪一個比較好！</h4><p>我們延續<a href="/backtesting-overfitting-probability/">上一篇文章中的介紹</a>，使用「the probability backtest overfitting」<br>來分析，我們這兩種優化過程中 overfitting 的機率。</p><p>下方的實驗結果，都會是兩張圖左右並排，同樣是簡單的均線策略<br>左邊是「最佳化方法一」，右邊是「最佳化方法二」<br>首先，我們先做出均線策略，在不同參數下的色溫圖如下，<br>我們可以發現，枚舉的「密度」上有很大的差異</p><center><img src="/backtesting-key-optimization/performance.png" title="performance"></center><p>由於「最佳化方法一」用了很多的參數，自然會得到比較連續的函數，<br>然而「最佳化方法二」的參數都比較不連續，代表這樣比較不好嗎？</p><p><strong>所以究竟哪種方法好？</strong><br>所以我們可以利用上一篇文章介紹的<a href="/backtesting-overfitting-probability/">「the probability of backtest overfitting」</a><br>來幫我們比較這兩種方法的差異：</p><center><img src="/backtesting-key-optimization/distribution.png" title="performance"></center><p>上圖中，是overfitting的機率分佈圖，<br>我們是使用 sharpe ratio 來當作最後的績效指標，<br>採樣時，會從「樣本內」的最佳參數，測試在「樣本外」是否也一樣好，<br><strong>該最佳參數在「樣本內」是第一名，而在樣本外，至少要是「前50％」</strong><br>我們才會說這樣的優化是有效果的（雖然還是滿寬鬆的XD）</p><p>上圖中，大於 0 的樣本，就是優化後有效果的，<br>而小於 0 的樣本，代表優化並沒有效果。</p><p><strong>上圖左圖，分佈比較偏向左邊(x &lt; 0)，代表 overfitting 的機率比較大</strong><br><strong>而右邊的圖中，分佈比較偏向右邊（x &gt; 0），代表其 overfitting 的機率比較小</strong></p><p>實際的原理，可以參考上一篇文章<a href="/backtesting-overfitting-probability/">「the probability of backtest overfitting」</a>來獲得更詳細的介紹喔！</p><p>除了以上的機率，該文章作者也提供不同的角度，檢視overfitting的問題，</p><p>像是</p><h4 id="Perfornace-degradation"><a href="#Perfornace-degradation" class="headerlink" title="Perfornace degradation"></a>Perfornace degradation</h4><p>在「樣本內」最好的測略，其績效會在「樣本外」衰減，<br>以下就是「樣本內的績效跟樣本外的績效」比較圖</p><center><img src="/backtesting-key-optimization/degradation.png" title="performance"></center><p>我們使用 sharpe ratio 當成績效<br>將「樣本內」最佳數值，跟「樣本外」的數值做比較，<br><strong>任何一種回測最佳化</strong>，都會出現這樣的「負相關 」，稱為 Performance degradation<br>也就是：</p><h5 id="「樣本內」sharpe-ratio-越高，則「樣本外」sharpe-ratio-越低"><a href="#「樣本內」sharpe-ratio-越高，則「樣本外」sharpe-ratio-越低" class="headerlink" title="「樣本內」sharpe ratio 越高，則「樣本外」sharpe ratio 越低"></a>「樣本內」sharpe ratio 越高，則「樣本外」sharpe ratio 越低</h5><p>是一件非常可怕的事情！XD</p><p>要怎麼比較上述兩張圖的好壞呢？<br>以視覺上來說，可以看哪張圖的 y 軸數值平均來說比較大，<br>以統計上來說，可以用<strong>線性回歸</strong>比較斜率（越負相關越不好）<br>左邊的回歸後，斜率是 -1.034<br>而右邊是 -0.988<br>稍微好一點而已</p><h4 id="感覺沒有差很多，有沒有更好的判斷法？"><a href="#感覺沒有差很多，有沒有更好的判斷法？" class="headerlink" title="感覺沒有差很多，有沒有更好的判斷法？"></a>感覺沒有差很多，有沒有更好的判斷法？</h4><p>另外我們可以用 Stochastic dominance 來判別「究竟要不要使用最佳化後的結果」<br>First-order stochastic dominance 從數學的角度出發，可以參考<a href="https://en.wikipedia.org/wiki/Stochastic_dominance" rel="external nofollow noopener noreferrer" target="_blank">wiki</a><br>就是在說，給定任意一個 performance 希望策略達標，<br>假如策略 A 達標的機率，比策略 B 還高，針對任意 performance 都是，<br>那我們就說 A 策略有一階機遇優勢 ( A  has first-order stochastic dominance over B)</p><p>這邊的 A 跟 B，所指的就是「優化前」跟「優化後」的策略，根據這兩個優化方式，可以總結下面的兩張圖</p><p><center><img src="/backtesting-key-optimization/dominance.png" title="performance"></center><br>上圖是一個累計分佈圖，而 Y 軸就是累積數量，藍色是優化後的績效，橘色是優化前的策略，<br><strong>優化成功的話，「藍色」會偏到「黃色」右邊，代表優化後的參數，有一階機遇優勢！</strong><br>上圖左圖中，藍色並沒有偏向右邊，而是與橘色交錯，所以我們不能確定「優化後效果比原先的好」<br>然而右圖中，藍色偏右邊，代表我們用優化後的策略，從統計的角度來說「優化成功的期望值是偏正的」</p><p>你可以從<a href="https://colab.research.google.com/drive/1E1Hcv6WddAkptdVyR34bO7GJftyUpZ5d?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">colab上直接運行實驗結果</a></p><h4 id="待改進之處"><a href="#待改進之處" class="headerlink" title="待改進之處"></a>待改進之處</h4><p>當然任何研究都會有優缺點的，此篇文章的作者提及一些待改進的空間，</p><ol><li>就算是有 overfitting 的狀況，當中還是可能會有針對「樣本外」效果很好的策略，舉一個例子，上述的兩種最佳化方法，其實非常巧合的，都優化在（13、21）這個參數位置，也就是說，這兩種方法最後的策略效果一樣，但是過程是不一樣。不過換一種商品，相信也會有不同的特性，究竟整體對策略研發而言，可以進步多少，還有待後續的驗證</li><li>此方法並沒有考慮參數與模型之間的關係，所以無法將考慮高原參數給考量進去，或許可以藉由機器學習將參數做 clustering 並且以「多參數組」來取代單一「樣本內」最佳參數，來判定過擬合的機率。</li><li>假如長時間使用，理論上，這個方法會變成越來越無效！因為使用了這種「避免overfitting的方法」，最終你有可能讓你不小心 overfit 這種「避免 overfitting 的方法」（overfit the algorithm that prevent overfitting）。我想這應該是所有這類演算法的通病吧！</li></ol><p>overfitting 真的是魔王中的魔王，創造夢境中的夢境！<br>夢裡中樂透，醒來發現一場夢，又中樂透，醒來又發現一場夢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你有沒有用過 Python 、 Multicharts、R 等等的回測工具嗎？&lt;br&gt;工具越來越強大，伴隨著平行運算，參數最佳化變得越來越容易&lt;br&gt;但有時候，這些強大的工具，反而是一種陷阱！&lt;br&gt;讓我們一步步走進陷阱而不自知&lt;/p&gt;
&lt;h4 id=&quot;就連學術期刊都如此！
      
    
    </summary>
    
      <category term="選股策略" scheme="https://www.finlab.tw/categories/%E9%81%B8%E8%82%A1%E7%AD%96%E7%95%A5/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>策略優化 - 如何避免過擬合？</title>
    <link href="https://www.finlab.tw/backtesting-overfitting-probability/"/>
    <id>https://www.finlab.tw/backtesting-overfitting-probability/</id>
    <published>2020-06-20T02:40:25.000Z</published>
    <updated>2020-06-23T08:54:19.507Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/backtesting-overfitting-probability/thumbnail.png" title="info"></center><p>當你做回測做久了，就會發現，找到「歷史報酬率」好的策略很簡單，但是找到「未來報酬率」好的策略非常難。原因在於做了過多的參數枚舉與優化，當樣本數夠大，自然會有極端的數據產生，就像是夜路走多了會碰到鬼，人多必有白癡，樹多必有枯枝，就像是量子力學中，波函數坍縮成我們所處的現實，代表著均值，但在極端的多重宇宙樣本中，你也有可能是總統，代表著眾多巧合下的極端事件。</p><h5 id="本文就是用口語的方式，帶你瞭解如何判斷過擬合的演算法"><a href="#本文就是用口語的方式，帶你瞭解如何判斷過擬合的演算法" class="headerlink" title="本文就是用口語的方式，帶你瞭解如何判斷過擬合的演算法"></a>本文就是用口語的方式，帶你瞭解如何判斷過擬合的演算法</h5><p>牛頓從蘋果落地的現象，發現了萬有引力，F=ma，因為實驗的雜訊很小（風、熱能散失等等），才能有經典簡潔的公式，然而把牛頓的實驗，換到財經領域時，可能就不是這麼管用了，當我們在建模時，價格的雜訊遠大於規律，</p><h4 id="我們很有可能是優化雜訊，而非優化價格的規律。"><a href="#我們很有可能是優化雜訊，而非優化價格的規律。" class="headerlink" title="我們很有可能是優化雜訊，而非優化價格的規律。"></a>我們很有可能是優化雜訊，而非優化價格的規律。</h4><h5 id="要怎麼辨別這兩者的不同呢？"><a href="#要怎麼辨別這兩者的不同呢？" class="headerlink" title="要怎麼辨別這兩者的不同呢？"></a>要怎麼辨別這兩者的不同呢？</h5><p>我們可以先從直觀的角度出發，究竟歷史上成功的偉人，Bill Gates、Steve Jobs、Elon Musk，這些科技巨擘，他們之所以能夠有今天的成就，是一連串的巧合，還是他們有一些人格特質，促使他們的成功？另一個極端的例子，假如今天某人中了樂透彩而一夕爆富，那很明顯，他很可能是多重宇宙中，非常成功的一個版本，但他的成功，可能並非來自他的人格特質，而是來自運氣。今天就運氣跟命運，來討論策略模型過擬合的問題。</p><p>模型的過擬合，就像是簽樂透彩，只要參數夠多了，總會中獎。所以策略績效好，究竟是不是運氣好，最重要的事，就是要確保「實驗是有效的」。如何定義實驗是有效的呢？</p><p>樣本內的「最佳參數」在樣本外的「績效」也是顯著的機率是高的</p><h5 id="聽不懂？別走，讓我舉個例子"><a href="#聽不懂？別走，讓我舉個例子" class="headerlink" title="聽不懂？別走，讓我舉個例子"></a>聽不懂？別走，讓我舉個例子</h5><p>這邊的「樣本內」就是指我們現在的現實世界，已經發生了的事情，例如我們知道 Steve Jobs 是頻果創辦人，將科技與時尚結合，促進科技的進步功不可沒，所以他就是我們在樣本內的「最佳人選」。而「樣本外」就是指那些我們沒見過的多重宇宙，在多重宇宙中，假如都有 Steve Jobs 這個人，而他都有一番豐功偉業，那就代表那是他貨真價實的實力。</p><h3 id="回到策略的角度，如何驗證「貨真價實的策略」？"><a href="#回到策略的角度，如何驗證「貨真價實的策略」？" class="headerlink" title="回到策略的角度，如何驗證「貨真價實的策略」？"></a>回到策略的角度，如何驗證「貨真價實的策略」？</h3><p>最簡單的方式，一般我們會使用 hold-out，將歷史資料分成樣本內（in-sample IS）和樣本外（out-of-sampe OOS）並且在 IS 做最佳化後，再用 OOS 驗證，這樣的方法有幾個缺點：</p><ul><li>由於 IS 跟 OOS 都是人為定義，所以當重複優化很多次後，還是會對於 OOS 的績效越來越熟悉，最後不免還是用了 OOS 的資訊來設計模型</li><li>資料量的問題，回測跟驗證都需要一定長度的歷史數據，將歷史數據分成 IS 跟 OOS 顯然有點浪費</li><li>OOS 通常是時間序列的尾端，代表近期的資料，對於策略效能有決定性的影響，然而卻不能拿來開發</li></ul><h3 id="所以比較好的方法是？"><a href="#所以比較好的方法是？" class="headerlink" title="所以比較好的方法是？"></a>所以比較好的方法是？</h3><p><a href="https://poseidon01.ssrn.com/delivery.php?ID=868103003064115117125100064075098092016007037010053025100075080026029100071001025108063043035060033044107114028094094091106006057048087011059012084117121014084068060040064001077111012024029099081115109104017084001102009126127067113118116067099111100&amp;EXT=pdf" rel="external nofollow noopener noreferrer" target="_blank">The probability of backtest overfitting</a>的作者是這樣做的：<br>Bailey, D.H., Borwein, J., Lopez de Prado, M. and Zhu, Q.J., 2016. The probability of backtest overfitting. Journal of Computational Finance, forthcoming.</p><h3 id="1-確定參數效果真的比較好"><a href="#1-確定參數效果真的比較好" class="headerlink" title="1. 確定參數效果真的比較好"></a>1. 確定參數效果真的比較好</h3><p>任何策略都有好與不好的時候，要確定參數效果很好，不是看績效是正的就好，而是要跟其他參數的績效作比較，<br>例如最近台股上漲，雞犬升天，所以任何人投資績效都是正的，但不帶表大家都是投資高手，<br>所以就算績效是正的，還要看績效的排名才行！</p><p>所以論文中的作者，針對所有參數產生出來績效，從「樣本內」找到「最佳參數」，並且將「樣本外的績效」由小到大排名，並且觀察「最佳參數」是否位於前 1/2 的機率</p><h3 id="2-產生多重的-IS-跟-OOS"><a href="#2-產生多重的-IS-跟-OOS" class="headerlink" title="2. 產生多重的 IS 跟 OOS"></a>2. 產生多重的 IS 跟 OOS</h3><p>假如只有一組 IS 跟 OOS 實再是太少了，這樣驗證的樣本會不足，<br>所以作者不使用「歷史數據」來區分 IS 跟 OOS，而是將回測整個跑完後，將績效的時間序列切成 S 份，任選 S/2 份當作 IS，其他當作 OOS，這樣的話可以產生超多種組合</p><h3 id="實驗結果："><a href="#實驗結果：" class="headerlink" title="實驗結果："></a>實驗結果：</h3><p>下圖就是作者使用此方法的實驗範例， x 代表「最佳參數」在「樣本外」的效果，越右邊代表效果越好，而 y 軸是樣本的數量<br>我們會發現，下圖這個例子，整個分佈偏向左邊，也就是 x 軸小於零，代表其實最佳化後，大部分的績效都是比較差的！<br>每100個樣本，就有74個樣本，最佳化後的效果小於績效的中位數，<br>所以 74% 的機率，最佳化後的效果比較差</p><center><img src="/backtesting-overfitting-probability/bad_strategy.png" title="info"></center><p>一個比較好的策略，應該會是如下圖，整個<br>每100個樣本，只有4個樣本，最佳化後的效果小於績效的中位數，<br>所以只有 4% 的機率，有過擬合的風險，<br>算是一個很不錯的參數優化過程</p><center><img src="/backtesting-overfitting-probability/good_strategy.png" title="info"></center><p>結果我上網找了一下，都沒有 python 的程式碼<br>所以假如大家有興趣，我之後可以提供這篇 paper 的程式碼，<br>雖然但我不確定大家有沒有興趣就是了XDDD</p><p>後記：<br>大家好像滿有興趣的，所以準備了<a href="/backtesting-key-optimization">下一篇程式和數據分享</a>！趕快來看看吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/backtesting-overfitting-probability/thumbnail.png&quot; title=&quot;info&quot;&gt;&lt;/center&gt;

&lt;p&gt;當你做回測做久了，就會發現，找到「歷史報酬率」好的策略很簡單，但是找到「未來報酬率」好
      
    
    </summary>
    
      <category term="選股策略" scheme="https://www.finlab.tw/categories/%E9%81%B8%E8%82%A1%E7%AD%96%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>AI讀書心得：人工智慧在台灣：產業轉型的契機與挑戰</title>
    <link href="https://www.finlab.tw/ai-in-taiwan/"/>
    <id>https://www.finlab.tw/ai-in-taiwan/</id>
    <published>2020-06-15T03:48:37.000Z</published>
    <updated>2020-06-15T06:00:23.063Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/ai-in-taiwan/thumbnail.png" title="機器學習"></center><p>書目連結：<br><a href="https://www.books.com.tw/products/0010821934" rel="external nofollow noopener noreferrer" target="_blank">https://www.books.com.tw/products/0010821934</a></p><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>陳昇瑋博士是台灣人工智慧學界名人，除了是中研院院士與台灣人工智慧學校的CEO，也致力於人工智慧的產官學合作、落地化應用，不是純學術的學者，而是入世科學家。不幸的是，陳博士於今年因意外離世，無法繼續完成他的夢想。這本2019年出版的著作說明他對台灣AI產業發展的理想，也以淺顯易懂的文字介紹人工智慧為何？就算完全不懂程式，也能輕鬆理解概論，如果你是開發者，也能從此書了解產業脈絡與實務應用。<br>總結來說是一本人人必讀的AI通識書，以下節錄一些重點和想法。</p><h2 id="AI進程"><a href="#AI進程" class="headerlink" title="AI進程"></a>AI進程</h2><p>AI浪潮在過去發生過兩波，但後來都冷卻掉，新一波在2010年後由圍棋大師：Alpha Go引爆第三波熱潮，受惠於算力強大的晶片、大數據基礎、演算法成熟的天時地利人合，許多以前表現不如預期的項目，如影像辨識、語音辨識，都有突破性的進展，且在產業界有成功應用，如醫療判讀、產品瑕疵檢測，讓許多科學家斷言這波AI浪潮和以前不一樣了，不再空有理論，而是逐步影響人類的生活。</p><p>不過目前的AI仍屬『弱人工智慧』，也就是無創造力的AI，其學習完全依賴人類輸入的資料，具主動思考、感情的『強人工智慧』在短期(50年內)連影子都沒有，且無法用目前機器學習演算法來發展，應該會以另一套新技術來發展，所以科幻片如西部世界或全民公敵的情節、一大堆工作被取代的推想，純屬想像，目前只有重複性高的工作如客服、檢測員、駕駛等重複性高的工作會被逐漸取代，其他行業趨勢為人機合作。</p><h2 id="機器學習簡單分"><a href="#機器學習簡單分" class="headerlink" title="機器學習簡單分"></a>機器學習簡單分</h2><ol><li>監督式學習：人類先標註label，如標註是狗還是貓，讓電腦填鴨式學習，目前90%算法都用這。</li><li>非監督式學習：不先標註label，讓電腦自動去依照變數去分群，資料科學家再判讀分群結果的意義，讓電腦學習自己去分類。</li><li>深度學習：機器學習演算法的一隻，與一般機器學習差異在，不用先人工作特徵擷取(做指標)，讓電腦去找特徵，如不用給電腦看KD值，只丟價量資料讓電腦自己生成指標。在降低人為涉入</li><li><img src="https://i.imgur.com/ZmN336Y.png" alt></li></ol><h2 id="AI產業化的難題"><a href="#AI產業化的難題" class="headerlink" title="AI產業化的難題"></a>AI產業化的難題</h2><p>以前硬體是問題，現在晶片算力強、伺服器便宜，現在比較麻煩的是資料和人材問題。</p><h3 id="技術債-資料處理基礎建設"><a href="#技術債-資料處理基礎建設" class="headerlink" title="技術債-資料處理基礎建設:"></a>技術債-資料處理基礎建設:</h3><p>沒有資料，演算法再強也沒用，大數據不是量多就好，質量更重要，不然做出來的只是自己爽的Trash。<br>陳博士蠻多youtube影音資源可看，有一篇就在說醫學資料label標註的問題，若視網膜影像只給一位醫生標註有無病變，誤差率很高，同一張圖給33位醫生看，只有60%影像是看法全部一致，可見1.資料要給數位專家多數決標註、2.人類判讀不穩定性很高，但要請專家來標註資料，這成本可不低，企業會願意花錢處理資料嗎？</p><p><img src="https://i.imgur.com/IEixQg6.jpg" alt></p><p>截自陳教授演講：<a href="https://www.youtube.com/watch?v=OddYM6aq-zM" rel="external nofollow noopener noreferrer" target="_blank">https://www.youtube.com/watch?v=OddYM6aq-zM</a></p><p>另外具筆者工作經驗，許多企業ERP、CRM、EC外包給多廠商做，資料庫系統與格式都不同，光日期就有好幾種格式，或是沒有埋紀錄使用者操作的程式，在後來想導入AI推薦系統或精準行銷時，會在資料處理和搜集遇到困難，有多少企業願意先花大把時間還完技術債？</p><h3 id="AI人材困境"><a href="#AI人材困境" class="headerlink" title="AI人材困境"></a>AI人材困境</h3><p>現今AI人材供需失衡，且技術迭代太快(畢業3年後，原先技術就偏老)，要找有產業經驗加懂最新演算法的很難，因為剛畢業的新鮮人沒經驗、產業老鳥沒太多時間學新技術(台灣習慣省人力成本，老闆很難放你平日丟下工作去學新技術)，台灣仍以硬體代工為王，純軟工的企業待遇差國外一大截，造成人材不是往豬屎屋跑，就是遠走高飛，上市櫃軟體企業多做代理、維護追求短期獲利，無論是演算法開發、雲平台服務都落後國外甚多。</p><p>作者指出企業計畫導入AI時，必須由上而下的支持，AI專案不能用傳統KPI定義績效，經理人須掃除管理障礙，因為初期會花很多時間還技術債和試誤，應該用投資新創以小博大的視角來評斷，如投入獲利的10%來養AI拚未來趨勢領先權，若成功，報酬率會很高;若失敗，也不影響太多主體獲利。<br>經理人不一定要很懂程式，但一定要對AI適合解決哪些問題、企業待解決問題的優先權、跨部門整合溝通有足夠理解。<br>資料量缺乏、不可知情境多的，機器學習能幫助的就有限。</p><p><img src="https://i.imgur.com/Z4ez8u9.jpg" alt></p><h3 id="團隊工作流"><a href="#團隊工作流" class="headerlink" title="團隊工作流"></a>團隊工作流</h3><p>培養厲害的工程師很重要，培養了解AI的老闆更重要，工程師才能少受點折磨。具我目前在產業的經驗，完整的團隊配置是：</p><ol><li>資料工程師：蒐集與清洗資料</li><li>機器學習工程師：特徵擷取、套用或開發演算法、建模</li><li>資料科學家：領導工程團隊，訂定研究方向、判讀商業價值。</li><li>UX Resercher，沒錢請資料科學家的公司，可能請使用者體驗研究員來設計解決方案，補足工程師弱項。差在其不大懂程式，工程師要花較多時間溝通可行性。</li><li>一組前後端將模型判讀結果刻出API與BI(儀表板)畫面</li><li>PO or PM：經理人與市場部溝通問題優先權、目標、可能情境變數。</li></ol><p>實際是…見&lt;打造第一隻AI團隊,陳教授著&gt;<br><a href="https://www.leadercampus.com.tw/desktop/course/free/960" rel="external nofollow noopener noreferrer" target="_blank">https://www.leadercampus.com.tw/desktop/course/free/960</a><br><img src="https://i.imgur.com/d1g13sa.png" alt></p><h2 id="產業案例"><a href="#產業案例" class="headerlink" title="產業案例"></a>產業案例</h2><p>陳教授最看好醫療應用的成功，原因是台灣有完整的健保資料庫，醫學資料生成也較穩定專業，label標記單純，現在知名的雲象科技(腫瘤檢測)、PTT創世神的AI Lab(基因檢測、病毒基因序)就屬代表。</p><p>再來由於台灣是硬體王國，有不少機器生產管理的數據可作機器故障預測、產品瑕疵檢測，製成優化應用也是看好的方向。如AOI光學檢測升級、布料染色配方、石化業工廠管理等等。以後物聯網更發達後，又有更多數據可導入。</p><p>金融業數據也齊全，陳教授生前也擔任玉山金科技長，將AI導入信用卡管理、洗錢法遵、投資理財等，近來台灣官方剛開放些保守態度，有創立監理沙盒給金融新創試驗金融數據，未來也有潛力。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>文筆非常好的科普書，未來AI將會影響生活各層面，就算不投入此行，也該思考自己的生活會受何影響？AI會帶來什麼方便與危機？<br>初探AI領域、課程的人在寫程式前最好先看這本書，你才不會覺得AI很抽象，再搭配陳教授生前的網路演講影音，更有成效，你也會敬佩這位科學家的理想與為台灣付出的努力！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/ai-in-taiwan/thumbnail.png&quot; title=&quot;機器學習&quot;&gt;&lt;/center&gt;

&lt;p&gt;書目連結：&lt;br&gt;&lt;a href=&quot;https://www.books.com.tw/products/0010821934&quot; re
      
    
    </summary>
    
      <category term="AI看股票" scheme="https://www.finlab.tw/categories/AI%E7%9C%8B%E8%82%A1%E7%A5%A8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Machine Learning" scheme="https://www.finlab.tw/tags/Machine-Learning/"/>
    
      <category term="AI" scheme="https://www.finlab.tw/tags/AI/"/>
    
      <category term="人工智慧" scheme="https://www.finlab.tw/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7/"/>
    
  </entry>
  
  <entry>
    <title>每天只要15分鐘 - 超簡單學會 Python 自動化投資比特幣</title>
    <link href="https://www.finlab.tw/btc-summary/"/>
    <id>https://www.finlab.tw/btc-summary/</id>
    <published>2020-06-10T01:38:45.000Z</published>
    <updated>2020-06-13T11:57:16.050Z</updated>
    
    <content type="html"><![CDATA[<p>2017年12月，比特幣曾一天上漲20％！<br>我的朋友說，他投資了加密貨幣，<br>但過了一個禮拜，比特幣的價格開始崩盤，而他卻買在高點，</p><p>我就在想，有沒有一種投資方法，<br>可以投資加密貨幣，卻不用承受這麼高的風險？<br>於是開始研究基於加密貨幣的量化投資，<br>寫成一系列的文章，共12篇，一篇只需要操作 15 分鐘<br>分享給大家</p><center><img src="/btc-summary/summary.png" title="info"></center><h3 id="為什麼要投資加密貨幣"><a href="#為什麼要投資加密貨幣" class="headerlink" title="為什麼要投資加密貨幣"></a>為什麼要投資加密貨幣</h3><p>加密貨幣當前是個小眾市場，但是有很大的潛力<br>從貨幣供給、基本面的角度，加密貨幣也是非常有市場的<br>是值得投資的商品</p><p>德意志交易所（Deutsche Bórse）<br>這個月發行了 BTC-E<br>是由 100% BTC 支持的<br>代表每個德國人，都可以從股票帳戶購買 BTC！</p><p>當初被世界各國禁止，<br>現在反而是逐漸開放，<br>從期貨、現貨等，進入人們的日常，<br>你還覺得加密貨幣沒有未來嗎？</p><p><a href="/python-bitcoin-trading-why-bitcoin/">前導：（Python x Crypto (Part 1)：為什麼是比特幣？）</a></p><p>然而投資跟投機往往一線之間，<br>像是比特幣<br>波動就非常大！<br>所以持有時加密貨幣一定要</p><ul><li>少部位</li><li>用量化分析降低風險</li></ul><h3 id="買入時機：-Miner-Capitulation-指標"><a href="#買入時機：-Miner-Capitulation-指標" class="headerlink" title="買入時機： Miner Capitulation 指標"></a>買入時機： Miner Capitulation 指標</h3><p>長期投資，究竟要怎麼投資比特幣？<br>可以參考一個很有用的指標，<br>不過這個指標的原理，比較複雜，<br>需要兩篇的時間慢慢解說：</p><ul><li><a href="/best-indicator-bitcoin/">用Python投資加密貨幣：比特幣操作最強指標(原理篇)</a></li><li><a href="/btc-tradingview-intro/">用Python投資加密貨幣：比特幣操作最強指標(技術篇)</a></li></ul><p>學完後，你就可以製作出下面這種專業的操盤工具喔！</p><center><img src="/btc-summary/ind.png" title="info"></center><p>上述指標<br>在歷史上看來很準確<br>但是可以投資的時機真的太少了<br>畢竟比特幣的上漲跟下跌週期非常長</p><p>要怎麼樣可以安穩的投資加密貨幣呢？<br>我們可以用量化投資的方式，<br>只要重複做簡單的操作<br>就可以有效控制風險！</p><h3 id="用-Python-做量化投資"><a href="#用-Python-做量化投資" class="headerlink" title="用 Python 做量化投資"></a>用 Python 做量化投資</h3><p>要打造一個可用的交易策略，<br>可以參考下方的文章<br>每一步程式碼都可以在 <a href="https://colab.research.google.com/" rel="external nofollow noopener noreferrer" target="_blank">Colab</a> 線上執行<br>不需要安裝和設定 Python 環境，<br>你可以現在就跟我們一起<br>來做量化投資的實驗喔！</p><ol><li>獲得歷史數據：<a href="/btc-crawler-py/">加密貨幣爬蟲撰寫</a></li><li>找出交易訊號：<a href="/btc-trading-signal/">交易策略訊號實做</a></li><li>模擬回測績效：<a href="/btc-simple-sma-backtesting/">實做回測績效驗證</a></li><li>策略參數優化：<a href="/btc-backtesting-optimization/">二十倍的策略優化</a></li></ol><p>學完上方單元，就能做出歷史績效高達20倍的比特幣交易策略喔！</p><center><img src="/btc-summary/after.png" title="info"></center><p>有了以上的研究，<br>再加上你自己的創意，<br>不斷的嘗試，<br>就會有底氣，<br>可以買入人生第一枚加密貨幣了！</p><h3 id="加密貨幣入金"><a href="#加密貨幣入金" class="headerlink" title="加密貨幣入金"></a>加密貨幣入金</h3><p>然而，究竟要怎麼買？買多少？這篇文章告訴你：</p><ul><li><a href="/btc-deposit-how/">如何投資加密貨幣</a></li><li><a href="/btc-deposit-ways/">加密貨幣入金</a></li></ul><p>上面的文章總結，<br>我們可以有兩種投資的方法：</p><ol><li>小額長線投資</li><li>量化策略投資</li></ol><p>其中，量化投資需要有紀律的操作，<br>但是，萬一訊號出現在午夜，<br>難道我們要熬夜操做嗎？<br>也太累了吧？！</p><p>所以我們也額外教大家<br>怎麼做一個全自動化的策略<br>我們是利用 <a href="http://aws.amazon.com/" rel="external nofollow noopener noreferrer" target="_blank">Amazon Web Service （AWS）</a><br>裡面的 Lambda 功能<br>來自動監控策略，<br>決定買入賣出的喔！</p><h3 id="策略雲端交易"><a href="#策略雲端交易" class="headerlink" title="策略雲端交易"></a>策略雲端交易</h3><p>使用 AWS Lambda 的好處<br>就是在每個月提供 400,000 GB-seconds 的額度<br>照著下方的教學，基本上不太會超額<br>讓你雲端<strong>免費</strong>自動下單交易！</p><ul><li><a href="/aws-lambda-initial-setup/">基本功能：AWS 簡易架設</a></li><li><a href="/btc-aws-lambda-signal-update/">用 AWS 算出策略多空</a></li><li><a href="/btc-aws-signal-trigger-condition/">AWS 手機監控與雲端下單</a></li></ul><center><img src="/btc-summary/cloud.png" title="info"></center><p>有了雲端的自動執行策略，<br>就可以讓你 忘記交易<br>直到某一天 突然想起<br>打開手機，發現帳戶資產多了個零！（為了押韻，純屬效果XD）</p><h3 id="用最科學的方式，投資最先進的貨幣"><a href="#用最科學的方式，投資最先進的貨幣" class="headerlink" title="用最科學的方式，投資最先進的貨幣"></a>用最科學的方式，投資最先進的貨幣</h3><p>加密貨幣是體制上的顛覆，<br>加密貨幣之於傳統貨幣，就像是Uber之於計程車行一樣，<br>引入新的科技，必然會有一些配套措施來不及因應（詐騙、價格波動），<br>也會引來舊有制度的既得利益者反感。</p><p>加密貨幣的發展有些顛頗，<br>但長期來說，整個世代會朝著先進、便利的方向發展。<br>或許一百年後的未來，大家會嘲笑現在的金融體制怎麼這麼不方便呢！</p><p>FinLab 的目標，就是<br>希望可以在量化投資的路上，當大家的「武器製造商」！<br>就讓我們一起用 Python 勇闖未來吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年12月，比特幣曾一天上漲20％！&lt;br&gt;我的朋友說，他投資了加密貨幣，&lt;br&gt;但過了一個禮拜，比特幣的價格開始崩盤，而他卻買在高點，&lt;/p&gt;
&lt;p&gt;我就在想，有沒有一種投資方法，&lt;br&gt;可以投資加密貨幣，卻不用承受這麼高的風險？&lt;br&gt;於是開始研究基於加密貨幣的量
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>Bokeh 探索頻道(1)~Python互動式圖表函數庫初體驗</title>
    <link href="https://www.finlab.tw/python-bokeh1-setup-and-first-impression/"/>
    <id>https://www.finlab.tw/python-bokeh1-setup-and-first-impression/</id>
    <published>2020-06-08T01:27:10.000Z</published>
    <updated>2020-06-08T01:43:07.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-視覺化套件使用經驗"><a href="#Python-視覺化套件使用經驗" class="headerlink" title="Python 視覺化套件使用經驗"></a>Python 視覺化套件使用經驗</h2><p>Python套件多，品質不一。用module之前，我習慣先看github星星確認認可度，有1000個以上多是品質保證，再看release history，看是否有被持續維護，那種2年以上沒新版本的，採坑機率高。Bokeh看來沒問題。</p><p><img src="https://i.imgur.com/y3p5KBo.png" alt></p><p>平常python視覺化的主力套件是matplotlib和seaborn，前者是20歲老套件，是視覺化元祖，許多套件基礎都是建構在matplotlib上，像seaborn就是，有更簡潔的寫法和精美圖例，兩者都以靜態視覺居多，缺乏變化性(或是要費點功)。<br>Python守備範圍廣，但在網頁前端仍難以與Java Script抗衡，而D3.js函數庫也要花不少學習成本，有沒有辦法用Python做出JS動態視覺的效果？</p><p>Bokeh的出世，提供了Python與D3.js之間的橋梁，讓你可以用Python做出D3.js常用功能的效果，減少學習成本，高效開發，輕鬆描述統計結果。</p><h2 id="厲害在哪裡？"><a href="#厲害在哪裡？" class="headerlink" title="厲害在哪裡？"></a>厲害在哪裡？</h2><p>先來看Gallory，python視覺化套件很多，範例圖不夠精美的，可考慮跳過。</p><ol><li>化學元素週期表</li></ol><p><img src="https://i.imgur.com/81XiMAU.png" alt="化學元素週期表"></p><ol start="2"><li>雷達圖</li></ol><p><img src="https://i.imgur.com/hMPxBgq.png" alt></p><ol start="3"><li>互動式wiget散點圖表</li></ol><p><img src="https://i.imgur.com/9vnv8yZ.png" alt></p><p>逛了一圈，發現Bokeh圖表精美、範例多、都有附原始碼，官方教學也完整，有tutorial jupyter檔案教學。<br>看來比matplotlib強大，也比plotly漂亮…，函數庫使用看來也不難，且可鑲嵌到Django等Web框架，無論是local或遠端的前端呈現都可以效率開發。</p><h2 id="開箱試玩時間"><a href="#開箱試玩時間" class="headerlink" title="開箱試玩時間"></a>開箱試玩時間</h2><p>要注意的是bokeh會預設連BokehJS cdn，但連線有時不是很穩定，這時可多加”INLINE”環境變數設定，讓BokehJS驅動於local python env。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bokeh.resources <span class="keyword">import</span> INLINE</span><br><span class="line">bokeh.io.output_notebook(INLINE)</span><br></pre></td></tr></table></figure><p>Bokeh可以在Jupyter呈現開發也可以跳轉出html檔，可自由設定，預設是跳轉html檔(output_file())。若要更改預設，必須加上<code>bokeh.io.reset_output()</code>重設環境預設。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output_notebook() ＃jupyter呈現</span><br><span class="line">output_file()  ＃html呈現</span><br></pre></td></tr></table></figure><p>fig物件可設定tools參數，圖表會自帶縮放、重整、儲存等功能。<br>以下是參考官方範例後微調的程式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bokeh.plotting <span class="keyword">import</span> figure, output_file, show, output_notebook</span><br><span class="line"><span class="keyword">import</span> bokeh.io</span><br><span class="line"><span class="keyword">from</span> bokeh.resources <span class="keyword">import</span> INLINE</span><br><span class="line"></span><br><span class="line"><span class="comment"># env settings 環境變數設定</span></span><br><span class="line">bokeh.io.reset_output()</span><br><span class="line">bokeh.io.output_notebook(INLINE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare some data</span></span><br><span class="line">x = [<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>, <span class="number">3.0</span>]</span><br><span class="line">y0 = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">y1 = [<span class="number">10</span>**i <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">y2 = [<span class="number">10</span>**(i**<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line"><span class="comment"># output to static HTML file</span></span><br><span class="line"><span class="comment"># output_file("log_lines.html")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create a new plot</span></span><br><span class="line">p = figure(</span><br><span class="line">tools=<span class="string">"pan,box_zoom,reset,save"</span>,</span><br><span class="line">y_axis_type=<span class="string">"log"</span>, y_range=[<span class="number">0.001</span>, <span class="number">10</span>**<span class="number">11</span>], title=<span class="string">"log axis example"</span>,</span><br><span class="line">x_axis_label=<span class="string">'sections'</span>, y_axis_label=<span class="string">'particles'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add some renderers</span></span><br><span class="line">p.line(x, x, legend_label=<span class="string">"y=x"</span>)</span><br><span class="line">p.circle(x, x, legend_label=<span class="string">"y=x"</span>, fill_color=<span class="string">"white"</span>, size=<span class="number">8</span>)</span><br><span class="line">p.line(x, y0, legend_label=<span class="string">"y=x^2"</span>, line_width=<span class="number">3</span>)</span><br><span class="line">p.line(x, y1, legend_label=<span class="string">"y=10^x"</span>, line_color=<span class="string">"red"</span>)</span><br><span class="line">p.circle(x, y1, legend_label=<span class="string">"y=10^x"</span>, fill_color=<span class="string">"red"</span>, line_color=<span class="string">"red"</span>, size=<span class="number">6</span>)</span><br><span class="line">p.line(x, y2, legend_label=<span class="string">"y=10^x^2"</span>, line_color=<span class="string">"orange"</span>, line_dash=<span class="string">"4 4"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show the results</span></span><br><span class="line">show(p)</span><br><span class="line">output_notebook() </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/cK9ZFBB.png" alt></p><h2 id="投資圖表試玩"><a href="#投資圖表試玩" class="headerlink" title="投資圖表試玩"></a>投資圖表試玩</h2><p>Bokeh官方有提供sample_data給大家練習，gallery豐富的範例都取自sample_data，對比官方的資料格式就能輕鬆模仿應用，沒啥高深程式技巧。下載sample_data指令為<code>bokeh.sampledata.download()</code>，直接貼在jupyter執行。檔案會下載到bokeh module裡。</p><h3 id="檢查蘋果電腦範例資料-json"><a href="#檢查蘋果電腦範例資料-json" class="headerlink" title="檢查蘋果電腦範例資料(json)"></a>檢查蘋果電腦範例資料(json)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bokeh.sampledata.stocks <span class="keyword">import</span> AAPL</span><br><span class="line"><span class="comment"># 檢查欄位</span></span><br><span class="line">AAPL.keys()</span><br><span class="line"><span class="comment">#dict_keys(['date', 'open', 'high', 'low', 'close', 'volume', 'adj_close'])</span></span><br></pre></td></tr></table></figure><h3 id="ColumnDataSource物件為Bokeh資料驅動渲染核心"><a href="#ColumnDataSource物件為Bokeh資料驅動渲染核心" class="headerlink" title="ColumnDataSource物件為Bokeh資料驅動渲染核心"></a>ColumnDataSource物件為Bokeh資料驅動渲染核心</h3><p>dataframe要傳入ColumnDataSource才能驅動js。<br>providing the data that is visualized by the glyphs of the plot<br><a href="https://docs.bokeh.org/en/latest/docs/user_guide/data.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.bokeh.org/en/latest/docs/user_guide/data.html</a></p><h3 id="HoverTool"><a href="#HoverTool" class="headerlink" title="HoverTool"></a>HoverTool</h3><p>游標滑過時顯示資料</p><h3 id="Click-policy"><a href="#Click-policy" class="headerlink" title="Click_policy"></a>Click_policy</h3><p>藉由標籤控制數值顯示<br>hide為隱藏，mute為切換自訂顯示模式<br>可在muted_color控制顏色, muted_alpha控制顏色濃淡</p><h3 id="程式範例"><a href="#程式範例" class="headerlink" title="程式範例"></a>程式範例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> bokeh.io</span><br><span class="line"><span class="keyword">from</span> bokeh.resources <span class="keyword">import</span> INLINE</span><br><span class="line"><span class="keyword">from</span> bokeh.models <span class="keyword">import</span> HoverTool</span><br><span class="line"><span class="keyword">from</span> bokeh.palettes <span class="keyword">import</span> Spectral4</span><br><span class="line"><span class="keyword">from</span> bokeh.plotting <span class="keyword">import</span> figure, output_file, show, output_notebook, ColumnDataSource</span><br><span class="line"><span class="keyword">from</span> bokeh.sampledata.stocks <span class="keyword">import</span> AAPL, GOOG, IBM, MSFT</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># env settings</span></span><br><span class="line">bokeh.io.reset_output()</span><br><span class="line">bokeh.io.output_notebook(INLINE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set hover</span></span><br><span class="line"><span class="comment">## HoverTool</span></span><br><span class="line"><span class="comment"># 游標滑過時顯示資料,date格式需要轉換，不然會是timestamp</span></span><br><span class="line">hover = HoverTool(</span><br><span class="line">    tooltips = [</span><br><span class="line">        (<span class="string">"date"</span>, <span class="string">"@date"</span>),</span><br><span class="line">        (<span class="string">"close"</span>, <span class="string">"@open"</span>),</span><br><span class="line">        (<span class="string">"close"</span>, <span class="string">"@close"</span>),</span><br><span class="line">        (<span class="string">"high"</span>, <span class="string">"@high"</span>),</span><br><span class="line">        (<span class="string">"low"</span>, <span class="string">"@low"</span>),</span><br><span class="line">        (<span class="string">"volume"</span>,<span class="string">"@volume"</span>)</span><br><span class="line">    ], </span><br><span class="line">    formatters=&#123;<span class="string">"@date"</span>:<span class="string">"datetime"</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set figure</span></span><br><span class="line">p = figure(</span><br><span class="line">    plot_width=<span class="number">1000</span>, </span><br><span class="line">    plot_height=<span class="number">400</span>, </span><br><span class="line">    x_axis_type=<span class="string">"datetime"</span>,</span><br><span class="line">    tools=[hover,<span class="string">"pan,box_zoom,reset,save"</span>],</span><br><span class="line">)</span><br><span class="line">p.title.text = <span class="string">'Stock_Price--Click on legend entries to mute the corresponding lines and show daily details in hover'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use ColumnDataSource to control</span></span><br><span class="line"><span class="comment"># click_policy</span></span><br><span class="line"><span class="comment"># 藉由標籤控制數值顯示</span></span><br><span class="line"><span class="comment"># hide為隱藏，mute為切換自訂顯示模式</span></span><br><span class="line"><span class="comment"># 可在muted_color控制顏色, muted_alpha控制顏色濃淡</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data, name, color <span class="keyword">in</span> zip([AAPL, IBM, MSFT, GOOG], [<span class="string">"AAPL"</span>, <span class="string">"IBM"</span>, <span class="string">"MSFT"</span>, <span class="string">"GOOG"</span>], Spectral4):</span><br><span class="line">    df = pd.DataFrame(data)</span><br><span class="line">    df[<span class="string">'date'</span>] = pd.to_datetime(df[<span class="string">'date'</span>])</span><br><span class="line">    source = ColumnDataSource(df)</span><br><span class="line">    p.line(x=<span class="string">"date"</span>,y=<span class="string">"close"</span>, line_width=<span class="number">2</span>, color=color, alpha=<span class="number">0.8</span>,</span><br><span class="line">           muted_color=color, muted_alpha=<span class="number">0.2</span>, legend_label=name,source=source)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.legend.location = <span class="string">"top_left"</span></span><br><span class="line"><span class="comment"># use hide or mute</span></span><br><span class="line">p.legend.click_policy=<span class="string">"mute"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output_file("interactive_legend.html", title="interactive_legend.py example")</span></span><br><span class="line"></span><br><span class="line">show(p)</span><br><span class="line">output_notebook() </span><br></pre></td></tr></table></figure><h3 id="兩種模式結果比較"><a href="#兩種模式結果比較" class="headerlink" title="兩種模式結果比較"></a>兩種模式結果比較</h3><ol><li><p>Mute<br><img src="https://i.imgur.com/xkQhfUt.png" alt></p></li><li><p>Hide<br><img src="https://i.imgur.com/fKmVrH1.png" alt></p></li></ol><h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>這篇主要是來體會一下Bokeh的效果，不用會JS，隨便玩就有這種效果，蠻滿意的，值得再深入一下細節，把以前matplotlib的圖表都轉來bokeh，無論是在工作上的資料報告還是看盤需要，都蠻方便的。</p><h3 id="程式檔案連結"><a href="#程式檔案連結" class="headerlink" title="程式檔案連結"></a>程式檔案連結</h3><p><a href="https://github.com/benbilly3/bokeh_explore" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/benbilly3/bokeh_explore</a></p><h6 id="tags-bokeh"><a href="#tags-bokeh" class="headerlink" title="tags: bokeh"></a>tags: <code>bokeh</code></h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-視覺化套件使用經驗&quot;&gt;&lt;a href=&quot;#Python-視覺化套件使用經驗&quot; class=&quot;headerlink&quot; title=&quot;Python 視覺化套件使用經驗&quot;&gt;&lt;/a&gt;Python 視覺化套件使用經驗&lt;/h2&gt;&lt;p&gt;Python套件多，品質不一
      
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="資料視覺化" scheme="https://www.finlab.tw/tags/%E8%B3%87%E6%96%99%E8%A6%96%E8%A6%BA%E5%8C%96/"/>
    
      <category term="bokeh" scheme="https://www.finlab.tw/tags/bokeh/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：手機監控與自動下單 (Part 12)</title>
    <link href="https://www.finlab.tw/btc-aws-signal-trigger-condition/"/>
    <id>https://www.finlab.tw/btc-aws-signal-trigger-condition/</id>
    <published>2020-05-31T20:23:13.000Z</published>
    <updated>2020-06-10T01:46:51.896Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/btc-aws-signal-trigger-condition/thumbnail.png" title="thumbnail"></center><p>我們上次已經寫好了「核心」程式<br>但什麼時候，才能執行這些程式呢？<br>總共有兩種方式啟動程式：</p><ol><li>一種是連上網監控</li><li>另一種是時間間格、自動下單（每4小時）</li></ol><h3 id="1-連上網監控"><a href="#1-連上網監控" class="headerlink" title="1. 連上網監控"></a>1. 連上網監控</h3><p>我們可以用「新增觸發條件」來觸發，<br>並且點選「API Gateway」：</p><center><img src="/btc-aws-signal-trigger-condition/selectTrigger.png" title="thumbnail"></center><br><center><img src="/btc-aws-signal-trigger-condition/createGateway.png" title="thumbnail"></center><br>最後會給你一個網址<br>用任何手機、筆電 連進去就可以了！<br><center><img src="/btc-aws-signal-trigger-condition/triggerUrl.png" title="thumbnail"></center><br><center><img src="/btc-aws-signal-trigger-condition/results.png" title="thumbnail"></center><h3 id="2-時間間格、自動下單"><a href="#2-時間間格、自動下單" class="headerlink" title="2. 時間間格、自動下單"></a>2. 時間間格、自動下單</h3><p>首先我們先將原本的 API Gateway 刪除<br>然後再增加新的 Trigger：每4小時執行一次</p><p><center><img src="/btc-aws-signal-trigger-condition/addcron.png" title="thumbnail"></center><br>這樣就會四小時執行一次了！</p><p>假如我們希望它四小時判斷多空與下單，<br>可以將上一個單元的範例<br>做以下的修改</p><ol><li>新增 client 使用金鑰登入（可以到 <a href="https://www.binance.com/tw/" rel="external nofollow noopener noreferrer" target="_blank">Binance</a> 申請）</li><li>做多時，要買入「BTCUSDT」</li><li>做空時，賣出「BTCUSDT」</li></ol><p>以下的範例，在做空時，<br>我們只單純的賣出，而不額外做空<br>因為我們現在是用現貨且無槓桿的交易帳戶<br>所以沒有辦法做空喔！<br>假如想要做BTC期貨，也可以參考<a href="https://python-binance.readthedocs.io/en/latest/margin.html" rel="external nofollow noopener noreferrer" target="_blank">官方的Margin Trading End Point</a></p><p>以下就是現貨範例，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> binance.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lambda_handler</span><span class="params">(event, context)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##########</span></span><br><span class="line">    <span class="comment"># Login #</span></span><br><span class="line">    <span class="comment">##########</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># before:</span></span><br><span class="line">    <span class="comment"># client = Client()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># after:</span></span><br><span class="line">    PUBLIC = <span class="string">'&lt;YOUR-PUBLIC-KEY&gt;'</span></span><br><span class="line">    SECRET = <span class="string">'&lt;YOUR-SECRET-KEY&gt;'</span></span><br><span class="line">    QUANTITY = <span class="number">0.0001</span></span><br><span class="line"></span><br><span class="line">    client = Client(api_key=PUBLIC, api_secret=SECRET)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">###################</span></span><br><span class="line">    <span class="comment"># historical data #</span></span><br><span class="line">    <span class="comment">###################</span></span><br><span class="line">    </span><br><span class="line">    klines = client.get_historical_klines(<span class="string">"BTCUSDT"</span>, Client.KLINE_INTERVAL_4HOUR, <span class="string">"two week ago"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sma</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-1</span>:<span class="number">-1</span>]])/n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prev_sma</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-2</span>:<span class="number">-2</span>]])/n</span><br><span class="line">    </span><br><span class="line">    sma60 = sma(<span class="number">65</span>)</span><br><span class="line">    sma5 = sma(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    psma60 = prev_sma(<span class="number">65</span>)</span><br><span class="line">    psma5 = prev_sma(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">###################</span></span><br><span class="line">    <span class="comment">#      Trade      #</span></span><br><span class="line">    <span class="comment">###################</span></span><br><span class="line">    </span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">        ret = <span class="string">'long'</span></span><br><span class="line">        order = client.order_market_buy(</span><br><span class="line">            symbol=<span class="string">'BTCUSDT'</span>,</span><br><span class="line">            quantity=QUANTITY)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">        ret = <span class="string">'short'</span></span><br><span class="line">        order = client.order_market_sell(</span><br><span class="line">            symbol=<span class="string">'BTCUSDT'</span>,</span><br><span class="line">            quantity=QUANTITY)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">        ret = <span class="string">'hold short'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">        ret = <span class="string">'hold long'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO implement</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'statusCode'</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">'body'</span>: json.dumps(<span class="string">'btc-trading-signal: '</span> + ret)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>經過這12個單元，<br>相信大家對於加密貨幣量化交易有初步的理解<br>大概瞭解如何建構一個自動化的交易系統</p><p>你會發現<br>手刻一個交易系統，其實沒有很難<br>難的在於，<br>如何「系統化」的建立一個多元的交易策略<br>研發多個策略 並統整起來，<br>考驗大家撰寫策略、系統化的能力</p><p>怕輸太多錢嗎？<br>沒關係，因為加密貨幣可以切割至 10 的 8 次方！<br>就算你有一百種不同的策略，<br>也可以用300元台幣順利分散風險喔！<br>所以不要再猶豫了，趕快來試試看吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/btc-aws-signal-trigger-condition/thumbnail.png&quot; title=&quot;thumbnail&quot;&gt;&lt;/center&gt;

&lt;p&gt;我們上次已經寫好了「核心」程式&lt;br&gt;但什麼時候，才能執行這些程式呢？&lt;br&gt;總共
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：用AWS Lambda即時更新交易訊號 (Part 11)</title>
    <link href="https://www.finlab.tw/btc-aws-lambda-signal-update/"/>
    <id>https://www.finlab.tw/btc-aws-lambda-signal-update/</id>
    <published>2020-05-25T06:35:48.000Z</published>
    <updated>2020-06-11T17:28:29.116Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/btc-aws-lambda-signal-update/thumbnail.png" title="thumbnail"></center><p>上一個單元中，<br>大家都已經操作好了 AWS Lambda<br>建立一個簡單的 Hello World</p><p>接下來，<br>我們就可以開始建構<br>比特幣的交易系統了</p><p>首先，可以先在 local 端架設環境，<br>方便我們確認程式可以跑，<br>之後再把它複製到雲端即可。</p><p>首先在本地端先安裝 python-binance<br>用來收報價與下單：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-binance</span><br></pre></td></tr></table></figure><p>再來，<br>撰寫交易系統的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> binance.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"><span class="comment"># get price from binance api</span></span><br><span class="line">client = Client()</span><br><span class="line">klines = client.get_historical_klines(<span class="string">"BTCUSDT"</span>, Client.KLINE_INTERVAL_4HOUR, <span class="string">"two week ago"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># function to calculate sma value</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sma</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-1</span>:<span class="number">-1</span>]])/n</span><br><span class="line"></span><br><span class="line"><span class="comment"># function to calculate previous sma value</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prev_sma</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-2</span>:<span class="number">-2</span>]])/n</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate sma 5 and 65</span></span><br><span class="line">sma60 = sma(<span class="number">65</span>)</span><br><span class="line">sma5 = sma(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate previous sma 5 and 65</span></span><br><span class="line">psma60 = prev_sma(<span class="number">65</span>)</span><br><span class="line">psma5 = prev_sma(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># golden cross</span></span><br><span class="line"><span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">    print(<span class="string">'flip to long'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># dead cross</span></span><br><span class="line"><span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">    print(<span class="string">'flip to short'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hold for short</span></span><br><span class="line"><span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">    print(<span class="string">'hold short'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hold for long</span></span><br><span class="line"><span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">    print(<span class="string">'hold long'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上，我們建構一個簡單的程式碼<br>每次執行，都可以產生出當前的訊號～<br>這個策略<br>就是我們在<a href="btc-backtesting-optimization/">前個單元中</a><br>經過優化後的均線策略，<br>這邊我們用不同的方式撰寫一次</p><p>接下來<br>就是將以上的程式碼<br>移到 AWS Lambda 上！</p><p>首先，跟剛剛一樣，<br>在 Lambda 上，<br>我們可以先來安裝<br>Binance 的 API<br>來獲取報價跟下單</p><p>之前，我們只需要使用<br>pip install python-binance<br>就可以安裝了</p><p>但 AWS 上要安裝 package 呢？<br>AWS 沒有一台 server 可以下安裝指令<br>所以我們可以先自己下載 </p><p>「python-binance」這個 package<br>壓縮成壓縮檔，<br>這個檔案以AWS的術語，叫做 AWS Layer ，<br>我已經幫大家打包好了，<br>可以<a href="/btc-aws-lambda-signal-update/lambda-layer-binance.zip">點此下載</a><br>並將 AWS Layer 上傳上去，<br>方法如下圖：</p><center><img src="/btc-aws-lambda-signal-update/layer1.png" title="設定layer"></center><br><center><img src="/btc-aws-lambda-signal-update/layer2.png" title="設定layer2"></center><p>就等於是安裝完畢了</p><p>剩下就簡單了！<br>我們可以到上個單元創建的 Lambda 函數：</p><center><img src="/btc-aws-lambda-signal-update/lambda-select-helloworld.png" title="開啟helloworld"></center><p>並在這個 lambda 函數中<br>新增我們剛剛上傳的layer：</p><center><img src="/btc-aws-lambda-signal-update/lambda-add-layer.png" title="新增layer"></center><br><center><img src="/btc-aws-lambda-signal-update/lambda-add-layer2.png" title="新增layer2"></center><p>最後，我們點選 Hello Lmabda 並往下拉到程式碼編輯視窗：</p><center><img src="/btc-aws-lambda-signal-update/lambda-editor.png" title="編輯器"></center><p>複製到下方的程式碼，到程式碼編輯視窗之中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> binance.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lambda_handler</span><span class="params">(event, context)</span>:</span></span><br><span class="line">    </span><br><span class="line">    client = Client()</span><br><span class="line">    </span><br><span class="line">    klines = client.get_historical_klines(<span class="string">"BTCUSDT"</span>, Client.KLINE_INTERVAL_4HOUR, <span class="string">"two week ago"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sma</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-1</span>:<span class="number">-1</span>]])/n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prev_sma</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-2</span>:<span class="number">-2</span>]])/n</span><br><span class="line">    </span><br><span class="line">    sma60 = sma(<span class="number">65</span>)</span><br><span class="line">    sma5 = sma(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    psma60 = prev_sma(<span class="number">65</span>)</span><br><span class="line">    psma5 = prev_sma(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">        ret = <span class="string">'flip to long'</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">        ret = <span class="string">'flip to short'</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">        ret = <span class="string">'hold short'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">        ret = <span class="string">'hold long'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO implement</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'statusCode'</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">'body'</span>: json.dumps(<span class="string">'btc-trading-signal: '</span> + ret)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>點選「測試」按鈕後，可以用了！</p><p><center><img src="/btc-aws-lambda-signal-update/result.png" title="檢查"></center><br>上圖中，顯示「hold short」代表我們現在是持續偏空的狀態<br>每次按一下 test ，<br>就可以顯示目前的訊號喔！</p><p>目前我們要登入AWS<br>並且執行 lambda 才能看到訊號<br>有點麻煩呀！</p><p>所以在下一個單元，<br>我們將會分享<br><a href="/btc-aws-signal-trigger-condition/">怎麼樣從手機上看到交易訊號</a><br>以及把這個交易訊號實際下單的方法！<br>可以到<a href="https://www.facebook.com/finlab.python" rel="external nofollow noopener noreferrer" target="_blank">粉專按讚追蹤</a><br>才不會錯過我們每週的更新喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/btc-aws-lambda-signal-update/thumbnail.png&quot; title=&quot;thumbnail&quot;&gt;&lt;/center&gt;

&lt;p&gt;上一個單元中，&lt;br&gt;大家都已經操作好了 AWS Lambda&lt;br&gt;建立一個簡單的 He
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：架設一個簡易的AWS交易系統 (Part 10)</title>
    <link href="https://www.finlab.tw/aws-lambda-initial-setup/"/>
    <id>https://www.finlab.tw/aws-lambda-initial-setup/</id>
    <published>2020-05-18T06:35:48.000Z</published>
    <updated>2020-06-11T17:27:49.358Z</updated>
    
    <content type="html"><![CDATA[<p>延續之前的介紹，<br>這個單元中，<br>我們將架設一個簡單的 <a href="https://aws.amazon.com/tw/lambda/" rel="external nofollow noopener noreferrer" target="_blank">AWS Lambda function</a><br>是 AWS ( Amazon cloud service ) 底下的一個服務</p><center><img src="/aws-lambda-initial-setup/thumbnail.png" title="info"></center><p>AWS Lambda function，<br>是一段可以自定義的程式碼<br>會在 AWS 主機上執行<br>可以經由任意的方式啟動，<br>例如每個整點執行一次</p><p>例如以下的例子，<br>就是當使用者上傳照片後<br>就可以用 Lambda function<br>雲端將照片縮小，然後輸出到網頁上：</p><center><img src="/aws-lambda-initial-setup/usage.png" title="info"></center><p>之後我們的交易系統，<br>就會寫在這樣的 function 裡面</p><p>AWS免費提供40萬秒/月，可以讓我們執行 AWS Lambda function<br>所以假如我們的策略頻率是「小時」的話，是非常充足的！</p><p>首先我們可以打開<a href="https://aws.amazon.com/tw/" rel="external nofollow noopener noreferrer" target="_blank">Amazon Web Service網頁</a>，<br>並且註冊帳號，取得服務，<br>在這個過程中，會需要輸入信用卡，<br>不過並不會額外收費，</p><p>進入了主控台們點選 Lambda</p><center><img src="/aws-lambda-initial-setup/open_lambda.png" title="info"></center><p>新增 Lambda 函數</p><center><img src="/aws-lambda-initial-setup/open_panel.png" title="info"></center><p>並且選擇最簡單的Hello World<br>程式語言設定成「Python3.6」<br>按一下右下角確定，稍等一會就成功了！</p><center><img src="/aws-lambda-initial-setup/new_lambda.png" title="info"></center><p>接下來，<br>我們就會看到lambda的頁面，<br>可以在這個頁面下，<br>它已經預設了一個程式，</p><center><img src="/aws-lambda-initial-setup/code.png" title="info"></center><p>我們之後會來修改它<br>不過先不急，我們先跑跑看</p><p>可以按「測試」並且建立預設的事件，<br>你就會看到測試結果：成功！</p><center><img src="/aws-lambda-initial-setup/test.png" title="info"></center><p>接下來我們就要在這個基礎下，來建構一個交易的邏輯，<br>並且每個小時來執行一次！<br><a href="/btc-aws-lambda-signal-update/">詳情請看：AWS Lambda 交易訊號產生</a><br>假如對於我們的新文章有興趣，可以幫我們追蹤<a href="https://www.facebook.com/finlab.python" rel="external nofollow noopener noreferrer" target="_blank">我們的粉絲團</a>喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;延續之前的介紹，&lt;br&gt;這個單元中，&lt;br&gt;我們將架設一個簡單的 &lt;a href=&quot;https://aws.amazon.com/tw/lambda/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>創新高股票，你還少看了這個因子！</title>
    <link href="https://www.finlab.tw/break-new-high-roe-stock/"/>
    <id>https://www.finlab.tw/break-new-high-roe-stock/</id>
    <published>2020-05-17T05:21:38.000Z</published>
    <updated>2020-06-05T07:29:51.016Z</updated>
    
    <content type="html"><![CDATA[<p>假如你是追高的選股策略，<br>有沒有一種感覺？<br>就是往往創新高的股票，<br>大部分都賠錢，<br>只有少部分賺錢，</p><p>今天我們將介紹一個因子，<br>大幅提昇創新高獲利的效果！</p><center><img src="/break-new-high-roe-stock/thumbnail.jpeg" title="動手做"></center><p>這種追高的策略，<br>有幾個比較難克服的地方，<br>我們將介紹<br>一個可以破解這些課題的策略。</p><h3 id="1-心理因素"><a href="#1-心理因素" class="headerlink" title="1. 心理因素"></a>1. 心理因素</h3><p>一個就是心魔，<br>因為勝率真的很低<br>所以你會覺得<br>怎麼一直輸錢？<br>造成人為干預嚴重</p><p>所以在追高股票時，<br>最好還是讓自己「分心」<br>也就是透過持有多檔股票的方式<br>讓自己不會過度在乎一檔個股</p><h3 id="2-選到亂漲一通的股票"><a href="#2-選到亂漲一通的股票" class="headerlink" title="2. 選到亂漲一通的股票"></a>2. 選到亂漲一通的股票</h3><p>另外，<br>有時候股票市場很感性<br>不能用理性的方式來交易</p><p>有些個股<br>明明股價淨值比都5以上<br>本益比都50了<br>還漲個沒完</p><p>針對這種個股<br>要是去追高<br>很有可能買在高點！</p><p>所以我們可以用「基本面」<br>來分析這檔股票的「創新高」<br>合不合理</p><h3 id="總結以上兩點-製作創新高策略"><a href="#總結以上兩點-製作創新高策略" class="headerlink" title="總結以上兩點 製作創新高策略"></a>總結以上兩點 製作創新高策略</h3><h4 id="1-動態調整-Portfolio"><a href="#1-動態調整-Portfolio" class="headerlink" title="1. 動態調整 Portfolio"></a>1. 動態調整 Portfolio</h4><p>每兩個禮拜調整一次所選的股票，<br>並將資產「平均分配」於所選的股票中，</p><h4 id="2-基本面篩選"><a href="#2-基本面篩選" class="headerlink" title="2. 基本面篩選"></a>2. 基本面篩選</h4><p>我們並不是看到創新高就無條件選這些股票<br>必須搭配基本面的因子，<br>來選出更有可能維持上漲的股票：</p><ol><li>創新高：股價突破60天內股價</li><li>ROE大於3，前一季ROE大於1</li></ol><p>另外由於股價容易受流動性影響，<br>我們希望買入賣出有流動性的股票：</p><ol start="3"><li>股價大於7</li><li>成交量大於100張</li></ol><p>才能更順利<br>在任意時刻買賣股票</p><h4 id="3-新因子研發"><a href="#3-新因子研發" class="headerlink" title="3. 新因子研發"></a>3. 新因子研發</h4><p>最後，最重要的因子<br>忍痛割愛告訴大家<br>我們特別研發一個「成長+價值」的複合因子：</p><p>新因子 = 當季ROE / 前一季ROE / 股價淨值比</p><p>新因子可以拆解成兩個部分：</p><h5 id="第一部份：成長股篩選"><a href="#第一部份：成長股篩選" class="headerlink" title="第一部份：成長股篩選"></a>第一部份：成長股篩選</h5><p>這個新因子當中，成長的部分是<br>「當季ROE / 前一季ROE」<br>這些ROE成長的股票，這個數值會大於1</p><h5 id="第二部分：價值股篩選"><a href="#第二部分：價值股篩選" class="headerlink" title="第二部分：價值股篩選"></a>第二部分：價值股篩選</h5><p>接下來，我們要選 CP 值高的股票<br>股價淨值比<br>就是一個很好的指標<br>可以幫我們判斷股票的價格是否太高，<br>我們希望<br>「1 ／ 股價淨值比」<br>越大越好，<br>可以參考<a href="/股價淨值比有這麼神？/">「股價淨值比」</a>來瞭解更詳細的原理喔！</p><h5 id="將上述兩種因子合併"><a href="#將上述兩種因子合併" class="headerlink" title="將上述兩種因子合併"></a>將上述兩種因子合併</h5><p>用乘法，將這兩種因子合併起來：</p><p>新因子 = 當季ROE / 前一季ROE / 股價淨值比</p><p>我們將每檔股票都算出此因子，假如當天有超過三檔股票創新高，<br>用這個因子排序，並選出前 3 名的股票，<br>新增到我們的 portfolio 組合裡面</p><h3 id="賣出策略"><a href="#賣出策略" class="headerlink" title="賣出策略"></a>賣出策略</h3><p>當股價收盤價小於 20 日均，則賣出</p><h3 id="回測結果"><a href="#回測結果" class="headerlink" title="回測結果"></a>回測結果</h3><p>本文章所公佈的「新因子」<br>究竟對於這些創新高有什麼樣子的影響呢？</p><center><img src="/break-new-high-roe-stock/compare.png" title="動手做"></center><br>上圖中<br>藍色的數值為使用「新因子」，<br>每次加入3檔股票的方法<br>而橘色的為，「沒有用新因子」，<br>每次加入數檔股票的方法<br><br><strong>效果差距非常多！</strong><br><br>以下是策略的回測相關數值和風險，<br>假如你希望用 Python<br>跟我們一起研究量化投資，<br>可以參加「<a href="https://hahow.in/cr/python-finance" rel="external nofollow noopener noreferrer" target="_blank">小資族選股策略</a>」和「<a href="https://hahow.in/cr/finlab-ml" rel="external nofollow noopener noreferrer" target="_blank">AI股票理專</a>」，<br>一起來研發有用的選股邏輯喔！<br><br>假如你是有加入課程的同學，<br>可以直接使用以下的程式碼開始選股喔！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from finlab.data import Data</span><br><span class="line"></span><br><span class="line">data = Data()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#############</span><br><span class="line"># 股價淨值比  #</span><br><span class="line">#############</span><br><span class="line">price = data.get(&apos;收盤價&apos;, 300)</span><br><span class="line">股東權益 = data.get(&apos;歸屬於母公司業主之權益合計&apos;, 1)</span><br><span class="line">股本 = data.get(&apos;普通股股本&apos;, 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">流通股數 = 股本 / 10</span><br><span class="line">每股淨值 = 股東權益 / 流通股數</span><br><span class="line">今日股價 = price.iloc[-1]</span><br><span class="line"></span><br><span class="line">股價淨值比pb = (今日股價 / 每股淨值).squeeze()</span><br><span class="line"></span><br><span class="line">#####################</span><br><span class="line"># 股東權益報酬率 ROE  #</span><br><span class="line">#####################</span><br><span class="line"></span><br><span class="line">稅後淨利 = data.get(&apos;本期淨利（淨損）&apos;, 2)</span><br><span class="line"></span><br><span class="line"># 股東權益，有兩個名稱，有些公司叫做權益總計，有些叫做權益總額</span><br><span class="line"># 所以得把它們抓出來</span><br><span class="line">權益總計 = data.get(&apos;權益總計&apos;, 2)</span><br><span class="line">權益總額 = data.get(&apos;權益總額&apos;, 2)</span><br><span class="line"></span><br><span class="line"># 並且把它們合併起來</span><br><span class="line">權益總計.fillna(權益總額, inplace=True)</span><br><span class="line"></span><br><span class="line">股東權益報酬率 = 稅後淨利.iloc[-1] / 權益總計.iloc[-1]</span><br><span class="line">股東權益報酬率_上季 = 稅後淨利.iloc[-2] / 權益總計.iloc[-2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#####################</span><br><span class="line"># 成交量  #</span><br><span class="line">#####################</span><br><span class="line">vol = data.get(&apos;成交股數&apos;, 100)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">############</span><br><span class="line"># 篩選股票  #</span><br><span class="line">############</span><br><span class="line"></span><br><span class="line">condition1 = (price.rolling(60).max() == price).iloc[-10:].sum() &gt; 0</span><br><span class="line">condition2 = (股東權益報酬率 &gt; 0.03) &amp; (股東權益報酬率_上季 &gt; 0.01)</span><br><span class="line">condition3 = (price.iloc[-1] &gt; 7) &amp; (vol.iloc[-1] &gt; 100000)</span><br><span class="line">rank = 股東權益報酬率 / 股東權益報酬率_上季 / 股價淨值比pb * (condition1 &amp; condition2 &amp; condition3)</span><br><span class="line"></span><br><span class="line">print(&apos;近10天創新高的股票數量&apos;)</span><br><span class="line">print(condition1.sum())</span><br><span class="line"></span><br><span class="line">print(&apos;rank 前10名的股票&apos;)</span><br><span class="line">print(rank[rank &gt; 0].nlargest(10))</span><br></pre></td></tr></table></figure><br><br>附上策略的回測結果<br>祝大家選股愉快！<br><br><center><img src="/break-new-high-roe-stock/eq.png" title="動手做"></center><br><center><img src="/break-new-high-roe-stock/info.png" title="動手做"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假如你是追高的選股策略，&lt;br&gt;有沒有一種感覺？&lt;br&gt;就是往往創新高的股票，&lt;br&gt;大部分都賠錢，&lt;br&gt;只有少部分賺錢，&lt;/p&gt;
&lt;p&gt;今天我們將介紹一個因子，&lt;br&gt;大幅提昇創新高獲利的效果！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/break-new-high
      
    
    </summary>
    
      <category term="股票策略" scheme="https://www.finlab.tw/categories/%E8%82%A1%E7%A5%A8%E7%AD%96%E7%95%A5/"/>
    
    
      <category term="如何買股票" scheme="https://www.finlab.tw/tags/%E5%A6%82%E4%BD%95%E8%B2%B7%E8%82%A1%E7%A5%A8/"/>
    
      <category term="量化投資" scheme="https://www.finlab.tw/tags/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B3%87/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：入金加密貨幣 (Part 9)</title>
    <link href="https://www.finlab.tw/btc-deposit-ways/"/>
    <id>https://www.finlab.tw/btc-deposit-ways/</id>
    <published>2020-05-07T06:50:43.000Z</published>
    <updated>2020-06-11T17:36:57.727Z</updated>
    
    <content type="html"><![CDATA[<p>這陣子加密貨幣大漲，<br>大家都躍躍欲試了吧？<br>但我沒有很開心</p><p>因為價格就是漲漲跌跌<br>漲上去的 - 會下來<br>跌下去的 - 會上去</p><p>不開心<br>就不會難過<br>平心靜氣的投資才是最好的方式<br>（果然文章還沒寫完，就跌了15％XD）</p><p>這個階段，<br>在建構<a href="/btc-deposit-how/">初步的買賣的規劃後</a><br>終於要來買入人生中的第一枚加密貨幣了！</p><p>請不要買太多！！！！<br>假如你下的金額，明天歸零你會心疼<br>那就代表下太多了！</p><p>首先，來看一下<br>入金到交易<br>全部過程總覽：</p><center><img src="/btc-deposit-ways/ways.png" title="ways"></center><p>以台幣來說，可以交易的方式就是以下這幾種：</p><ul><li>透過「簡單買賣」來買加密貨幣</li><li>先入金台幣，再「擇時買賣」加密貨幣</li></ul><p>最主要是以下這四個平台，可以用台幣買加密貨幣喔！</p><h3 id="簡單買賣"><a href="#簡單買賣" class="headerlink" title="簡單買賣"></a>簡單買賣</h3><p><a href="https://www.maicoin.com/" rel="external nofollow noopener noreferrer" target="_blank">Maicoin</a>和<a href="https://www.bitoex.com/" rel="external nofollow noopener noreferrer" target="_blank">Bitoex</a>都是可以簡單買入的平台<br>申請帳號其實很簡單，只要提供</p><ol><li>身份證</li><li>第二證件<br>就可以辦了，因為人工審核需要花一點時間，<br>這段時間就可以來學學<a href="/btc-simple-sma-backtesting/">前面所教的投資方式</a></li></ol><h3 id="擇時買賣"><a href="#擇時買賣" class="headerlink" title="擇時買賣"></a>擇時買賣</h3><p>這類的平台有 <a href="https://max.maicoin.com/signup?r=602dff1a" rel="external nofollow noopener noreferrer" target="_blank">MAX</a> 跟 <a href="https://www.bitopro.com/landing_pages/referral?referrer=7971594176" rel="external nofollow noopener noreferrer" target="_blank">BitoPro</a><br>假如用以上連結註冊會員的話，你可以享手續費8折喔！<br>而我也會收到平台的獎勵，<br>當作是這個免費的課程的支持XD</p><p>以上這兩個平台<br>其實就是 Maicoin 跟 BitoEx 的加強版<br>都是以0成本先入金台幣，再做交易，<br>做交易酌收手續費</p><h3 id="Binance-P2P-直接購買-BTC"><a href="#Binance-P2P-直接購買-BTC" class="headerlink" title="Binance P2P 直接購買 BTC"></a>Binance P2P 直接購買 BTC</h3><p>其實<a href="https://www.binance.com/tw/register?ref=23975897" rel="external nofollow noopener noreferrer" target="_blank">Binance</a>也有提供P2P來購買BTC的方式<br>但是現在只限BTC，沒有USDT，且由於是P2P，交易比較沒有保障</p><h3 id="為什麼要提供多家呢？"><a href="#為什麼要提供多家呢？" class="headerlink" title="為什麼要提供多家呢？"></a>為什麼要提供多家呢？</h3><p>因為多方比對，找出最便宜的入金方式，<br>是很重要的<br>以上四個平台的價格，<br>報價都是不一樣的，<br>所以一定要貨比多家！，<br>另外「簡單買賣」那兩家，<br>入金完全是看該加密貨幣的報價，手續費已經算進去了<br>而「擇時買賣」的平台，是台幣入金不用錢，但是交易要扣0.05%手續費</p><p>假如要交易，我建議一次辦好這四個，<br>反正要上傳的東西都是一樣的！</p><h3 id="這四家都辦好了，要買什麼幣呢？"><a href="#這四家都辦好了，要買什麼幣呢？" class="headerlink" title="這四家都辦好了，要買什麼幣呢？"></a>這四家都辦好了，要買什麼幣呢？</h3><p>可以給你個方向，</p><p>假如你有做超長線交易，<br>那就可以直接買 BTC，<br>不過因為長期持有<br>風險就比較高，請自行斟酌</p><p>假如你想交易波段，<br>那就先買入 USDT，<br>在<a href="/btc-crawler-py/">前幾篇</a>有提到<br>這是跟美金 1:1 的加密貨幣</p><p>之後交易時，在來用 USDT 買賣 BTC</p><h3 id="如何自動交易呢？"><a href="#如何自動交易呢？" class="headerlink" title="如何自動交易呢？"></a>如何自動交易呢？</h3><p>我比較喜歡去成交量大一點的交易平台，<br>這邊我以 Binance 為例，<br>我們將購入的 USDT 轉到 Binance，<br>不論金額，這四個平台都差不多，<br>將會有約 100 元台幣的出金手續費</p><p>下圖以 Maicoin為例，講解一次整體的操作過程，<br>主要分成兩個步驟，</p><ol><li>買入 USDT</li><li>將 USDT 存入 Binance</li></ol><h4 id="1-買入-USDT"><a href="#1-買入-USDT" class="headerlink" title="1. 買入 USDT"></a>1. 買入 USDT</h4><p>首先，我們點選「購買」-&gt;「USDT」，<br>然後輸入，購買的數量，通常我會直接輸入台幣，平台自動換算<br>選擇付款方式，然後按購買<br>跟網拍一樣XDDD</p><h3 id="2-存入-Binance"><a href="#2-存入-Binance" class="headerlink" title="2. 存入 Binance"></a>2. 存入 Binance</h3><p>在Maicoin介面，購買後，選擇「發送」-&gt;「USDT」<br>在Binance介面，選擇「收取」-&gt;「USDT」<br>這時候，Binance就會提供一個虛擬位置，請複製起來，<br>並且在Maicoin的介面上貼上</p><p>以上的步驟，要小心，千萬要選擇 USDT 的「發送」和「收取」<br>不然你的$就會丟失喔！<br>請非常小心，再三確認！</p><p>由於交易鏈不會馬上傳送，會先以區塊的方式保留，<br>所以你暫時會看到，你的兩邊存款都是0，XDD<br>但不用擔心，你的轉帳手續正在驗證中，<br>你可以到 <a href="https://www.omniexplorer.info/" rel="external nofollow noopener noreferrer" target="_blank">USDT待驗證區塊的搜尋網站</a><br>輸入帳戶位置，<br>就可以看到正在驗證的交易，<br>所以$沒有丟失啦！</p><p>我建議，假如你想要做波段，並且跟著課程走<br>可以先開戶，<strong>等後面的文章出來了</strong>，<br>先操作小金額，例如500、1000元台幣，測試看看<br>沒錯，小金額就可以架設波段交易程式了！<br>瞭解所有的操作流程，再來考慮增加一點資金。</p><p>下個單元中，我們將教你<br>如何用 Python API<br>在Binance上做 BTC/USDT 的交易！</p><p>可以先申請點下方連結註冊<br><a href="https://www.binance.com/tw/register?ref=HXO25II1" rel="external nofollow noopener noreferrer" target="_blank">https://www.binance.com/tw/register?ref=HXO25II1</a><br>來節省每筆10％的交易手續費，</p><p>入金完畢！<br>那我們就在<a href="/aws-lambda-initial-setup/">下個單元 - 架設雲端交易系統</a>囉！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這陣子加密貨幣大漲，&lt;br&gt;大家都躍躍欲試了吧？&lt;br&gt;但我沒有很開心&lt;/p&gt;
&lt;p&gt;因為價格就是漲漲跌跌&lt;br&gt;漲上去的 - 會下來&lt;br&gt;跌下去的 - 會上去&lt;/p&gt;
&lt;p&gt;不開心&lt;br&gt;就不會難過&lt;br&gt;平心靜氣的投資才是最好的方式&lt;br&gt;（果然文章還沒寫完，就跌了1
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：如何投資(投機) 加密貨幣 (Part 8)</title>
    <link href="https://www.finlab.tw/btc-deposit-how/"/>
    <id>https://www.finlab.tw/btc-deposit-how/</id>
    <published>2020-05-04T20:23:13.000Z</published>
    <updated>2020-06-11T17:31:09.885Z</updated>
    
    <content type="html"><![CDATA[<p>自從本blog開始介紹 BTC 以來，<br>BTC已經上漲了約25％！<br>我是有稍微選一下發文時機的，<br>很想說自己未卜先知，但世界上沒有這種事情，<br>只能說是個美麗的巧合吧！</p><center><img src="/btc-deposit-how/thumbnail.jpeg" title="thumbnail"></center><p>畢竟所有的指標都是參考用，<br>我們處在瞬息萬變的世界，<br>別想要預測市場<br>而是以最機械的方式來投資<br>才不會無所適從、舉棋不定</p><p>這個單元中，要來介紹，<br>我用哪些方法來投資比特幣，<br>最主要是兩種<br>只是分享，非建議喔！</p><h2 id="1-長線投資"><a href="#1-長線投資" class="headerlink" title="1. 長線投資"></a>1. 長線投資</h2><p>記得在2013年的時候，</p><p>有一個大學生問<br>「我現在有1萬元，要投資什麼比較好？」</p><p>有人回答<br>「買入比特幣，不要管它，等你畢業了再換成現金」</p><p>要是當時真的照這個方法操作，<br>畢業後，基本上就已經財富自由了</p><p>這個故事告訴我們，有時候<br>挑好商品，買了放著，不要亂動，<br>其實也滿好的</p><h3 id="買入的原因"><a href="#買入的原因" class="headerlink" title="買入的原因"></a>買入的原因</h3><p>買 BTC<br>一定是有價格以外的原因，<br>就像是去菜市場買菜，<br>為什麼買這顆蘋果？<br>因為它顏色鮮豔、比較大顆、看起來比較甜，等<br>而不是因為這顆蘋果最近上漲<br>（沒人這樣買蘋果吧？）</p><p>買 BTC 一樣要有理由<br>而不是覺得大家都在買，就跟著買<br>不然，大家都再賣，就跟著賣，<br>很容易就賠錢了</p><h3 id="我的買入原因"><a href="#我的買入原因" class="headerlink" title="我的買入原因"></a>我的買入原因</h3><p>我的買入理由，就是<br>BTC市值當時跟黃金比<br>不到1/50<br>BTC 有著優越的貨幣的特性，<br>理論上應該是很有潛力的</p><p>設定一個出場條件，然後嚴格執行，</p><h3 id="出場條件"><a href="#出場條件" class="headerlink" title="出場條件"></a>出場條件</h3><p>例如我的出場條件就是：<br>BTC 到達跟 黃金市值平起平坐，<br>不過世界上哪有一定準確的預言？<br>所以保險起見可以設定<br>「比特幣：黃金」<br>「市值 1：10」<br>「市值 1：5」<br>「市值 1：2」<br>「市值 1：1」<br>分別出場，這並不是投資建議，<br>只是我自己的規劃而已<br>一定要做賣出條件，因為<br>「不要愛上任何投資的標的」<br>「沒有永遠都上漲的商品」</p><p>達成這個條件之前，<br>我是分批慢慢買入，</p><h3 id="買入條件"><a href="#買入條件" class="headerlink" title="買入條件"></a>買入條件</h3><p>直到金額到達自己投資「單項商品的上限」為止<br>不要壓身家，不要壓身家，不要壓身家！</p><p>畢竟這種超長線，最怕的就是買在高點！<br>而很少人可以準確預測未來股價<br>所以平均分攤風險，是比較建議的</p><p>用以上的方法，<br>價格高高低低，<br>心情也會受影響，<br>所以為何不用「量化投資」來幫助我們獲利呢？</p><h2 id="2-量化投資"><a href="#2-量化投資" class="headerlink" title="2. 量化投資"></a>2. 量化投資</h2><p>量化投資<br>也就是利用程式機械式的操作<br>來避免不必要的風險</p><p>例如<a href="/btc-backtesting-optimization/">前一篇文章所介紹的策略</a></p><p>回測跑得好，<br>策略得開始運轉吧？</p><p>但架設server，<br>還是有一定的難度，<br>為了幫助大家做一個簡單的自動化交易系統，</p><p>接下來的文章，<br>首先我們會介紹 <a href="/btc-deposit-ways/">BTC 如何入金</a>，<br>也就是正式開始投資 BTC，</p><p>然後呢，<br>我們會用AWS，也就是Amazon推出的雲端伺服器<br>將<a href="/btc-backtesting-optimization/">前一篇文章所介紹的策略</a>真實上線使用<br>重點是：成本為0，完全免費！<br><a href="/aws-lambda-initial-setup/">詳情請看：雲端建置交易信號</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自從本blog開始介紹 BTC 以來，&lt;br&gt;BTC已經上漲了約25％！&lt;br&gt;我是有稍微選一下發文時機的，&lt;br&gt;很想說自己未卜先知，但世界上沒有這種事情，&lt;br&gt;只能說是個美麗的巧合吧！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/btc-deposit-how/th
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：三年20倍的策略參數最佳化 (Part 7)</title>
    <link href="https://www.finlab.tw/btc-backtesting-optimization/"/>
    <id>https://www.finlab.tw/btc-backtesting-optimization/</id>
    <published>2020-04-26T20:23:13.000Z</published>
    <updated>2020-06-11T17:29:30.813Z</updated>
    
    <content type="html"><![CDATA[<p>這篇文章中，<br>我們將承接著之前的單元，<br>來教大家怎麼做最佳化，</p><center><img src="/btc-backtesting-optimization/thumbnail.jpeg" title="thumbnail"></center><a id="more"></a><p>必備的單元提要：</p><ol><li>環境設定：<a href="/btc-crawler-py/">使用 colab 並且安裝相關 packages</a></li><li>簡單回測：<a href="/btc-simple-sma-backtesting/">利用均線相交產生買賣訊號回測</a></li></ol><p>要執行完上述兩個單元的程式碼<br>才能繼續接下來的單元喔！</p><p>我們將上次的回測程式改成以下的樣子<br>請大家來比較一下有什麼不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> backtesting <span class="keyword">import</span> Backtest</span><br><span class="line"><span class="keyword">from</span> backtesting.lib <span class="keyword">import</span> SignalStrategy</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy</span><span class="params">(SignalStrategy)</span>:</span></span><br><span class="line">    </span><br><span class="line">    n1 = <span class="number">20</span></span><br><span class="line">    n2 = <span class="number">60</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().init()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Precompute the two moving averages</span></span><br><span class="line">        close = pd.Series(self.data.Close)</span><br><span class="line">        sma1 = close.rolling(self.n1).mean()</span><br><span class="line">        sma2 = close.rolling(self.n2).mean()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Precompute signal</span></span><br><span class="line">        signal_long = (sma1 &gt; sma2) &amp; (sma1.shift() &lt; sma2.shift())</span><br><span class="line">        signal_short = (sma1 &lt; sma2) &amp; (sma1.shift() &gt; sma2.shift())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># combine signal</span></span><br><span class="line">        signal = signal_long</span><br><span class="line">        signal[signal_short] = <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># add signal</span></span><br><span class="line">        self.set_signal(signal)</span><br><span class="line"></span><br><span class="line">bt = Backtest(df, Strategy)</span><br><span class="line">result1 = bt.run()</span><br><span class="line">bt.plot()</span><br></pre></td></tr></table></figure><p>沒錯，<br>我們新增了7、8行的物件參數，<br>分別代表兩條均線的參數<br>並且在15、16行，<br>製作均線時，使用該參數來製作均線</p><p>另外我們也在倒數第二行，<br>將回測結果存到 <code>result1</code><br>等等可以做比較</p><p>你應該會看到跟上次一樣的結果：</p><center><img src="/btc-backtesting-optimization/before.png" title="優化前的回測結果"></center><p>接下來就可以自動最佳化了</p><h3 id="暴力枚舉"><a href="#暴力枚舉" class="headerlink" title="暴力枚舉"></a>暴力枚舉</h3><p>你可能以為要寫for迴圈，但其實 backtesting 已經幫你寫好了<br>我們只要將參數範圍傳入 <code>bt.optimize</code><br>就可以了，非常方便：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result2 = bt.optimize(n1=range(<span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>),</span><br><span class="line">                      n2=range(<span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure></p><h3 id="優化後的結果"><a href="#優化後的結果" class="headerlink" title="優化後的結果"></a>優化後的結果</h3><p>由於策略優化完後，參數會自動更新<br>所以我們可以用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bt.plot()</span><br></pre></td></tr></table></figure><br>來看優化後的績效就可以了！</p><center><img src="/btc-backtesting-optimization/after.png" title="優化後的回測結果"></center><p>三年半 20 倍，是不是很夢幻呀！而且還多空都賺<br>拿量化交易的方式交易比特幣，<br>就像是拿大砲對付刀劍一樣</p><p>我們可以將優化前後的績效比對一下，<br>真的差很多呢！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result1._trade_data.Equity.plot()</span><br><span class="line">result2._trade_data.Equity.plot()</span><br></pre></td></tr></table></figure><center><img src="/btc-backtesting-optimization/compare.png" title="比較不同的績效"></center><p>但隨著期貨市場的開放<br>這樣的績效，或許沒辦法重現，<br>或許市場已經慢慢走向效率化，<br>可以看到2019年以後，賺得比較少</p><p>但是加密貨幣又不是只有 BTC，<br>一定有很多未開發的地帶，<br>等著量化交易去開拓的！<br>所以也不用太擔心！</p><p>這些單元的用意<br>就是在你在開江闢土時<br>提供你豐富的資源，<br>讓你在開發策略事半功倍！</p><p>更新：很多人都躍躍欲試呢！<br>我幫大家寫好完整的代碼，可以在線上直接運行喔！<br><a href="https://colab.research.google.com/drive/1ESztR0DvBGQNRml_hpPWMkgXNJ2dmdUa?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">請點此</a></p><p>下個階段，我們就可以來真的<a href="/btc-deposit-how/">入金交易囉</a>！</p><p>你可以到<a href="https://www.facebook.com/finlab.python/" rel="external nofollow noopener noreferrer" target="_blank">FinLab粉專</a><br>點選追蹤，或點讚，就可以收到我們的新單元囉！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這篇文章中，&lt;br&gt;我們將承接著之前的單元，&lt;br&gt;來教大家怎麼做最佳化，&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/btc-backtesting-optimization/thumbnail.jpeg&quot; title=&quot;thumbnail&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：比特幣操作最強指標(看盤篇) (Part 6)</title>
    <link href="https://www.finlab.tw/btc-tradingview-intro/"/>
    <id>https://www.finlab.tw/btc-tradingview-intro/</id>
    <published>2020-04-26T03:44:58.000Z</published>
    <updated>2020-06-11T17:34:33.931Z</updated>
    
    <content type="html"><![CDATA[<p>我們當然可以用 Python 來幫我們做分析<br>但是人都是懶惰的，<br>假如有好用的工具，<br>即使不是 Python 也沒關係</p><p>這篇文章接續前一篇，將來一探究竟<br>究竟這個好用的指標怎麼看</p><center><img src="/btc-tradingview-intro/ind.png" title="thumbnail"></center><h3 id="TradingView"><a href="#TradingView" class="headerlink" title="TradingView"></a>TradingView</h3><p>介紹一款我覺得很好用的平台，<a href="https://tw.tradingview.com/" rel="external nofollow noopener noreferrer" target="_blank">TradingView</a><br>這並不是業配，只是真的滿好用的<br>以加密貨幣來說，我都會用它來看盤</p><p>可以在商品代碼中，輸入「BTCUSDT」來搜尋比特幣的價格</p><center><img src="/btc-tradingview-intro/search.png" title="search"></center><br>並且按一下全功能圖表<br><center><img src="/btc-tradingview-intro/panel.png" title="search"></center><p>這時候就會跳出這檔商品的技術分析圖表<br>然後我們再上方功能列表，可以點選「fx」來添加技術指標</p><center><img src="/btc-tradingview-intro/bar.png" title="bar"></center><br>這些是別人已經寫好<br>並且開源的技術指標<br>可以直接拿來用<br><br># <strong>Hash Ribbons 指標</strong><br><br>接下來，搜尋並點選「Hash Ribbon」就可以看到這個指標了！<br>你應該會看到以下的圖表<br><center><img src="/btc-tradingview-intro/ind.png" title="indicator"></center><p>可以看到「Hash Ribbon」這張圖表中<br>綠色像是階梯狀的數值，就是「Hash rate」<br>也就是「所有的挖礦機」的算力總和<br>也就是每秒可以暴力解多少次<br>可以參考<a href>之前的文章</a><br>瞭解更多原理的部分</p><p>另外有兩條均線，分別是淺綠色，跟灰色，<br>分別是30日和60日均線，<br>這些數字我們不用調整，用它預設的即可</p><p>另外有紅色的區域，<br>從均線的死亡交叉開始出現<br>代表 Miner Capitulation 發生的時刻<br>此時比特幣會進入超跌的狀態，</p><p>最後當紅色區域的末稍，<br>也就是均線黃金交叉時<br>代表礦工恢復運作，<br>通常在這個時候買入<br>近三年的平均來說，會有約5000％的報酬</p><p>當然歷史不代表未來<br>不論部落格提供怎麼樣的訊息<br>你還是得自己做決定</p><p>比特幣波動是非常大的<br>起床發現突然下跌 30％<br>都是可能的</p><p>以長期投資而言，<br>注重風險的讀者，<br>真的不能下注太大呀！</p><p>看完了主觀交易的部分，<br>讓我們回到正題<br><a href="/btc-backtesting-optimization/">來做量化投資吧！</a></p><p>注：<br>另外假如要看 BTC 的長期價格，<br>可以用 tradingview 搜尋 「BLX」<br>就可以找到了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我們當然可以用 Python 來幫我們做分析&lt;br&gt;但是人都是懶惰的，&lt;br&gt;假如有好用的工具，&lt;br&gt;即使不是 Python 也沒關係&lt;/p&gt;
&lt;p&gt;這篇文章接續前一篇，將來一探究竟&lt;br&gt;究竟這個好用的指標怎麼看&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/btc-t
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：比特幣操作最強指標(原理篇) (Part 5)</title>
    <link href="https://www.finlab.tw/best-indicator-bitcoin/"/>
    <id>https://www.finlab.tw/best-indicator-bitcoin/</id>
    <published>2020-04-25T07:36:15.000Z</published>
    <updated>2020-06-10T01:47:15.733Z</updated>
    
    <content type="html"><![CDATA[<p>這是臨時加開的一篇文章<br>主要是因為<br><strong>就在今天</strong><br>有個非常準的比特幣上漲指標<br>發生了罕見的重磅訊號！</p><center><img src="/best-indicator-bitcoin/thumbnail.jpeg" title="thumbnail"></center><p>近三年，只要這個指標產生買入訊號，<br>平均來說，<strong>比特幣上漲幅度為 5000％</strong></p><p>這個指標的原理是什麼呢？<br>首先我們要介紹幾個名詞：</p><h3 id="1-Miner-挖礦機"><a href="#1-Miner-挖礦機" class="headerlink" title="1. Miner 挖礦機"></a>1. Miner 挖礦機</h3><p>比特幣的運作機制，<br>是讓所有的電腦互相競爭，看誰最快產生一串隨機字串 s，<br>使得以下公式<br><code>hash = sha256(phash + leger + s)</code><br>中 hash 的開頭「 n 個 0 」，</p><p>其中 <code>phash</code> 就是前一個 block（區塊）的 hash<br><code>leger</code> 是待驗證的 BTC 交易帳本，<br><code>sha256</code> 是一個<strong>不可逆的加密函數</strong></p><p>不可逆函數意味著<br>我們不可能反推s是多少，<br>而是必需要用暴力法，硬猜 s 是多少，<br>一個個嘗試，直到成功為止</p><p>專門在嘗試暴力法枚舉的電腦，我們就稱為「挖礦機」</p><h3 id="2-為何要找-s-？-感覺很沒意義"><a href="#2-為何要找-s-？-感覺很沒意義" class="headerlink" title="2. 為何要找 s ？ 感覺很沒意義"></a>2. 為何要找 s ？ 感覺很沒意義</h3><p>因為這樣子，我們就可以驗證此帳本是真的<br>這種驗證機智叫做 <strong>proof-of-work</strong><br>也就是用電腦的勞力<br>來確保紀錄的資料不受串改，</p><p>舉個例子，假如今天某駭客想上傳一個假的block，<br>這個時候，他必須先解出 上述 <code>s</code> 是多少，<br>還必須將下一個block的 <code>s</code> 也算出來，<br>和下下個 block 的 <code>s</code><br>和下下下個 block 的 <code>s</code><br>…等<br>直到其他電腦承認他的那條「假區塊鏈」為止，</p><p>也就是這個駭客的電腦算力，<br>必須跟其他正規礦機的算力總和披敵，<br>並且持續非常長的一段時間都能戰勝<strong>正規礦機的總和</strong><br>才有辦法將假的block驗證成功，</p><h3 id="3-Miner-Capitulation-礦機的投降"><a href="#3-Miner-Capitulation-礦機的投降" class="headerlink" title="3. Miner Capitulation 礦機的投降"></a>3. Miner Capitulation 礦機的投降</h3><p>為什麼會有人想挖礦？<br>因為辛苦挖礦<br>可以獲得新發行的比特幣</p><p>但當今天比特幣價格下降，<br>導致挖礦獲利減少時，<br>礦工挖礦成本 大於 挖到的比特幣價值<br>有些礦工乾脆就不運轉，<br>或是賣掉BTC去添購新的挖礦機型<br>也就是 Miner Capitulation</p><h3 id="4-Miner-Capitulation-是好的買入機會"><a href="#4-Miner-Capitulation-是好的買入機會" class="headerlink" title="4. Miner Capitulation 是好的買入機會"></a>4. Miner Capitulation 是好的買入機會</h3><p>Miner Capitulation<br>通常發生在 BTC 價格下跌時<br>BTC 的價格跌破了挖礦成本開始</p><p>很多的礦機持有者，<br>在這個時候</p><ol><li>賣掉已經挖到的 BTC 來購買新的礦機</li><li>乾脆機器收一收，BTC賣一賣了結出場</li></ol><p>就會引發一系列超賣</p><h3 id="5-如何判斷-Miner-Capitulation？"><a href="#5-如何判斷-Miner-Capitulation？" class="headerlink" title="5. 如何判斷 Miner Capitulation？"></a>5. 如何判斷 Miner Capitulation？</h3><p>我們可以從BTC調整「挖礦的困難程度」<br>來當成 Miner Capitulation 的延遲指標</p><p>因為這個「挖礦難易程度」會動態調整的：<br>根據比特幣白皮書<br>一個 block 的出產時間<br>必須在約10分鐘左右</p><p>所以當礦機很多時，算力上升，<br>這樣用暴力法找 <code>s</code> 的速度就會變快<br>所以找 <code>s</code> 難度也必須提升才行</p><p>還記得 hash 開頭必須包含 n 個 0 嗎？<br>這個 n 就可以用來控制難度，<br>當 n 越大，代表要產生越多開頭為 0 的 hash<br>而難度也會跟著加大</p><h3 id="6-我們可以藉由-n-來推算-hash-rate"><a href="#6-我們可以藉由-n-來推算-hash-rate" class="headerlink" title="6. 我們可以藉由 n 來推算 hash rate"></a>6. 我們可以藉由 n 來推算 hash rate</h3><p>hash rate 就是比特幣網路的算力，<br>每秒可以暴力解 x 次<br>這個 hash rate 降低，也代表著礦工的退出，<br>礦工退出，就會將 BTC 兌現<br>BTC 就會有比較大的跌幅</p><p>而當 hash rate 反轉升高時<br>就代表礦機更新完畢、礦場被整併，新礦機上線<br>近三年，這樣子的狀況，比特幣都有不錯的報酬<br>如今這個訊號也發生了，<br>就不知道接下來歷史會不會重演呢？</p><p>下一集將分享怎麼用 trading view 來開啟<br>hash  rate 訊號買賣點！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這是臨時加開的一篇文章&lt;br&gt;主要是因為&lt;br&gt;&lt;strong&gt;就在今天&lt;/strong&gt;&lt;br&gt;有個非常準的比特幣上漲指標&lt;br&gt;發生了罕見的重磅訊號！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/best-indicator-bitcoin/thumbnail.jpe
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：實做回測策略 (Part 4)</title>
    <link href="https://www.finlab.tw/btc-simple-sma-backtesting/"/>
    <id>https://www.finlab.tw/btc-simple-sma-backtesting/</id>
    <published>2020-04-25T00:54:09.000Z</published>
    <updated>2020-06-11T17:31:58.107Z</updated>
    
    <content type="html"><![CDATA[<p>接下來我們廢話不多說，<br>結合前一篇的買賣訊號<br>來建構一個加密貨幣的策略吧！</p><center><img src="/btc-simple-sma-backtesting/thumbnail.jpeg" title="info"></center><h3 id="複習前幾篇的知識"><a href="#複習前幾篇的知識" class="headerlink" title="複習前幾篇的知識"></a>複習前幾篇的知識</h3><p>這篇文章，將接續著之前的單元，<br>假如還沒看過前面的部分<br>可以參考以下的連結喔！</p><ol><li><a href="/python-bitcoin-trading-why-bitcoin/">為什麼要投資加密貨幣</a></li><li><a href="/btc-crawler-py/">加密貨幣爬蟲</a></li><li><a href="/btc-trading-signal/">策略訊號建立</a></li></ol><p>這篇我寫的比較仔細一點，所以文章稍長，但程式碼很短，先給大家聞香一下</p><center><img src="/btc-simple-sma-backtesting/result.png" title="回測結果統計"></center><br>想知道怎麼做出來，要看到最後喔！<br><br>將上一篇的程式碼統整，我們可以得到<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal_long = (sma1 &gt; sma2) &amp; (sma1.shift() &lt; sma2.shift())</span><br><span class="line">signal_short = (sma1 &lt; sma2) &amp; (sma1.shift() &gt; sma2.shift())</span><br></pre></td></tr></table></figure><br><br>接下來，我們將 <code>signal_long</code> 跟 <code>signal_short</code> 整合在一起<br>這邊的 <code>signal_long</code> 跟 <code>signal_short</code><br>是進場訊號，一個做多、一個是做空 的時間序列<br>當訊號為 True 時代表入場<br><br><strong> 多空訊號結合 </strong><br><br>接下來為了配合 backtesting 函式庫<br>我們想將 <code>signal_long</code> 跟 <code>signal_short</code> 合併起來<br>產生一個翻轉策略：<br>當 <code>signal_long</code> 為 True 時，不論目前有什麼部位，都翻多<br>當 <code>signal_short</code> 為 True 時，不論目前什麼部位，一律翻空<br>我們想要做出一個新的訊號 叫做 <code>signal</code><br>其做多訊號為 1，做空訊號為 -1 ，維持不變則為0<br><br>可以用以下的寫法，首先copy <code>signal_long</code> 序列，<br>並且將 <code>signal_short</code> 為 True 的部分改成 <code>-1</code><br>這樣就可以了！<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># combine long and short signal</span></span><br><span class="line">signal = signal_long.copy()</span><br><span class="line">signal[signal_short] = <span class="number">-1</span></span><br></pre></td></tr></table></figure><br><br><center><img src="/btc-simple-sma-backtesting/signal.png" title="交易訊號"></center><p>完整總和來說，我們目前已經有以下的程式碼，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> finlab <span class="keyword">import</span> crypto</span><br><span class="line"></span><br><span class="line"><span class="comment"># geth the historical price</span></span><br><span class="line">df = crypto.get_all_binance(<span class="string">'BTCUSDT'</span>, <span class="string">'4h'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate moving averages</span></span><br><span class="line">sma1 = df.Close.rolling(<span class="number">20</span>).mean()</span><br><span class="line">sma2 = df.Close.rolling(<span class="number">60</span>).mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># create long and short signal</span></span><br><span class="line">signal_long = (sma1 &gt; sma2) &amp; (sma1.shift() &lt; sma2.shift())</span><br><span class="line">signal_short = (sma1 &lt; sma2) &amp; (sma1.shift() &gt; sma2.shift())</span><br><span class="line"></span><br><span class="line"><span class="comment"># combine long and short signal</span></span><br><span class="line">signal = signal_long.copy()</span><br><span class="line">signal[signal_short] = <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>接下來我們直接比對一下，回測的程式碼，<br>橘色部分比較特別，會逐一介紹</p><center><img src="/btc-simple-sma-backtesting/code.png" title="程式碼的部分"></center><br>(先不急著抄寫，文末會附上完整代碼)<br><br>首先，上圖中第一二行，我們將 Backtest 和 SignalStrategy 匯入<br>Backtest 是一個幫我們回測的 interface，<br>而 <code>SignalStrategy</code> 是一個 class<br>我們可以繼承 <code>SignalStrategy</code> (第5行)<br>就能把剛剛的訊號 <code>signal</code> 匯入來回測<br>這邊會用到物件導向的概念，可以參考<br><a href="https://www.w3schools.com/python/python_classes.asp" rel="external nofollow noopener noreferrer" target="_blank">w3c提供的簡單 python 物件導向教學</a><br><br>有了一個strategy空殼，接下來就可以實做內部功能了<br><br>第7行中，我們覆寫一個parent 方法，叫做 <code>init</code>，<br>在 <code>init</code> 這個方法中，我們可以計算回測要用的訊號<br>這個方法會在<strong>回測開始前執行一次</strong><br>所以當我們先把訊號計算好<br>這樣回測的時候就不用計算，速度上會比較快<br><br><code>init</code>中大部分的程式碼，<br>跟我們開頭所述的非常雷同，<br>有幾點不一樣而已：<br><br>首先，在第8行中<br>parent class 會先執行他的 <code>init</code><br>你可以想像，父母先吃飯，小孩再吃飯的道理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super().init()</span><br></pre></td></tr></table></figure><br><br>然後，第11行，也做了一點修正，從原本的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原本的</span></span><br><span class="line">df = crypto.get_all_binance(<span class="string">'BTCUSDT'</span>, <span class="string">'4h'</span>)</span><br></pre></td></tr></table></figure><br>變成<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新的</span></span><br><span class="line">close = pd.Series(self.data.Close)</span><br></pre></td></tr></table></figure><br><br>我們可以用 <code>self.data.Close</code> 來獲取「開高低收」的歷史價格<br>這是繼承 <code>SignalStrategy</code> 附加的功能<br>可以讓程式碼中的「策略」跟「價格」解耦<br>讓策略不只交易 <code>BTCUSDT</code><br>還能交易其他加密貨幣，甚至是股票！<br><br>最後12～21行，都跟之前一樣，所以就略過囉！<br><br>最後的24行，就是將我們產生的 <code>signal</code> 給匯入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elf.set_signal(signal)</span><br></pre></td></tr></table></figure><br>這樣子 <code>SignalStrategy</code> 裡面就會根據 <code>signal</code><br>來進行翻多翻空的交易囉！<br><br>上述 1～26 行，都是一個策略藍圖，我們只是規劃，並沒有真正執行這些程式碼<br>所以我們還要額外家三行，建構出規劃好的策略，並且回測、統計回測結果：<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bt = Backtest(df, Strategy)</span><br><span class="line">bt.run()</span><br><span class="line">bt.plot()</span><br></pre></td></tr></table></figure><br><br><center><img src="/btc-simple-sma-backtesting/result.png" title="回測結果統計"></center><p>執行後會顯示出非常詳細的買賣點，<br>這個就是所謂 <del>窮人版</del> python 版的 multicharts 了吧！<br>不過看起來策略的 <code>performnace</code> 不太好，賺不到什麼 $$<br>所以下一個單元，我們就來使用內建的 optimize 方法，<br>找尋最優的均線交叉策略！優化後的績效，先給大家聞香一下</p><center><img src="/btc-simple-sma-backtesting/opt.png" title="回測結果統計優化後"></center><p><a href="/btc-backtesting-optimization/">點我進入下一個單元：策略優化</a></p><p>以下是完整的程式碼：<br>另外也可以參考完整的 <a href="https://colab.research.google.com/drive/1ZUst2gJfBSxrdhw2aBdr_OJn6uMdDabi" rel="external nofollow noopener noreferrer" target="_blank">colab notebook 範例</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> finlab <span class="keyword">import</span> crypto</span><br><span class="line"><span class="keyword">from</span> backtesting <span class="keyword">import</span> Backtest</span><br><span class="line"><span class="keyword">from</span> backtesting.lib <span class="keyword">import</span> SignalStrategy</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = crypto.get_all_binance(<span class="string">'BTCUSDT'</span>, <span class="string">'4h'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy</span><span class="params">(SignalStrategy)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().init()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Precompute the two moving averages</span></span><br><span class="line">        close = pd.Series(self.data.Close)</span><br><span class="line">        sma1 = close.rolling(<span class="number">20</span>).mean()</span><br><span class="line">        sma2 = close.rolling(<span class="number">60</span>).mean()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Precompute signal</span></span><br><span class="line">        signal_long = (sma1 &gt; sma2) &amp; (sma1.shift() &lt; sma2.shift())</span><br><span class="line">        signal_short = (sma1 &lt; sma2) &amp; (sma1.shift() &gt; sma2.shift())</span><br><span class="line">        </span><br><span class="line">        signal = signal_long</span><br><span class="line">        signal[signal_short] = <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        self.set_signal(signal)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().next()</span><br><span class="line"></span><br><span class="line">bt = Backtest(df, Strategy)</span><br><span class="line">bt.run()</span><br><span class="line">bt.plot()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接下來我們廢話不多說，&lt;br&gt;結合前一篇的買賣訊號&lt;br&gt;來建構一個加密貨幣的策略吧！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/btc-simple-sma-backtesting/thumbnail.jpeg&quot; title=&quot;info&quot;&gt;&lt;/center&gt;

&lt;h3
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：交易策略訊號實做 (Part 3)</title>
    <link href="https://www.finlab.tw/btc-trading-signal/"/>
    <id>https://www.finlab.tw/btc-trading-signal/</id>
    <published>2020-04-23T20:20:56.000Z</published>
    <updated>2020-06-11T17:35:12.040Z</updated>
    
    <content type="html"><![CDATA[<p>這篇文章中，我們將用 pandas 來做一個簡易的交易訊號，</p><p>Pandas 是一個資料處理用的 Package<br>專門用來做資料處理，<br>你可以想像它是 python 裡面的 excel，<br>可以產生並且處理各式各樣的表格</p><h3 id="Pandas-操作介紹"><a href="#Pandas-操作介紹" class="headerlink" title="Pandas 操作介紹"></a>Pandas 操作介紹</h3><p>承接著<a href="/btc-crawler-py/">上一篇文章</a>，<br>我們繼續在 <a href="https://colab.research.google.com/" rel="external nofollow noopener noreferrer" target="_blank">google colab</a> 上進行程式的實驗<br>此時的 <code>df</code> 已經是歷史資料</p><center><img src="/btc-trading-signal/df.png" title="dataframe"></center><p>就是一個 <code>pandas.DataFrame</code> 物件<br>這個物件就像是 excel 表格一樣<br>有很多的行跟列</p><p>每一個列都可以簡單的呼叫出來，<br>以我們的例子，每一列都是一個時間序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.Close</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/series.png" title="時間序列"></center><p>由上圖可知，每一列也是一種物件<br>叫做 <code>pd.Series</code>，<br>這種物件，就是一條序列，<br>可以想像是excel的單一一列的意思</p><h3 id="製作簡易的均線策略"><a href="#製作簡易的均線策略" class="headerlink" title="製作簡易的均線策略"></a>製作簡易的均線策略</h3><p><code>pd.Series</code>有很多特別的功能<br>例如計算移動窗格，我們可以用<br><code>pd.Series.rolling()</code><br>來產生移動窗格，並且用<br><code>pd.Series.rolling().mean()</code><br>來產生這個移動窗格的平均數<br>從時間序列的角度<br>這個就是「均線」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sma1 = df.Close.rolling(<span class="number">20</span>).mean()</span><br><span class="line">sma2 = df.Close.rolling(<span class="number">60</span>).mean()</span><br><span class="line"></span><br><span class="line">df.Close.plot()</span><br><span class="line">sma1.plot()</span><br><span class="line">sma2.plot()</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/sma_plot.png" title="SMA"></center><p>上圖中，我們將<code>BTCUSDT</code>的歷史紀錄 與兩條均線畫出來<br>會發現，時間跨度太大，導致價格跟均線看不清楚，<br>我們可以額外 zoom in 選取「某年」來觀察，<br>可以使用中括號來選取時間範圍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.Close[<span class="string">'2020'</span>].plot()</span><br><span class="line">sma1[<span class="string">'2020'</span>].plot()</span><br><span class="line">sma2[<span class="string">'2020'</span>].plot()</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/sma_plot2019.png" title="2019SMA"></center><p>接下來，我們來設計交易訊號<br>我們希望做一個簡單的均線策略：</p><p>假如短週期均線 <code>sma1</code> 超過 長週期 <code>sma2</code> -&gt; 做多<br>反之做空</p><p>要怎麼做出這樣的訊號呢？我們可以用不等式來進行，</p><h3 id="不等式條件"><a href="#不等式條件" class="headerlink" title="不等式條件"></a>不等式條件</h3><p>不等式，就是所謂的「大於等於小於」，<br>我們假如將兩條時間序列做不等式運算，</p><p>在這兩條時間序列中，每一個元素會被一一拿出來比對，<br>並且產生出新的「布林」時間序列：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">condition = sma1 &gt; sma2</span><br><span class="line">condition</span><br></pre></td></tr></table></figure></p><center><img src="/btc-trading-signal/condition.png" title="布林序列"></center><p>上圖中就是布林時間序列，每個時間點對映到「Ture」或是「False」<br>假如今天條件成立，也就是「sma1 &gt; sma2」的話<br>該時間點對映到的就會是 True<br>反之則是 False</p><p>因為我們是均線突破策略，<br>要怎麼結合不等式，來產生均線突破條件呢？我們還需要<br><code>pd.Series.shift</code><br>這個功能</p><h3 id="調用「昨天」的價格-pd-Series-shift"><a href="#調用「昨天」的價格-pd-Series-shift" class="headerlink" title="調用「昨天」的價格 pd.Series.shift"></a>調用「昨天」的價格 pd.Series.shift</h3><p><code>pd.Series.shift</code>是一個好用的function，<br>可以將時間序列全部都往後延遲一天，例如以下的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(df.Close)</span><br><span class="line">print(df.Close.shift(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/shift.png" title="shift範例"></center><p>你會發現兩者相差一天，<br>所以在做策略時，我會傾向於，將<code>pd.Series.shift(n)</code><br>當作是「n個時間單位前的價格」，<br>這邊我們用的是 ‘4h’ 4小時的歷史價格<br>所以<br><code>pd.Series.shift(1)</code><br>就是4小時前，<br>而<br><code>pd.Series.shift(2)</code><br>就是8小時前<br>以此類推</p><p>假如我們只使用<br><code>pd.Series.shift()</code><br>n 不設定參數的話<br>pandas 會預設 <code>n=1</code> 喔！</p><h3 id="結合上述的範例，產生策略訊號"><a href="#結合上述的範例，產生策略訊號" class="headerlink" title="結合上述的範例，產生策略訊號"></a>結合上述的範例，產生策略訊號</h3><p>我們希望的做出來的邏輯：<br>做多: 當(今天短週期均線 &gt; 今天長週期均線) 且 (昨天短週期均線 &lt; 昨天長週期均線)<br>做空: 當(今天短週期均線 &lt; 今天長週期均線) 且 (昨天短週期均線 &gt; 昨天長週期均線)</p><p>我們可以將上述中文，對映到以下的程式碼：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal_long = (sma1 &gt; sma2) &amp; (sma1.shift() &lt; sma2.shift())</span><br><span class="line">signal_short = (sma1 &lt; sma2) &amp; (sma1.shift() &gt; sma2.shift())</span><br></pre></td></tr></table></figure></p><p>上述程式碼中的 <code>&amp;</code> 就是「且」的意思</p><p>我們可以將訊號繪製出來：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal_long.astype(int).plot()</span><br><span class="line">(-signal_short.astype(int)).plot()</span><br></pre></td></tr></table></figure></p><center><img src="/btc-trading-signal/signal.png" title="交易訊號"></center><p>以上這張圖我用 -1 顯示 賣出訊號，而 1 是買進訊號<br>當我們將 True False 轉換成 int 時，<br>會轉換成「1」跟「0」的數值</p><h3 id="製作策略"><a href="#製作策略" class="headerlink" title="製作策略"></a>製作策略</h3><p>然而我們怎麼知道<br>照著這個交易訊號操作<br>實際的績效是怎麼樣呢？<br><a href="/btc-simple-sma-backtesting/">下一個單元中：回測</a>，會教大家怎麼用 <a href="https://github.com/kernc/backtesting.py" rel="external nofollow noopener noreferrer" target="_blank">backtesting</a> 這個 package<br>來實做回測，<br>模擬這個策略的績效<br>敬請期待！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這篇文章中，我們將用 pandas 來做一個簡易的交易訊號，&lt;/p&gt;
&lt;p&gt;Pandas 是一個資料處理用的 Package&lt;br&gt;專門用來做資料處理，&lt;br&gt;你可以想像它是 python 裡面的 excel，&lt;br&gt;可以產生並且處理各式各樣的表格&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：爬蟲下載歷史數據 (Part 2)</title>
    <link href="https://www.finlab.tw/btc-crawler-py/"/>
    <id>https://www.finlab.tw/btc-crawler-py/</id>
    <published>2020-04-22T20:42:33.000Z</published>
    <updated>2020-06-11T17:32:45.873Z</updated>
    
    <content type="html"><![CDATA[<p>這個單元，<br>分享如何獲取比特幣歷史價格</p><p>可以打開<a href="https://colab.research.google.com/" rel="external nofollow noopener noreferrer" target="_blank">colab</a>線上編輯python跟我們一起做實驗吧！<br>colab 是 google 提供，線上運行 python 的平台<br>打開後，新增一個notebook<br>直接一步步貼上下面的代碼<br>程式就會順利運行了</p><center><img src="/btc-crawler-py/thumbnail.png" title="info"></center><h3 id="獲取-python-函式庫"><a href="#獲取-python-函式庫" class="headerlink" title="獲取 python 函式庫"></a>獲取 python 函式庫</h3><p>首先，我們要先獲取幫大家寫好的 package 可以到github上下載<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!git clone https://github.com/koreal6803/crypto_backtrader.git</span><br><span class="line">%cd crypto_backtrader</span><br></pre></td></tr></table></figure></p><p>上面的指令，會先將預先寫好的程式從 github 上下載下來<br>並且將目錄切換到 crypto_backtrader<br>也就是下載下來的資料夾中</p><h3 id="安裝一些必要的packages"><a href="#安裝一些必要的packages" class="headerlink" title="安裝一些必要的packages"></a>安裝一些必要的packages</h3><p>接下來我們來安裝一些必要的 dependencies<br>這樣等會才能順利執行程式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!pip install python-binance</span><br><span class="line">!pip install bitmex</span><br><span class="line">!pip install Backtesting</span><br><span class="line">!pip install backtrader</span><br></pre></td></tr></table></figure><h3 id="加密貨幣命名方法"><a href="#加密貨幣命名方法" class="headerlink" title="加密貨幣命名方法"></a>加密貨幣命名方法</h3><p>這篇文章中，我們爬取 <code>BTCUSDT</code> 的價格<br><code>BTCUSDT</code> 這個 symbol 可以拆逞兩個部分<br>一個是 <code>BTC</code>、另一個是 <code>USDT</code><br><code>BTCUSDT</code> 代表，<code>BTC</code> 的價格，以 <code>USDT</code> 為單位，<br>這邊為什麼我們要用 <code>USDT</code> 呢？因為他是跟 <code>USD</code> 是美元是表兄弟，<br><code>USDT</code> 是一種跟 <code>USD</code> 約略 1:1 兌換的穩定虛擬貨幣<br><code>USDT</code> 的好處是</p><p>在交易時，假如用 加密貨幣 和 法定貨幣（美元）來回交易<br>這種方式交易，手續費會非常高昂<br>例如我們以 Maicoin 買入跟賣出手續費約高達 1%，</p><p>今天我們假如使用 <code>BTCUSDT</code> pair 來交易<br>由於同樣是加密貨幣，所以手續費算是大幅的降低，<br>目前手續費在各平台，一般的標準是0.1%，根據平台的優惠、交易量可以打折，<br>成本算是低很多，</p><p><a href="http://blog.udn.com/mashmoro980727/121661372" rel="external nofollow noopener noreferrer" target="_blank">交易對(trading pair)的相關介紹</a></p><p>那廢話不多說，趕快來下載歷史資料吧！</p><h3 id="使用幫大家寫好的函式庫"><a href="#使用幫大家寫好的函式庫" class="headerlink" title="使用幫大家寫好的函式庫"></a>使用幫大家寫好的函式庫</h3><p>我們可以使用<br><code>from finlab import crypto</code><br>將一些好用的 function 給叫進來</p><p>然後用<br><code>crypto.get_all_binance</code> 這個 function<br>來獲取交易對(trading pair)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from finlab import crypto</span><br><span class="line">df = crypto.get_all_binance(&apos;BTCUSDT&apos;, &apos;4h&apos;)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><center><img src="/btc-crawler-py/df.png" title="dataframe 結果"></center><p>上述這個 <code>get_all_binance</code><br>除了幫你整理好下載資料外，<br>還會將這些資料資料，存在 <code>crypto_backtrader/history/crypto/</code> 當中<br>以 <code>csv</code> 的方式存起來<br>方便你用 <code>excel</code>、<code>multicharts</code> 等程式來打開</p><p>你也可以輸入不同的 trading pair 名稱，可以<a href="https://www.binance.com/tw/markets" rel="external nofollow noopener noreferrer" target="_blank">binance官網</a>查找</p><p>下一步，我們會分享<br>怎麼用 <a href="/btc-simple-sma-backtesting/">Python 回測一個簡單的交易策略</a>！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這個單元，&lt;br&gt;分享如何獲取比特幣歷史價格&lt;/p&gt;
&lt;p&gt;可以打開&lt;a href=&quot;https://colab.research.google.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣：為什麼是比特幣？ (Part 1)</title>
    <link href="https://www.finlab.tw/python-bitcoin-trading-why-bitcoin/"/>
    <id>https://www.finlab.tw/python-bitcoin-trading-why-bitcoin/</id>
    <published>2020-04-20T06:09:14.000Z</published>
    <updated>2020-06-10T02:56:42.378Z</updated>
    
    <content type="html"><![CDATA[<p>原本想說開一個課程<br>介紹加密貨幣做portfolio selection<br>不過因為種種因素<br>決定還是寫成免費一系列的文章<br>介紹用 Python 建置 比特幣 交易系統</p><p>新科技<br>如 machine learning、blockchain，<br>或許可以說「有缺點」、「不成熟」、「尚未完善」<br>但同時也是<strong>充滿機會</strong>的地方！<br>不論這是投資還是投機<br>我都會想要試試看<br>這可以說是<br>我對於<strong>程式和科技的執著</strong>吧！</p><p>我想研究比特幣 可以分成三個原因：</p><h3 id="1-隨著時間推移"><a href="#1-隨著時間推移" class="headerlink" title="1. 隨著時間推移"></a>1. 隨著時間推移</h3><h3 id="科技的進步是很可怕的！"><a href="#科技的進步是很可怕的！" class="headerlink" title="科技的進步是很可怕的！"></a>科技的進步是很可怕的！</h3><p>你絕對沒辦法想像<br>30年前，大家對個人電腦嗤之以鼻：<br>「翻書1秒鐘，開機卻要3分鐘！」<br>「書 比 電腦 要方便太多了！」<br>「沒有理由大家需要電腦呀！」</p><p>今天，每個人口袋都有一台…</p><p><strong>加密貨幣，會不會就是30年前的筆電呢？</strong><br>可能會，可能不會，</p><p>不過可以當作是買保險，因為</p><h3 id="2-我們生活在安逸的年代"><a href="#2-我們生活在安逸的年代" class="headerlink" title="2. 我們生活在安逸的年代"></a>2. 我們生活在安逸的年代</h3><h3 id="居安思危是很重要的"><a href="#居安思危是很重要的" class="headerlink" title="居安思危是很重要的"></a>居安思危是很重要的</h3><p>人類的歷史，充滿戰爭，<br>很多人因此顛沛流離，<br>這80年以來，是世界上最和平的一段日子，<br>究竟是人類越來越文明？<br>還是說世界的動盪 就像是經濟一樣會循環，<br>我們剛好處在和平的週期？</p><p>設想你最糟糕的狀況：<br>房子被強制徵收、國家貨幣大幅貶值、<br>臨時離開住所，輕裝逃往其他國家，</p><p>要是這些事情都發生了，<br>你可以什麼都沒有 什麼都不帶<br><strong>只要腦海中有比特幣的公鑰私鑰(帳號密碼)，</strong><br><strong>一切都能卷土重來</strong></p><p>一百年後 國家會興亡 貨幣會貶值<br>但不論如何 只要人類文明尚在<br>比特幣也會一直存在</p><h3 id="3-比特幣的特性"><a href="#3-比特幣的特性" class="headerlink" title="3. 比特幣的特性"></a>3. 比特幣的特性</h3><p>可以舉貨幣的四種特徵<br>「易於辨識」、「易於分割且品質一致」、「易於儲存運送」、「普遍接受性」</p><h4 id="易於辨識"><a href="#易於辨識" class="headerlink" title="易於辨識"></a>易於辨識</h4><p>做偽鈔用於便利商店很難<br>但破解人類最先進的密碼學 更難</p><h4 id="易於分割且品質一致"><a href="#易於分割且品質一致" class="headerlink" title="易於分割且品質一致"></a>易於分割且品質一致</h4><p>比特幣支援「億」分之一</p><h4 id="易於儲存運送"><a href="#易於儲存運送" class="headerlink" title="易於儲存運送"></a>易於儲存運送</h4><p>只要有公私鑰在腦中，世界上任何地方都能使用，<br>轉帳費用非常低廉</p><h4 id="普遍接受性"><a href="#普遍接受性" class="headerlink" title="普遍接受性"></a>普遍接受性</h4><p>比特幣最為人詬病的點<br>就是大家認為 法定貨幣、黃金的特性已經足夠<br>加密貨幣只是多此一舉</p><p>另外，因為比特幣難監管，<br>導致各國剛開始時非常排斥<br>（但最近變成是愛恨交織就是了XD）<br>加密貨幣存在的意義<br>就是要等時間來慢慢證明了</p><h3 id="究竟時間要等多久？"><a href="#究竟時間要等多久？" class="headerlink" title="究竟時間要等多久？"></a>究竟時間要等多久？</h3><p>我粗淺認為<br>從微觀的角度 比特幣是可以被取代的<br>但是從鴻觀的角度 也就是100年為跨度<br>考慮了國家的興亡 和世界的動盪<br>它的價值會慢慢被體現<br>這邊的價值 比較著重在<br>應用於日常生活的價值！</p><p>在或近或遠的未來<br>比特幣應該存在著某種地位</p><p>以這樣的角度思考<br>則目前市值約為黃金的 1/50 倍<br>有點太低了</p><p>所以以個人濁見 是有一些投資的機會的<br>但投資跟投機往往一線之間<br>當前比特幣的波動非常大！<br>持有時加密貨幣一定要</p><ol><li>少部位</li><li>用量化分析降低風險</li></ol><p>要怎麼知道資金要投入多少呢？<br>簡單的方式：想像，你「單一天」可以承受最大虧損？</p><p>差不多就投資這麼多吧XDD<br>因為比特幣下跌個70％ 80％都是有發生過的！</p><p>接下來就來建置 Python 交易系統<br>讓我們投資的風險 可防可控！</p><p>歡迎追蹤<a href="https://www.facebook.com/finlab.python/" rel="external nofollow noopener noreferrer" target="_blank">粉專</a><br>來訂閱最新的教學分享喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原本想說開一個課程&lt;br&gt;介紹加密貨幣做portfolio selection&lt;br&gt;不過因為種種因素&lt;br&gt;決定還是寫成免費一系列的文章&lt;br&gt;介紹用 Python 建置 比特幣 交易系統&lt;/p&gt;
&lt;p&gt;新科技&lt;br&gt;如 machine learning、blockcha
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>台北最抗跌公寓在哪？ Python 告訴你 (Part 3)</title>
    <link href="https://www.finlab.tw/real-state-best-district-old-buildings-taipei/"/>
    <id>https://www.finlab.tw/real-state-best-district-old-buildings-taipei/</id>
    <published>2019-11-28T07:24:28.000Z</published>
    <updated>2020-06-05T07:29:51.984Z</updated>
    
    <content type="html"><![CDATA[<p>文末告訴你買哪裡？多少年齡的公寓？比較好<br>（結果滿出乎意料）</p><center><img src="/real-state-best-district-old-buildings-taipei/thumbnail.png" title="投資房產"></center><p>根據專家的說法，<br>由於人口老化的關係，<br>房價未來比較悲觀，<br>假如我們要自住買房怎麼辦？</p><p>有一個家的好處是<br>畢竟每個人生活習慣不同<br>要客制化專屬的生活空間<br>只有擁有房子才辦得到</p><p>但是，房子保值的年代已經過去了<br>幾年前台北的房價被炒的很高<br>有些地方明顯就是太貴了<br>這幾年慢慢的顯現出來</p><p>假如你因為工作需求，<br>需要再台北買一個自己的家<br>要買在哪裡比較保值？<br>對，保值而已，不求上漲，<br>只求不要跌太多</p><p>打開實價登錄，<br>不論是<a href="https://price.houseprice.tw/" rel="external nofollow noopener noreferrer" target="_blank">實價網</a>、<a href="https://www.rakuya.com.tw/realprice/result" rel="external nofollow noopener noreferrer" target="_blank">樂屋網</a>、或其他的網站<br>在功能上，都有很多進步的空間！</p><p>原因在於這些網站，都只提供進幾年的數據，<br>而且無法統計以及繪圖功能，<br>大部分都只提供近一兩年的比較，<br>但一般人自住買房，關心的是10年後的房價，<br>而不只是短期的上漲下跌，</p><p>所以只好來用 Python 做一點功課了</p><p>首先，我們根據之前的介紹，我們可以</p><ul><li><a href="/real-estate-analysis1/">爬到實價登錄歷史資料</a></li><li><a href="/real-estate-analasys-histograms/">將資料整理成 dataframe</a><br>可以先進行以上兩個步驟，然後就可以接著來寫 code 囉！</li></ul><p>這次的主題是「公寓」<br>我們假設某個人想買台北的房子<br>但是由於金錢考量，只能選擇公寓，</p><p>「究竟要怎麼選呢？」</p><h3 id="1-用區域來選"><a href="#1-用區域來選" class="headerlink" title="1. 用區域來選"></a>1. 用區域來選</h3><p>首先我們想要算出，台北市「公寓」的歷史走勢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># plt.rcParams['font.sans-serif'] = ['Noto Sans TC Regular'] # 有支援中文的字體</span></span><br><span class="line"><span class="comment"># plt.rcParams['axes.unicode_minus']=False</span></span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> dis <span class="keyword">in</span> set(df[<span class="string">'鄉鎮市區'</span>]):</span><br><span class="line"></span><br><span class="line">    condition1 = df[<span class="string">'土地區段位置/建物區段門牌'</span>].notna()</span><br><span class="line">    condition2 = df[<span class="string">'建物型態'</span>] == <span class="string">'公寓(5樓含以下無電梯)'</span></span><br><span class="line">    condition3 = (df[<span class="string">'鄉鎮市區'</span>] == dis)</span><br><span class="line">    </span><br><span class="line">    df_local = df[condition3 &amp; condition2]</span><br><span class="line">    result[dis] = df_local[<span class="string">'單價元坪'</span>].groupby(df_local.index.year).mean()</span><br><span class="line"></span><br><span class="line">k = pd.DataFrame(result).loc[<span class="number">2012</span>:]</span><br><span class="line">k.plot()</span><br></pre></td></tr></table></figure><center><img src="/real-state-best-district-old-buildings-taipei/dis-price.png" title="投資房產"></center><p>這張圖可以看出很多端倪，<br>自從政府調整法令後，<br>炒房投資客有明顯減少，<br>所以貴的地區房價下跌，</p><p>另外也因為台北交通便利，<br>（ubike、公車、捷運）<br>所以不論房價高低，<br>其實生活便利程度相差無幾<br>使得便宜的區域房價上漲，</p><p>房價差距越來越小，<br>平均來說，各區房價都越來越往 50～60W/坪 的價格趨近。</p><p>另外，除了肉眼來判別外，<br>我們也可以由價格標準差得知，<br>台北市各區，房價差異慢慢縮小，</p><center><img src="/real-state-best-district-old-buildings-taipei/std.png" title="投資房產"></center><p>由上面的分析，我們可以得到一個結論<br>對於「公寓」而言，我們應該選擇<br>「房價目前較低的地區」<br>因為這些地區的房價，會慢慢往平均（50～60W/坪）移動</p><p>所以假如是買公寓的話，要選哪裡呢？<br>以條件來分析的話，可以這樣選</p><ol><li>2019年房價 &lt; 平均的區域（價格低的）</li><li>2019年房價 &gt; 2018年的區域（看近期有漲的）</li></ol><p>以下就是程式碼以及選出來的區域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p2019 = k.loc[<span class="number">2019</span>]</span><br><span class="line">p2018 = k.loc[<span class="number">2018</span>]</span><br><span class="line"></span><br><span class="line">good_district = (p2019 &gt; p2018) &amp; (p2019 &lt; p2019.mean())</span><br><span class="line">p2019[good_district].sort_values()</span><br></pre></td></tr></table></figure><center><img src="/real-state-best-district-old-buildings-taipei/ranking.png" title="投資房產"></center><p>2. 用屋齡來判斷</p><p>大家都說越老的房子會折舊，<br>越老的房子應該要越便宜，<br>然而事情真的是這樣嗎？</p><p>實價登錄的資料令人跌破眼鏡！<br>根據數據的分析，每個區域都適用：<br>在屋齡「40～50」年的房子，竟然還會往上漲！？<br>不論哪一個區域，哪一年，都可以觀察到這個現象！</p><p>舉個例子，以下我們來繪圖「中山區」房價</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2012</span>, <span class="number">2020</span>):</span><br><span class="line">    df_local = df[(df[<span class="string">'鄉鎮市區'</span>] == <span class="string">'中山區'</span>) &amp; (df[<span class="string">'year'</span>] == i)]</span><br><span class="line">    df_local[<span class="string">'房屋年齡'</span>] = ((<span class="number">2019</span> - pd.to_numeric(df_local[<span class="string">'建築完成年月'</span>].str[:<span class="number">3</span>]) - <span class="number">1911</span>)).astype(int, errors=<span class="string">'ignore'</span>)</span><br><span class="line">    df_local[<span class="string">'房屋年齡'</span>] = pd.to_numeric(df_local[<span class="string">'房屋年齡'</span>] /<span class="number">10</span>).round()</span><br><span class="line">    df_local[<span class="string">'單價元坪'</span>].groupby(df_local[<span class="string">'房屋年齡'</span>]).mean().plot()</span><br></pre></td></tr></table></figure><center><img src="/real-state-best-district-old-buildings-taipei/age.png" title="投資房產"></center><p>上圖每一條線的意思是<br>每一年「不同屋齡的公寓價格」<br>我們可以觀察到幾個現象：</p><ol><li>年輕的公寓下跌的比較快</li><li>老公寓在40～50歲時，還會往上漲</li></ol><p>第二點尤其的詭異，<br>可能是因為都更的關係？<br>不只是中山區，<br>台北的任一區都可以觀察到這個現象<br>大家可以回去跑跑看</p><p>總之，至少老公寓折舊的速度，<br>是比想像中還要慢的，<br>（或可能是老公寓都賣不出去，除<br>非特別地段、特別地點，導致樣本有偏差？<br>還需要再研究）</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>這邊還是要提醒大家，<br>這個是針對「老公寓」做的研究，<br>假如是「新成屋」、「華廈」等屋型，<br>還需要額外去研究才能更清楚。</p><p>數據只是一部分的幫助，<br>買到好房子還是必需要做很多其他功課<br>例如：附近的捷運、生活機能、嫌惡設施 等等<br>都很重要<br>另外，看房技巧、談價格 也不能忽略，</p><p>不過以統計的觀點來說</p><p>保值地區首選順序：<br>「萬華區、文山區、內湖區、南港區」</p><p>保值屋齡首選：<br>「20～40歲以上」公寓</p><p>假如你要在台北買房，<br>而且想要買舊公寓重新裝潢，<br>希望這篇文章可以幫助到你！</p><p>也歡迎分享給有在看房的朋友哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文末告訴你買哪裡？多少年齡的公寓？比較好&lt;br&gt;（結果滿出乎意料）&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/real-state-best-district-old-buildings-taipei/thumbnail.png&quot; title=&quot;投資房產&quot;&gt;&lt;/cent
      
    
    </summary>
    
      <category term="實價登入" scheme="https://www.finlab.tw/categories/%E5%AF%A6%E5%83%B9%E7%99%BB%E5%85%A5/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="房地產" scheme="https://www.finlab.tw/tags/%E6%88%BF%E5%9C%B0%E7%94%A2/"/>
    
  </entry>
  
  <entry>
    <title>機器學習無法預測股價！</title>
    <link href="https://www.finlab.tw/ml-can-not-predict-price/"/>
    <id>https://www.finlab.tw/ml-can-not-predict-price/</id>
    <published>2019-11-06T19:57:11.000Z</published>
    <updated>2020-06-05T07:29:48.574Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/ml-can-not-predict-price/thumbnail.png" title="delay"></center><p>很多我非常尊敬的前輩，說機器學習有一些缺點，拿來投資很危險，<br>這些我都認同，畢竟要做出好的模型是很有挑戰的，<br>且回測模擬跟實際投資的狀況不一樣，非常認同！</p><h3 id="但有時候真的稍微有那麼一點激烈"><a href="#但有時候真的稍微有那麼一點激烈" class="headerlink" title="但有時候真的稍微有那麼一點激烈"></a>但有時候真的稍微有那麼一點激烈</h3><p>另一位我很尊敬的前輩，暗指用AI投資的人：<br>「他們的想像力都消失了，他們只是在耗著老天爺給他們的天賦，<br>  或是青春給他們能犯錯的空間，在那邊浪費生命。」<br>「很多人都被工具綁架邏輯，沒有一點想像力」<br>「做出來的只是垃圾，臭不可聞」</p><h3 id="嗯…"><a href="#嗯…" class="headerlink" title="嗯…"></a>嗯…</h3><p>「究竟跟AI有多深的怨念？」XD<br>我不知道是不是哪裡有不小心得罪或冒犯，<br>才讓他對於使用 AI 投資的人這麼嗤之以鼻<br>以我來說，我最早之前，是做價值投資的研究，後來加入了點技術指標，價量，到現在研究機器學習，</p><p>我覺得<br>每個人投資方法不同，<br>有價值型投資，技術指標，短線、極短線、中長線、存股<br>不論是哪些方法，都有很多人賺錢，更多人賠錢</p><p>不論如何</p><h4 id="可以長期穩定獲利的就是好工具。"><a href="#可以長期穩定獲利的就是好工具。" class="headerlink" title="可以長期穩定獲利的就是好工具。"></a>可以長期穩定獲利的就是好工具。</h4><p>這些對 AI 不屑前輩的口中，總是有著這麼一句話：</p><h3 id="機器學習無法預測價格"><a href="#機器學習無法預測價格" class="headerlink" title="機器學習無法預測價格"></a>機器學習無法預測價格</h3><p>這句話，以我自己的經驗來說，是舉雙手認同的，<br>但就算是認同，我也絕對不敢斷定，或直接了當的大肆宣揚，<br>畢竟這個世界有太多東西要學習了，</p><p>不過我們就先「假設」機器學習無法預測股價好了</p><h4 id="難道想獲利一定要預測股價嗎？"><a href="#難道想獲利一定要預測股價嗎？" class="headerlink" title="難道想獲利一定要預測股價嗎？"></a>難道想獲利一定要預測股價嗎？</h4><p>你不需要懂機器學習，也知道：</p><h4 id="通常撰寫策略，從來不用預測股價"><a href="#通常撰寫策略，從來不用預測股價" class="headerlink" title="通常撰寫策略，從來不用預測股價"></a>通常撰寫策略，從來不用預測股價</h4><p>只要產生的交易訊號，也就是買賣時機點就可以了，<br>照著操作，被動的投資，而不是主動的預測，<br>對於機器學習也是同樣的道理。</p><p>所以正確的使用機器學習的方法是：</p><h3 id="不要用機器學習預測股價，而是用來直接產生交易訊號！"><a href="#不要用機器學習預測股價，而是用來直接產生交易訊號！" class="headerlink" title="不要用機器學習預測股價，而是用來直接產生交易訊號！"></a>不要用機器學習預測股價，而是用來直接產生交易訊號！</h3><p>既然大家都有這樣的知識，為何還要執著於「機器學習無法預測股價」所以「機器學習沒有用」這件事情上呢？<br>就像是你測量羽毛跟保齡球落下，時間不一樣，難道就說牛頓第二運動定律是錯的了嗎？<br>比較有可能是實驗做錯了啦～</p><p>為何大家都說機器學習無法預測股價，先簡單的說明一下</p><h3 id="最為人所知的機器學習障礙-預測延遲"><a href="#最為人所知的機器學習障礙-預測延遲" class="headerlink" title="最為人所知的機器學習障礙 - 預測延遲"></a>最為人所知的機器學習障礙 - 預測延遲</h3><p>簡單來說，就是下圖中，藍色的為股價，而紅色的是機器學習預測的數值，<br>可以看到紅色永遠比藍色線慢半拍，晚一步才轉折<br>雖然藍色跟紅色非常接近，但離「預測」其實差得很遠，回測後就會發現，是不能拿來交易的，</p><p><center><img src="/ml-can-not-predict-price/delay.png" title="delay"></center><br>這個就是大家所說，機器學習的預測延遲<br>說真的，這類有小瑕疵的文章或論文是真的滿多的，<br>例如 <a href="https://towardsdatascience.com/predicting-stock-price-with-lstm-13af86a74944" rel="external nofollow noopener noreferrer" target="_blank">這篇</a><br>就連我們的部落格，也有<a href="https://www.finlab.tw/%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E5%B9%AB%E4%BD%A0%E8%A7%A3%E6%9E%90K%E7%B7%9A%E5%9C%96%EF%BC%81/">這類的文章</a></p><p>你只要搜尋「machine learning predict stock price」<br>就可以找到滿坑滿谷的文章，都有這個缺點</p><p>之所以會有這樣的問題，不難理解，因為股價並不是stationary time series，所以機器學習直接預測股價很容易失真<br>導致最後落入 overfitting 的窘境，且預測結果常常會有 bias</p><p>所以</p><h3 id="我自己寫的文章，沒有任何一篇是教大家預測股價的"><a href="#我自己寫的文章，沒有任何一篇是教大家預測股價的" class="headerlink" title="我自己寫的文章，沒有任何一篇是教大家預測股價的"></a>我自己寫的文章，沒有任何一篇是教大家預測股價的</h3><p>我想提供大家真的能夠獲利的程式碼，<br>用來展示機器學習真的可以用來投資，<br>我不是蹭AI的熱潮，東拼西湊，只求程式可以跑，<br>而是盡力做出一個希望能夠獲利的模型，又讓大家可以學到新的演算法<br>並把這個模型分享給大家，然而AI不是神，沒有一個策略保證一定賺錢，<br>但我至少做到問心無愧，目前績效看起來也還OK，</p><h3 id="機器學習策略-我認為有效的方法"><a href="#機器學習策略-我認為有效的方法" class="headerlink" title="機器學習策略 - 我認為有效的方法"></a>機器學習策略 - 我認為有效的方法</h3><p>接下來舉一個，我認為有用的方法，<br>首先利用<br>Integrating a Piecewise Linear Representation Method and a Neural Network Model for Stock Trading Points Prediction<br>這篇 paper 當中的方式產生交易訊號<br>並且讓機器學習模型模仿，找出轉折點，以下是簡略的數據：</p><ul><li>商品：台股加權指數，取每15分鐘的收盤價</li><li>製作特徵：利用各種技術指標當作features</li><li>預測訊號：利用上述的 paper 產生交易訊號</li><li>利用2015年以前的資料產生模型，</li></ul><p>用一個最普通的神經網路，就可以有不錯的效果，以下是2019年5月的範例圖，<br>其中</p><ul><li>紅色為股價</li><li>藍色為多方轉折的發生機率</li><li>紫色為空方轉折的發生機率（負值）</li></ul><p>可以看出來，當藍色飆高時，通常是底部的多方轉折<br>而紫色飆高時，則是相反，是頭部的空方轉折</p><p><center><img src="/ml-can-not-predict-price/better.png" title="better"></center><br>2019年五月</p><p><center><img src="/ml-can-not-predict-price/better2.png" title="better2"></center><br>2019年六月<br>看不出有延遲，幾乎都是直接實時反應，<br>看起來還抓的算滿OK的，可以用來逆勢操作</p><p>雖然看似有用，但</p><h3 id="機器學習不適用於所有人，因為很難很複雜"><a href="#機器學習不適用於所有人，因為很難很複雜" class="headerlink" title="機器學習不適用於所有人，因為很難很複雜"></a>機器學習不適用於所有人，因為很難很複雜</h3><h3 id="付出與收穫可能不成正比"><a href="#付出與收穫可能不成正比" class="headerlink" title="付出與收穫可能不成正比"></a>付出與收穫可能不成正比</h3><p>假如你不喜歡折磨自己<br>其實簡單的策略也可以賺錢的，<br>所以說你不一定要用機器學習來投資，</p><h3 id="然而每個人各有喜好，"><a href="#然而每個人各有喜好，" class="headerlink" title="然而每個人各有喜好，"></a>然而每個人各有喜好，</h3><p>以我而言，我喜歡<strong>追求和分享新的科技</strong>，<br>並且幫助大家學習新知識之餘，幸運的話還可以賺點錢，<br>然而走在科技的前沿，特立獨行，本來就是會有很多的支持和反對<br>我不敢說這條路走的正確，但我們能走多遠是多遠，<br>這一切紛擾，只能用對帳單來證明了（XDD努力生產中）<br>（雖然我們早在一年前開始就把模擬結果<a href="https://ai.finlab.tw/strategy/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%20-%20%E8%B2%A1%E5%8B%99%E5%A0%B1%E8%A1%A8%E9%81%B8%E8%82%A1" rel="external nofollow noopener noreferrer" target="_blank">每天都放上網</a>，但看來對帳單還是必須的呀！）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/ml-can-not-predict-price/thumbnail.png&quot; title=&quot;delay&quot;&gt;&lt;/center&gt;

&lt;p&gt;很多我非常尊敬的前輩，說機器學習有一些缺點，拿來投資很危險，&lt;br&gt;這些我都認同，畢竟要做出好的模型是很有
      
    
    </summary>
    
      <category term="AI看股票" scheme="https://www.finlab.tw/categories/AI%E7%9C%8B%E8%82%A1%E7%A5%A8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Machine Learning" scheme="https://www.finlab.tw/tags/Machine-Learning/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="量化投資" scheme="https://www.finlab.tw/tags/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B3%87/"/>
    
  </entry>
  
</feed>
