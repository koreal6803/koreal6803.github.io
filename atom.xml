<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FinLab 量化實驗室</title>
  
  <subtitle>回測與選股教學部落格</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.finlab.tw/"/>
  <updated>2020-06-08T01:43:07.037Z</updated>
  <id>https://www.finlab.tw/</id>
  
  <author>
    <name>koreal6803</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bokeh 探索頻道(1)~Python互動式圖表函數庫初體驗</title>
    <link href="https://www.finlab.tw/python-bokeh1-setup-and-first-impression/"/>
    <id>https://www.finlab.tw/python-bokeh1-setup-and-first-impression/</id>
    <published>2020-06-08T01:27:10.000Z</published>
    <updated>2020-06-08T01:43:07.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-視覺化套件使用經驗"><a href="#Python-視覺化套件使用經驗" class="headerlink" title="Python 視覺化套件使用經驗"></a>Python 視覺化套件使用經驗</h2><p>Python套件多，品質不一。用module之前，我習慣先看github星星確認認可度，有1000個以上多是品質保證，再看release history，看是否有被持續維護，那種2年以上沒新版本的，採坑機率高。Bokeh看來沒問題。</p><p><img src="https://i.imgur.com/y3p5KBo.png" alt></p><p>平常python視覺化的主力套件是matplotlib和seaborn，前者是20歲老套件，是視覺化元祖，許多套件基礎都是建構在matplotlib上，像seaborn就是，有更簡潔的寫法和精美圖例，兩者都以靜態視覺居多，缺乏變化性(或是要費點功)。<br>Python守備範圍廣，但在網頁前端仍難以與Java Script抗衡，而D3.js函數庫也要花不少學習成本，有沒有辦法用Python做出JS動態視覺的效果？</p><p>Bokeh的出世，提供了Python與D3.js之間的橋梁，讓你可以用Python做出D3.js常用功能的效果，減少學習成本，高效開發，輕鬆描述統計結果。</p><h2 id="厲害在哪裡？"><a href="#厲害在哪裡？" class="headerlink" title="厲害在哪裡？"></a>厲害在哪裡？</h2><p>先來看Gallory，python視覺化套件很多，範例圖不夠精美的，可考慮跳過。</p><ol><li>化學元素週期表</li></ol><p><img src="https://i.imgur.com/81XiMAU.png" alt="化學元素週期表"></p><ol start="2"><li>雷達圖</li></ol><p><img src="https://i.imgur.com/hMPxBgq.png" alt></p><ol start="3"><li>互動式wiget散點圖表</li></ol><p><img src="https://i.imgur.com/9vnv8yZ.png" alt></p><p>逛了一圈，發現Bokeh圖表精美、範例多、都有附原始碼，官方教學也完整，有tutorial jupyter檔案教學。<br>看來比matplotlib強大，也比plotly漂亮…，函數庫使用看來也不難，且可鑲嵌到Django等Web框架，無論是local或遠端的前端呈現都可以效率開發。</p><h2 id="開箱試玩時間"><a href="#開箱試玩時間" class="headerlink" title="開箱試玩時間"></a>開箱試玩時間</h2><p>要注意的是bokeh會預設連BokehJS cdn，但連線有時不是很穩定，這時可多加”INLINE”環境變數設定，讓BokehJS驅動於local python env。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bokeh.resources <span class="keyword">import</span> INLINE</span><br><span class="line">bokeh.io.output_notebook(INLINE)</span><br></pre></td></tr></table></figure><p>Bokeh可以在Jupyter呈現開發也可以跳轉出html檔，可自由設定，預設是跳轉html檔(output_file())。若要更改預設，必須加上<code>bokeh.io.reset_output()</code>重設環境預設。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output_notebook() ＃jupyter呈現</span><br><span class="line">output_file()  ＃html呈現</span><br></pre></td></tr></table></figure><p>fig物件可設定tools參數，圖表會自帶縮放、重整、儲存等功能。<br>以下是參考官方範例後微調的程式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bokeh.plotting <span class="keyword">import</span> figure, output_file, show, output_notebook</span><br><span class="line"><span class="keyword">import</span> bokeh.io</span><br><span class="line"><span class="keyword">from</span> bokeh.resources <span class="keyword">import</span> INLINE</span><br><span class="line"></span><br><span class="line"><span class="comment"># env settings 環境變數設定</span></span><br><span class="line">bokeh.io.reset_output()</span><br><span class="line">bokeh.io.output_notebook(INLINE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare some data</span></span><br><span class="line">x = [<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>, <span class="number">3.0</span>]</span><br><span class="line">y0 = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">y1 = [<span class="number">10</span>**i <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">y2 = [<span class="number">10</span>**(i**<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line"><span class="comment"># output to static HTML file</span></span><br><span class="line"><span class="comment"># output_file("log_lines.html")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create a new plot</span></span><br><span class="line">p = figure(</span><br><span class="line">tools=<span class="string">"pan,box_zoom,reset,save"</span>,</span><br><span class="line">y_axis_type=<span class="string">"log"</span>, y_range=[<span class="number">0.001</span>, <span class="number">10</span>**<span class="number">11</span>], title=<span class="string">"log axis example"</span>,</span><br><span class="line">x_axis_label=<span class="string">'sections'</span>, y_axis_label=<span class="string">'particles'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add some renderers</span></span><br><span class="line">p.line(x, x, legend_label=<span class="string">"y=x"</span>)</span><br><span class="line">p.circle(x, x, legend_label=<span class="string">"y=x"</span>, fill_color=<span class="string">"white"</span>, size=<span class="number">8</span>)</span><br><span class="line">p.line(x, y0, legend_label=<span class="string">"y=x^2"</span>, line_width=<span class="number">3</span>)</span><br><span class="line">p.line(x, y1, legend_label=<span class="string">"y=10^x"</span>, line_color=<span class="string">"red"</span>)</span><br><span class="line">p.circle(x, y1, legend_label=<span class="string">"y=10^x"</span>, fill_color=<span class="string">"red"</span>, line_color=<span class="string">"red"</span>, size=<span class="number">6</span>)</span><br><span class="line">p.line(x, y2, legend_label=<span class="string">"y=10^x^2"</span>, line_color=<span class="string">"orange"</span>, line_dash=<span class="string">"4 4"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show the results</span></span><br><span class="line">show(p)</span><br><span class="line">output_notebook() </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/cK9ZFBB.png" alt></p><h2 id="投資圖表試玩"><a href="#投資圖表試玩" class="headerlink" title="投資圖表試玩"></a>投資圖表試玩</h2><p>Bokeh官方有提供sample_data給大家練習，gallery豐富的範例都取自sample_data，對比官方的資料格式就能輕鬆模仿應用，沒啥高深程式技巧。下載sample_data指令為<code>bokeh.sampledata.download()</code>，直接貼在jupyter執行。檔案會下載到bokeh module裡。</p><h3 id="檢查蘋果電腦範例資料-json"><a href="#檢查蘋果電腦範例資料-json" class="headerlink" title="檢查蘋果電腦範例資料(json)"></a>檢查蘋果電腦範例資料(json)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bokeh.sampledata.stocks <span class="keyword">import</span> AAPL</span><br><span class="line"><span class="comment"># 檢查欄位</span></span><br><span class="line">AAPL.keys()</span><br><span class="line"><span class="comment">#dict_keys(['date', 'open', 'high', 'low', 'close', 'volume', 'adj_close'])</span></span><br></pre></td></tr></table></figure><h3 id="ColumnDataSource物件為Bokeh資料驅動渲染核心"><a href="#ColumnDataSource物件為Bokeh資料驅動渲染核心" class="headerlink" title="ColumnDataSource物件為Bokeh資料驅動渲染核心"></a>ColumnDataSource物件為Bokeh資料驅動渲染核心</h3><p>dataframe要傳入ColumnDataSource才能驅動js。<br>providing the data that is visualized by the glyphs of the plot<br><a href="https://docs.bokeh.org/en/latest/docs/user_guide/data.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.bokeh.org/en/latest/docs/user_guide/data.html</a></p><h3 id="HoverTool"><a href="#HoverTool" class="headerlink" title="HoverTool"></a>HoverTool</h3><p>游標滑過時顯示資料</p><h3 id="Click-policy"><a href="#Click-policy" class="headerlink" title="Click_policy"></a>Click_policy</h3><p>藉由標籤控制數值顯示<br>hide為隱藏，mute為切換自訂顯示模式<br>可在muted_color控制顏色, muted_alpha控制顏色濃淡</p><h3 id="程式範例"><a href="#程式範例" class="headerlink" title="程式範例"></a>程式範例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> bokeh.io</span><br><span class="line"><span class="keyword">from</span> bokeh.resources <span class="keyword">import</span> INLINE</span><br><span class="line"><span class="keyword">from</span> bokeh.models <span class="keyword">import</span> HoverTool</span><br><span class="line"><span class="keyword">from</span> bokeh.palettes <span class="keyword">import</span> Spectral4</span><br><span class="line"><span class="keyword">from</span> bokeh.plotting <span class="keyword">import</span> figure, output_file, show, output_notebook, ColumnDataSource</span><br><span class="line"><span class="keyword">from</span> bokeh.sampledata.stocks <span class="keyword">import</span> AAPL, GOOG, IBM, MSFT</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># env settings</span></span><br><span class="line">bokeh.io.reset_output()</span><br><span class="line">bokeh.io.output_notebook(INLINE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set hover</span></span><br><span class="line"><span class="comment">## HoverTool</span></span><br><span class="line"><span class="comment"># 游標滑過時顯示資料,date格式需要轉換，不然會是timestamp</span></span><br><span class="line">hover = HoverTool(</span><br><span class="line">    tooltips = [</span><br><span class="line">        (<span class="string">"date"</span>, <span class="string">"@date"</span>),</span><br><span class="line">        (<span class="string">"close"</span>, <span class="string">"@open"</span>),</span><br><span class="line">        (<span class="string">"close"</span>, <span class="string">"@close"</span>),</span><br><span class="line">        (<span class="string">"high"</span>, <span class="string">"@high"</span>),</span><br><span class="line">        (<span class="string">"low"</span>, <span class="string">"@low"</span>),</span><br><span class="line">        (<span class="string">"volume"</span>,<span class="string">"@volume"</span>)</span><br><span class="line">    ], </span><br><span class="line">    formatters=&#123;<span class="string">"@date"</span>:<span class="string">"datetime"</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set figure</span></span><br><span class="line">p = figure(</span><br><span class="line">    plot_width=<span class="number">1000</span>, </span><br><span class="line">    plot_height=<span class="number">400</span>, </span><br><span class="line">    x_axis_type=<span class="string">"datetime"</span>,</span><br><span class="line">    tools=[hover,<span class="string">"pan,box_zoom,reset,save"</span>],</span><br><span class="line">)</span><br><span class="line">p.title.text = <span class="string">'Stock_Price--Click on legend entries to mute the corresponding lines and show daily details in hover'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use ColumnDataSource to control</span></span><br><span class="line"><span class="comment"># click_policy</span></span><br><span class="line"><span class="comment"># 藉由標籤控制數值顯示</span></span><br><span class="line"><span class="comment"># hide為隱藏，mute為切換自訂顯示模式</span></span><br><span class="line"><span class="comment"># 可在muted_color控制顏色, muted_alpha控制顏色濃淡</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data, name, color <span class="keyword">in</span> zip([AAPL, IBM, MSFT, GOOG], [<span class="string">"AAPL"</span>, <span class="string">"IBM"</span>, <span class="string">"MSFT"</span>, <span class="string">"GOOG"</span>], Spectral4):</span><br><span class="line">    df = pd.DataFrame(data)</span><br><span class="line">    df[<span class="string">'date'</span>] = pd.to_datetime(df[<span class="string">'date'</span>])</span><br><span class="line">    source = ColumnDataSource(df)</span><br><span class="line">    p.line(x=<span class="string">"date"</span>,y=<span class="string">"close"</span>, line_width=<span class="number">2</span>, color=color, alpha=<span class="number">0.8</span>,</span><br><span class="line">           muted_color=color, muted_alpha=<span class="number">0.2</span>, legend_label=name,source=source)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.legend.location = <span class="string">"top_left"</span></span><br><span class="line"><span class="comment"># use hide or mute</span></span><br><span class="line">p.legend.click_policy=<span class="string">"mute"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output_file("interactive_legend.html", title="interactive_legend.py example")</span></span><br><span class="line"></span><br><span class="line">show(p)</span><br><span class="line">output_notebook() </span><br></pre></td></tr></table></figure><h3 id="兩種模式結果比較"><a href="#兩種模式結果比較" class="headerlink" title="兩種模式結果比較"></a>兩種模式結果比較</h3><ol><li><p>Mute<br><img src="https://i.imgur.com/xkQhfUt.png" alt></p></li><li><p>Hide<br><img src="https://i.imgur.com/fKmVrH1.png" alt></p></li></ol><h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>這篇主要是來體會一下Bokeh的效果，不用會JS，隨便玩就有這種效果，蠻滿意的，值得再深入一下細節，把以前matplotlib的圖表都轉來bokeh，無論是在工作上的資料報告還是看盤需要，都蠻方便的。</p><h3 id="程式檔案連結"><a href="#程式檔案連結" class="headerlink" title="程式檔案連結"></a>程式檔案連結</h3><p><a href="https://github.com/benbilly3/bokeh_explore" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/benbilly3/bokeh_explore</a></p><h6 id="tags-bokeh"><a href="#tags-bokeh" class="headerlink" title="tags: bokeh"></a>tags: <code>bokeh</code></h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-視覺化套件使用經驗&quot;&gt;&lt;a href=&quot;#Python-視覺化套件使用經驗&quot; class=&quot;headerlink&quot; title=&quot;Python 視覺化套件使用經驗&quot;&gt;&lt;/a&gt;Python 視覺化套件使用經驗&lt;/h2&gt;&lt;p&gt;Python套件多，品質不一
      
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="資料視覺化" scheme="https://www.finlab.tw/tags/%E8%B3%87%E6%96%99%E8%A6%96%E8%A6%BA%E5%8C%96/"/>
    
      <category term="bokeh" scheme="https://www.finlab.tw/tags/bokeh/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(12)：手機監控與自動下單</title>
    <link href="https://www.finlab.tw/btc-aws-signal-trigger-condition/"/>
    <id>https://www.finlab.tw/btc-aws-signal-trigger-condition/</id>
    <published>2020-05-31T20:23:13.000Z</published>
    <updated>2020-06-05T07:29:48.680Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/btc-aws-signal-trigger-condition/thumbnail.png" title="thumbnail"></center><p>我們上次已經寫好了「核心」程式<br>但什麼時候，才能執行這些程式呢？<br>總共有兩種方式啟動程式：</p><ol><li>一種是連上網監控</li><li>另一種是時間間格、自動下單（每4小時）</li></ol><h3 id="1-連上網監控"><a href="#1-連上網監控" class="headerlink" title="1. 連上網監控"></a>1. 連上網監控</h3><p>我們可以用「新增觸發條件」來觸發，<br>並且點選「API Gateway」：</p><center><img src="/btc-aws-signal-trigger-condition/selectTrigger.png" title="thumbnail"></center><br><center><img src="/btc-aws-signal-trigger-condition/createGateway.png" title="thumbnail"></center><br>最後會給你一個網址<br>用任何手機、筆電 連進去就可以了！<br><center><img src="/btc-aws-signal-trigger-condition/triggerUrl.png" title="thumbnail"></center><br><center><img src="/btc-aws-signal-trigger-condition/results.png" title="thumbnail"></center><h3 id="2-時間間格、自動下單"><a href="#2-時間間格、自動下單" class="headerlink" title="2. 時間間格、自動下單"></a>2. 時間間格、自動下單</h3><p>首先我們先將原本的 API Gateway 刪除<br>然後再增加新的 Trigger：每4小時執行一次</p><p><center><img src="/btc-aws-signal-trigger-condition/addcron.png" title="thumbnail"></center><br>這樣就會四小時執行一次了！</p><p>假如我們希望它四小時判斷多空與下單，<br>可以將上一個單元的範例<br>做以下的修改</p><ol><li>新增 client 使用金鑰登入（可以到 <a href="https://www.binance.com/tw/" rel="external nofollow noopener noreferrer" target="_blank">Binance</a> 申請）</li><li>做多時，要買入「BTCUSDT」</li><li>做空時，賣出「BTCUSDT」</li></ol><p>以下的範例，在做空時，<br>我們只單純的賣出，而不額外做空<br>因為我們現在是用現貨且無槓桿的交易帳戶<br>所以沒有辦法做空喔！<br>假如想要做BTC期貨，也可以參考<a href="https://python-binance.readthedocs.io/en/latest/margin.html" rel="external nofollow noopener noreferrer" target="_blank">官方的Margin Trading End Point</a></p><p>以下就是現貨範例，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> binance.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lambda_handler</span><span class="params">(event, context)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##########</span></span><br><span class="line">    <span class="comment"># Login #</span></span><br><span class="line">    <span class="comment">##########</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># before:</span></span><br><span class="line">    <span class="comment"># client = Client()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># after:</span></span><br><span class="line">    PUBLIC = <span class="string">'&lt;YOUR-PUBLIC-KEY&gt;'</span></span><br><span class="line">    SECRET = <span class="string">'&lt;YOUR-SECRET-KEY&gt;'</span></span><br><span class="line">    QUANTITY = <span class="number">0.0001</span></span><br><span class="line"></span><br><span class="line">    client = Client(api_key=PUBLIC, api_secret=SECRET)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">###################</span></span><br><span class="line">    <span class="comment"># historical data #</span></span><br><span class="line">    <span class="comment">###################</span></span><br><span class="line">    </span><br><span class="line">    klines = client.get_historical_klines(<span class="string">"BTCUSDT"</span>, Client.KLINE_INTERVAL_4HOUR, <span class="string">"two week ago"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sma</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-1</span>:<span class="number">-1</span>]])/n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prev_sma</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-2</span>:<span class="number">-2</span>]])/n</span><br><span class="line">    </span><br><span class="line">    sma60 = sma(<span class="number">65</span>)</span><br><span class="line">    sma5 = sma(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    psma60 = prev_sma(<span class="number">65</span>)</span><br><span class="line">    psma5 = prev_sma(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">###################</span></span><br><span class="line">    <span class="comment">#      Trade      #</span></span><br><span class="line">    <span class="comment">###################</span></span><br><span class="line">    </span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">        ret = <span class="string">'long'</span></span><br><span class="line">        order = client.order_market_buy(</span><br><span class="line">            symbol=<span class="string">'BTCUSDT'</span>,</span><br><span class="line">            quantity=QUANTITY)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">        ret = <span class="string">'short'</span></span><br><span class="line">        order = client.order_market_sell(</span><br><span class="line">            symbol=<span class="string">'BTCUSDT'</span>,</span><br><span class="line">            quantity=QUANTITY)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">        ret = <span class="string">'hold short'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">        ret = <span class="string">'hold long'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO implement</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'statusCode'</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">'body'</span>: json.dumps(<span class="string">'btc-trading-signal: '</span> + ret)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>經過這12個單元，<br>相信大家對於加密貨幣量化交易有初步的理解<br>大概瞭解如何建構一個自動化的交易系統</p><p>你會發現<br>手刻一個交易系統，其實沒有很難<br>難的在於，<br>如何「系統化」的建立一個多元的交易策略<br>研發多個策略 並統整起來，<br>考驗大家撰寫策略、系統化的能力</p><p>怕輸太多錢嗎？<br>沒關係，因為加密貨幣可以切割至 10 的 8 次方！<br>就算你有一百種不同的策略，<br>也可以用300元台幣順利分散風險喔！<br>所以不要再猶豫了，趕快來試試看吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/btc-aws-signal-trigger-condition/thumbnail.png&quot; title=&quot;thumbnail&quot;&gt;&lt;/center&gt;

&lt;p&gt;我們上次已經寫好了「核心」程式&lt;br&gt;但什麼時候，才能執行這些程式呢？&lt;br&gt;總共
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(11)：用AWS Lambda即時更新交易訊號</title>
    <link href="https://www.finlab.tw/btc-aws-lambda-signal-update/"/>
    <id>https://www.finlab.tw/btc-aws-lambda-signal-update/</id>
    <published>2020-05-25T06:35:48.000Z</published>
    <updated>2020-06-05T07:29:48.218Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/btc-aws-lambda-signal-update/thumbnail.png" title="thumbnail"></center><p>上一個單元中，<br>大家都已經操作好了 AWS Lambda<br>建立一個簡單的 Hello World</p><p>接下來，<br>我們就可以開始建構<br>比特幣的交易系統了</p><p>首先，可以先在 local 端架設環境，<br>方便我們確認程式可以跑，<br>之後再把它複製到雲端即可。</p><p>首先在本地端先安裝 python-binance<br>用來收報價與下單：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-binance</span><br></pre></td></tr></table></figure><p>再來，<br>撰寫交易系統的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> binance.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"><span class="comment"># get price from binance api</span></span><br><span class="line">client = Client()</span><br><span class="line">klines = client.get_historical_klines(<span class="string">"BTCUSDT"</span>, Client.KLINE_INTERVAL_4HOUR, <span class="string">"two week ago"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># function to calculate sma value</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sma</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-1</span>:<span class="number">-1</span>]])/n</span><br><span class="line"></span><br><span class="line"><span class="comment"># function to calculate previous sma value</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prev_sma</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-2</span>:<span class="number">-2</span>]])/n</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate sma 5 and 65</span></span><br><span class="line">sma60 = sma(<span class="number">65</span>)</span><br><span class="line">sma5 = sma(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate previous sma 5 and 65</span></span><br><span class="line">psma60 = prev_sma(<span class="number">65</span>)</span><br><span class="line">psma5 = prev_sma(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># golden cross</span></span><br><span class="line"><span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">    print(<span class="string">'flip to long'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># dead cross</span></span><br><span class="line"><span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">    print(<span class="string">'flip to short'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hold for short</span></span><br><span class="line"><span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">    print(<span class="string">'hold short'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hold for long</span></span><br><span class="line"><span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">    print(<span class="string">'hold long'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上，我們建構一個簡單的程式碼<br>每次執行，都可以產生出當前的訊號～<br>這個策略<br>就是我們在<a href="btc-backtesting-optimization/">前個單元中</a><br>經過優化後的均線策略，<br>這邊我們用不同的方式撰寫一次</p><p>接下來<br>就是將以上的程式碼<br>移到 AWS Lambda 上！</p><p>首先，跟剛剛一樣，<br>在 Lambda 上，<br>我們可以先來安裝<br>Binance 的 API<br>來獲取報價跟下單</p><p>之前，我們只需要使用<br>pip install python-binance<br>就可以安裝了</p><p>但 AWS 上要安裝 package 呢？<br>AWS 沒有一台 server 可以下安裝指令<br>所以我們可以先自己下載 </p><p>「python-binance」這個 package<br>壓縮成壓縮檔，<br>這個檔案以AWS的術語，叫做 AWS Layer ，<br>我已經幫大家打包好了，<br>可以<a href="/btc-aws-lambda-signal-update/lambda-layer-binance.zip">點此下載</a><br>並將 AWS Layer 上傳上去，<br>方法如下圖：</p><center><img src="/btc-aws-lambda-signal-update/layer1.png" title="設定layer"></center><br><center><img src="/btc-aws-lambda-signal-update/layer2.png" title="設定layer2"></center><p>就等於是安裝完畢了</p><p>剩下就簡單了！<br>我們可以到上個單元創建的 Lambda 函數：</p><center><img src="/btc-aws-lambda-signal-update/lambda-select-helloworld.png" title="開啟helloworld"></center><p>並在這個 lambda 函數中<br>新增我們剛剛上傳的layer：</p><center><img src="/btc-aws-lambda-signal-update/lambda-add-layer.png" title="新增layer"></center><br><center><img src="/btc-aws-lambda-signal-update/lambda-add-layer2.png" title="新增layer2"></center><p>最後，我們點選 Hello Lmabda 並往下拉到程式碼編輯視窗：</p><center><img src="/btc-aws-lambda-signal-update/lambda-editor.png" title="編輯器"></center><p>複製到下方的程式碼，到程式碼編輯視窗之中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> binance.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lambda_handler</span><span class="params">(event, context)</span>:</span></span><br><span class="line">    </span><br><span class="line">    client = Client()</span><br><span class="line">    </span><br><span class="line">    klines = client.get_historical_klines(<span class="string">"BTCUSDT"</span>, Client.KLINE_INTERVAL_4HOUR, <span class="string">"two week ago"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sma</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-1</span>:<span class="number">-1</span>]])/n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prev_sma</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([float(k[<span class="number">4</span>]) <span class="keyword">for</span> k <span class="keyword">in</span> klines[-n<span class="number">-2</span>:<span class="number">-2</span>]])/n</span><br><span class="line">    </span><br><span class="line">    sma60 = sma(<span class="number">65</span>)</span><br><span class="line">    sma5 = sma(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    psma60 = prev_sma(<span class="number">65</span>)</span><br><span class="line">    psma5 = prev_sma(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">        ret = <span class="string">'flip to long'</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">        ret = <span class="string">'flip to short'</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> sma5 &lt; sma60 <span class="keyword">and</span> psma5 &lt; psma60:</span><br><span class="line">        ret = <span class="string">'hold short'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sma5 &gt; sma60 <span class="keyword">and</span> psma5 &gt; psma60:</span><br><span class="line">        ret = <span class="string">'hold long'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO implement</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'statusCode'</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">'body'</span>: json.dumps(<span class="string">'btc-trading-signal: '</span> + ret)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>點選「測試」按鈕後，可以用了！</p><p><center><img src="/btc-aws-lambda-signal-update/result.png" title="檢查"></center><br>上圖中，顯示「hold short」代表我們現在是持續偏空的狀態<br>每次按一下 test ，<br>就可以顯示目前的訊號喔！</p><p>目前我們要登入AWS<br>並且執行 lambda 才能看到訊號<br>有點麻煩呀！</p><p>所以在下一個階段，<br>我們將會分享<br>怎麼樣從手機上看到交易訊號<br>以及把這個交易訊號實際下單的方法！<br>可以到<a href="https://www.facebook.com/finlab.python" rel="external nofollow noopener noreferrer" target="_blank">粉專按讚追蹤</a><br>才不會錯過我們每週的更新喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/btc-aws-lambda-signal-update/thumbnail.png&quot; title=&quot;thumbnail&quot;&gt;&lt;/center&gt;

&lt;p&gt;上一個單元中，&lt;br&gt;大家都已經操作好了 AWS Lambda&lt;br&gt;建立一個簡單的 He
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(10)：架設一個簡易的AWS交易系統</title>
    <link href="https://www.finlab.tw/aws-lambda-initial-setup/"/>
    <id>https://www.finlab.tw/aws-lambda-initial-setup/</id>
    <published>2020-05-18T06:35:48.000Z</published>
    <updated>2020-06-05T07:29:49.678Z</updated>
    
    <content type="html"><![CDATA[<p>延續之前的介紹，<br>這個單元中，<br>我們將架設一個簡單的 <a href="https://aws.amazon.com/tw/lambda/" rel="external nofollow noopener noreferrer" target="_blank">AWS Lambda function</a><br>是 AWS ( Amazon cloud service ) 底下的一個服務</p><center><img src="/aws-lambda-initial-setup/thumbnail.png" title="info"></center><p>AWS Lambda function，<br>是一段可以自定義的程式碼<br>會在 AWS 主機上執行<br>可以經由任意的方式啟動，<br>例如每個整點執行一次</p><p>例如以下的例子，<br>就是當使用者上傳照片後<br>就可以用 Lambda function<br>雲端將照片縮小，然後輸出到網頁上：</p><center><img src="/aws-lambda-initial-setup/usage.png" title="info"></center><p>之後我們的交易系統，<br>就會寫在這樣的 function 裡面</p><p>AWS免費提供40萬秒/月，可以讓我們執行 AWS Lambda function<br>所以假如我們的策略頻率是「小時」的話，是非常充足的！</p><p>首先我們可以打開<a href="https://aws.amazon.com/tw/" rel="external nofollow noopener noreferrer" target="_blank">Amazon Web Service網頁</a>，<br>並且註冊帳號，取得服務，<br>在這個過程中，會需要輸入信用卡，<br>不過並不會額外收費，</p><p>進入了主控台們點選 Lambda</p><center><img src="/aws-lambda-initial-setup/open_lambda.png" title="info"></center><p>新增 Lambda 函數</p><center><img src="/aws-lambda-initial-setup/open_panel.png" title="info"></center><p>並且選擇最簡單的Hello World<br>程式語言設定成「Python3.6」<br>按一下右下角確定，稍等一會就成功了！</p><center><img src="/aws-lambda-initial-setup/new_lambda.png" title="info"></center><p>接下來，<br>我們就會看到lambda的頁面，<br>可以在這個頁面下，<br>它已經預設了一個程式，</p><center><img src="/aws-lambda-initial-setup/code.png" title="info"></center><p>我們之後會來修改它<br>不過先不急，我們先跑跑看</p><p>可以按「測試」並且建立預設的事件，<br>你就會看到測試結果：成功！</p><center><img src="/aws-lambda-initial-setup/test.png" title="info"></center><p>接下來我們就要在這個基礎下，來建構一個交易的邏輯，<br>並且每個小時來執行一次！<br>假如對於我們的新文章有興趣，可以幫我們追蹤<a href="https://www.facebook.com/finlab.python" rel="external nofollow noopener noreferrer" target="_blank">我們的粉絲團</a>喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;延續之前的介紹，&lt;br&gt;這個單元中，&lt;br&gt;我們將架設一個簡單的 &lt;a href=&quot;https://aws.amazon.com/tw/lambda/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>創新高股票，你還少看了這個因子！</title>
    <link href="https://www.finlab.tw/break-new-high-roe-stock/"/>
    <id>https://www.finlab.tw/break-new-high-roe-stock/</id>
    <published>2020-05-17T05:21:38.000Z</published>
    <updated>2020-06-05T07:29:51.016Z</updated>
    
    <content type="html"><![CDATA[<p>假如你是追高的選股策略，<br>有沒有一種感覺？<br>就是往往創新高的股票，<br>大部分都賠錢，<br>只有少部分賺錢，</p><p>今天我們將介紹一個因子，<br>大幅提昇創新高獲利的效果！</p><center><img src="/break-new-high-roe-stock/thumbnail.jpeg" title="動手做"></center><p>這種追高的策略，<br>有幾個比較難克服的地方，<br>我們將介紹<br>一個可以破解這些課題的策略。</p><h3 id="1-心理因素"><a href="#1-心理因素" class="headerlink" title="1. 心理因素"></a>1. 心理因素</h3><p>一個就是心魔，<br>因為勝率真的很低<br>所以你會覺得<br>怎麼一直輸錢？<br>造成人為干預嚴重</p><p>所以在追高股票時，<br>最好還是讓自己「分心」<br>也就是透過持有多檔股票的方式<br>讓自己不會過度在乎一檔個股</p><h3 id="2-選到亂漲一通的股票"><a href="#2-選到亂漲一通的股票" class="headerlink" title="2. 選到亂漲一通的股票"></a>2. 選到亂漲一通的股票</h3><p>另外，<br>有時候股票市場很感性<br>不能用理性的方式來交易</p><p>有些個股<br>明明股價淨值比都5以上<br>本益比都50了<br>還漲個沒完</p><p>針對這種個股<br>要是去追高<br>很有可能買在高點！</p><p>所以我們可以用「基本面」<br>來分析這檔股票的「創新高」<br>合不合理</p><h3 id="總結以上兩點-製作創新高策略"><a href="#總結以上兩點-製作創新高策略" class="headerlink" title="總結以上兩點 製作創新高策略"></a>總結以上兩點 製作創新高策略</h3><h4 id="1-動態調整-Portfolio"><a href="#1-動態調整-Portfolio" class="headerlink" title="1. 動態調整 Portfolio"></a>1. 動態調整 Portfolio</h4><p>每兩個禮拜調整一次所選的股票，<br>並將資產「平均分配」於所選的股票中，</p><h4 id="2-基本面篩選"><a href="#2-基本面篩選" class="headerlink" title="2. 基本面篩選"></a>2. 基本面篩選</h4><p>我們並不是看到創新高就無條件選這些股票<br>必須搭配基本面的因子，<br>來選出更有可能維持上漲的股票：</p><ol><li>創新高：股價突破60天內股價</li><li>ROE大於3，前一季ROE大於1</li></ol><p>另外由於股價容易受流動性影響，<br>我們希望買入賣出有流動性的股票：</p><ol start="3"><li>股價大於7</li><li>成交量大於100張</li></ol><p>才能更順利<br>在任意時刻買賣股票</p><h4 id="3-新因子研發"><a href="#3-新因子研發" class="headerlink" title="3. 新因子研發"></a>3. 新因子研發</h4><p>最後，最重要的因子<br>忍痛割愛告訴大家<br>我們特別研發一個「成長+價值」的複合因子：</p><p>新因子 = 當季ROE / 前一季ROE / 股價淨值比</p><p>新因子可以拆解成兩個部分：</p><h5 id="第一部份：成長股篩選"><a href="#第一部份：成長股篩選" class="headerlink" title="第一部份：成長股篩選"></a>第一部份：成長股篩選</h5><p>這個新因子當中，成長的部分是<br>「當季ROE / 前一季ROE」<br>這些ROE成長的股票，這個數值會大於1</p><h5 id="第二部分：價值股篩選"><a href="#第二部分：價值股篩選" class="headerlink" title="第二部分：價值股篩選"></a>第二部分：價值股篩選</h5><p>接下來，我們要選 CP 值高的股票<br>股價淨值比<br>就是一個很好的指標<br>可以幫我們判斷股票的價格是否太高，<br>我們希望<br>「1 ／ 股價淨值比」<br>越大越好，<br>可以參考<a href="/股價淨值比有這麼神？/">「股價淨值比」</a>來瞭解更詳細的原理喔！</p><h5 id="將上述兩種因子合併"><a href="#將上述兩種因子合併" class="headerlink" title="將上述兩種因子合併"></a>將上述兩種因子合併</h5><p>用乘法，將這兩種因子合併起來：</p><p>新因子 = 當季ROE / 前一季ROE / 股價淨值比</p><p>我們將每檔股票都算出此因子，假如當天有超過三檔股票創新高，<br>用這個因子排序，並選出前 3 名的股票，<br>新增到我們的 portfolio 組合裡面</p><h3 id="賣出策略"><a href="#賣出策略" class="headerlink" title="賣出策略"></a>賣出策略</h3><p>當股價收盤價小於 20 日均，則賣出</p><h3 id="回測結果"><a href="#回測結果" class="headerlink" title="回測結果"></a>回測結果</h3><p>本文章所公佈的「新因子」<br>究竟對於這些創新高有什麼樣子的影響呢？</p><center><img src="/break-new-high-roe-stock/compare.png" title="動手做"></center><br>上圖中<br>藍色的數值為使用「新因子」，<br>每次加入3檔股票的方法<br>而橘色的為，「沒有用新因子」，<br>每次加入數檔股票的方法<br><br><strong>效果差距非常多！</strong><br><br>以下是策略的回測相關數值和風險，<br>假如你希望用 Python<br>跟我們一起研究量化投資，<br>可以參加「<a href="https://hahow.in/cr/python-finance" rel="external nofollow noopener noreferrer" target="_blank">小資族選股策略</a>」和「<a href="https://hahow.in/cr/finlab-ml" rel="external nofollow noopener noreferrer" target="_blank">AI股票理專</a>」，<br>一起來研發有用的選股邏輯喔！<br><br>假如你是有加入課程的同學，<br>可以直接使用以下的程式碼開始選股喔！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from finlab.data import Data</span><br><span class="line"></span><br><span class="line">data = Data()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#############</span><br><span class="line"># 股價淨值比  #</span><br><span class="line">#############</span><br><span class="line">price = data.get(&apos;收盤價&apos;, 300)</span><br><span class="line">股東權益 = data.get(&apos;歸屬於母公司業主之權益合計&apos;, 1)</span><br><span class="line">股本 = data.get(&apos;普通股股本&apos;, 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">流通股數 = 股本 / 10</span><br><span class="line">每股淨值 = 股東權益 / 流通股數</span><br><span class="line">今日股價 = price.iloc[-1]</span><br><span class="line"></span><br><span class="line">股價淨值比pb = (今日股價 / 每股淨值).squeeze()</span><br><span class="line"></span><br><span class="line">#####################</span><br><span class="line"># 股東權益報酬率 ROE  #</span><br><span class="line">#####################</span><br><span class="line"></span><br><span class="line">稅後淨利 = data.get(&apos;本期淨利（淨損）&apos;, 2)</span><br><span class="line"></span><br><span class="line"># 股東權益，有兩個名稱，有些公司叫做權益總計，有些叫做權益總額</span><br><span class="line"># 所以得把它們抓出來</span><br><span class="line">權益總計 = data.get(&apos;權益總計&apos;, 2)</span><br><span class="line">權益總額 = data.get(&apos;權益總額&apos;, 2)</span><br><span class="line"></span><br><span class="line"># 並且把它們合併起來</span><br><span class="line">權益總計.fillna(權益總額, inplace=True)</span><br><span class="line"></span><br><span class="line">股東權益報酬率 = 稅後淨利.iloc[-1] / 權益總計.iloc[-1]</span><br><span class="line">股東權益報酬率_上季 = 稅後淨利.iloc[-2] / 權益總計.iloc[-2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#####################</span><br><span class="line"># 成交量  #</span><br><span class="line">#####################</span><br><span class="line">vol = data.get(&apos;成交股數&apos;, 100)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">############</span><br><span class="line"># 篩選股票  #</span><br><span class="line">############</span><br><span class="line"></span><br><span class="line">condition1 = (price.rolling(60).max() == price).iloc[-10:].sum() &gt; 0</span><br><span class="line">condition2 = (股東權益報酬率 &gt; 0.03) &amp; (股東權益報酬率_上季 &gt; 0.01)</span><br><span class="line">condition3 = (price.iloc[-1] &gt; 7) &amp; (vol.iloc[-1] &gt; 100000)</span><br><span class="line">rank = 股東權益報酬率 / 股東權益報酬率_上季 / 股價淨值比pb * (condition1 &amp; condition2 &amp; condition3)</span><br><span class="line"></span><br><span class="line">print(&apos;近10天創新高的股票數量&apos;)</span><br><span class="line">print(condition1.sum())</span><br><span class="line"></span><br><span class="line">print(&apos;rank 前10名的股票&apos;)</span><br><span class="line">print(rank[rank &gt; 0].nlargest(10))</span><br></pre></td></tr></table></figure><br><br>附上策略的回測結果<br>祝大家選股愉快！<br><br><center><img src="/break-new-high-roe-stock/eq.png" title="動手做"></center><br><center><img src="/break-new-high-roe-stock/info.png" title="動手做"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假如你是追高的選股策略，&lt;br&gt;有沒有一種感覺？&lt;br&gt;就是往往創新高的股票，&lt;br&gt;大部分都賠錢，&lt;br&gt;只有少部分賺錢，&lt;/p&gt;
&lt;p&gt;今天我們將介紹一個因子，&lt;br&gt;大幅提昇創新高獲利的效果！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/break-new-high
      
    
    </summary>
    
      <category term="股票策略" scheme="https://www.finlab.tw/categories/%E8%82%A1%E7%A5%A8%E7%AD%96%E7%95%A5/"/>
    
    
      <category term="如何買股票" scheme="https://www.finlab.tw/tags/%E5%A6%82%E4%BD%95%E8%B2%B7%E8%82%A1%E7%A5%A8/"/>
    
      <category term="量化投資" scheme="https://www.finlab.tw/tags/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B3%87/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(9)：入金加密貨幣</title>
    <link href="https://www.finlab.tw/btc-deposit-ways/"/>
    <id>https://www.finlab.tw/btc-deposit-ways/</id>
    <published>2020-05-07T06:50:43.000Z</published>
    <updated>2020-06-05T07:29:51.747Z</updated>
    
    <content type="html"><![CDATA[<p>這陣子加密貨幣大漲，<br>大家都躍躍欲試了吧？<br>但我沒有很開心</p><p>因為價格就是漲漲跌跌<br>漲上去的 - 會下來<br>跌下去的 - 會上去</p><p>不開心<br>就不會難過<br>平心靜氣的投資才是最好的方式<br>（果然文章還沒寫完，就跌了15％XD）</p><p>這個階段，<br>在建構<a href="/btc-deposit-how/">初步的買賣的規劃後</a><br>終於要來買入人生中的第一枚加密貨幣了！</p><p>請不要買太多！！！！<br>假如你下的金額，明天歸零你會心疼<br>那就代表下太多了！</p><p>首先，來看一下<br>入金到交易<br>全部過程總覽：</p><center><img src="/btc-deposit-ways/ways.png" title="ways"></center><p>以台幣來說，可以交易的方式就是以下這幾種：</p><ul><li>透過「簡單買賣」來買加密貨幣</li><li>先入金台幣，再「擇時買賣」加密貨幣</li></ul><p>最主要是以下這四個平台，可以用台幣買加密貨幣喔！</p><h3 id="簡單買賣"><a href="#簡單買賣" class="headerlink" title="簡單買賣"></a>簡單買賣</h3><p><a href="https://www.maicoin.com/" rel="external nofollow noopener noreferrer" target="_blank">Maicoin</a>和<a href="https://www.bitoex.com/" rel="external nofollow noopener noreferrer" target="_blank">Bitoex</a>都是可以簡單買入的平台<br>申請帳號其實很簡單，只要提供</p><ol><li>身份證</li><li>第二證件<br>就可以辦了，因為人工審核需要花一點時間，<br>這段時間就可以來學學<a href="/btc-simple-sma-backtesting/">前面所教的投資方式</a></li></ol><h3 id="擇時買賣"><a href="#擇時買賣" class="headerlink" title="擇時買賣"></a>擇時買賣</h3><p>這類的平台有 <a href="https://max.maicoin.com/signup?r=602dff1a" rel="external nofollow noopener noreferrer" target="_blank">MAX</a> 跟 <a href="https://www.bitopro.com/landing_pages/referral?referrer=7971594176" rel="external nofollow noopener noreferrer" target="_blank">BitoPro</a><br>假如用以上連結註冊會員的話，你可以享手續費8折喔！<br>而我也會收到平台的獎勵，<br>當作是這個免費的課程的支持XD</p><p>以上這兩個平台<br>其實就是 Maicoin 跟 BitoEx 的加強版<br>都是以0成本先入金台幣，再做交易，<br>做交易酌收手續費</p><h3 id="Binance-P2P-直接購買-BTC"><a href="#Binance-P2P-直接購買-BTC" class="headerlink" title="Binance P2P 直接購買 BTC"></a>Binance P2P 直接購買 BTC</h3><p>其實<a href="https://www.binance.com/tw/register?ref=23975897" rel="external nofollow noopener noreferrer" target="_blank">Binance</a>也有提供P2P來購買BTC的方式<br>但是現在只限BTC，沒有USDT，且由於是P2P，交易比較沒有保障</p><h3 id="為什麼要提供多家呢？"><a href="#為什麼要提供多家呢？" class="headerlink" title="為什麼要提供多家呢？"></a>為什麼要提供多家呢？</h3><p>因為多方比對，找出最便宜的入金方式，<br>是很重要的<br>以上四個平台的價格，<br>報價都是不一樣的，<br>所以一定要貨比多家！，<br>另外「簡單買賣」那兩家，<br>入金完全是看該加密貨幣的報價，手續費已經算進去了<br>而「擇時買賣」的平台，是台幣入金不用錢，但是交易要扣0.05%手續費</p><p>假如要交易，我建議一次辦好這四個，<br>反正要上傳的東西都是一樣的！</p><h3 id="這四家都辦好了，要買什麼幣呢？"><a href="#這四家都辦好了，要買什麼幣呢？" class="headerlink" title="這四家都辦好了，要買什麼幣呢？"></a>這四家都辦好了，要買什麼幣呢？</h3><p>可以給你個方向，</p><p>假如你有做超長線交易，<br>那就可以直接買 BTC，<br>不過因為長期持有<br>風險就比較高，請自行斟酌</p><p>假如你想交易波段，<br>那就先買入 USDT，<br>在<a href="/btc-crawler-py/">前幾篇</a>有提到<br>這是跟美金 1:1 的加密貨幣</p><p>之後交易時，在來用 USDT 買賣 BTC</p><h3 id="如何自動交易呢？"><a href="#如何自動交易呢？" class="headerlink" title="如何自動交易呢？"></a>如何自動交易呢？</h3><p>我比較喜歡去成交量大一點的交易平台，<br>這邊我以 Binance 為例，<br>我們將購入的 USDT 轉到 Binance，<br>不論金額，這四個平台都差不多，<br>將會有約 100 元台幣的出金手續費</p><p>下圖以 Maicoin為例，講解一次整體的操作過程，<br>主要分成兩個步驟，</p><ol><li>買入 USDT</li><li>將 USDT 存入 Binance</li></ol><h4 id="1-買入-USDT"><a href="#1-買入-USDT" class="headerlink" title="1. 買入 USDT"></a>1. 買入 USDT</h4><p>首先，我們點選「購買」-&gt;「USDT」，<br>然後輸入，購買的數量，通常我會直接輸入台幣，平台自動換算<br>選擇付款方式，然後按購買<br>跟網拍一樣XDDD</p><h3 id="2-存入-Binance"><a href="#2-存入-Binance" class="headerlink" title="2. 存入 Binance"></a>2. 存入 Binance</h3><p>在Maicoin介面，購買後，選擇「發送」-&gt;「USDT」<br>在Binance介面，選擇「收取」-&gt;「USDT」<br>這時候，Binance就會提供一個虛擬位置，請複製起來，<br>並且在Maicoin的介面上貼上</p><p>以上的步驟，要小心，千萬要選擇 USDT 的「發送」和「收取」<br>不然你的$就會丟失喔！<br>請非常小心，再三確認！</p><p>由於交易鏈不會馬上傳送，會先以區塊的方式保留，<br>所以你暫時會看到，你的兩邊存款都是0，XDD<br>但不用擔心，你的轉帳手續正在驗證中，<br>你可以到 <a href="https://www.omniexplorer.info/" rel="external nofollow noopener noreferrer" target="_blank">USDT待驗證區塊的搜尋網站</a><br>輸入帳戶位置，<br>就可以看到正在驗證的交易，<br>所以$沒有丟失啦！</p><p>我建議，假如你想要做波段，並且跟著課程走<br>可以先開戶，<strong>等後面的文章出來了</strong>，<br>先操作小金額，例如500、1000元台幣，測試看看<br>沒錯，小金額就可以架設波段交易程式了！<br>瞭解所有的操作流程，再來考慮增加一點資金。</p><p>下個單元中，我們將教你<br>如何用 Python API<br>在Binance上做 BTC/USDT 的交易！</p><p>可以先申請點下方連結註冊<br><a href="https://www.binance.com/tw/register?ref=HXO25II1" rel="external nofollow noopener noreferrer" target="_blank">https://www.binance.com/tw/register?ref=HXO25II1</a><br>來節省每筆10％的交易手續費，</p><p>我也會收到平台給我的獎勵，<br>來當作是這堂免費課程的收入，<br>那我們就在 Binance 上見囉！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這陣子加密貨幣大漲，&lt;br&gt;大家都躍躍欲試了吧？&lt;br&gt;但我沒有很開心&lt;/p&gt;
&lt;p&gt;因為價格就是漲漲跌跌&lt;br&gt;漲上去的 - 會下來&lt;br&gt;跌下去的 - 會上去&lt;/p&gt;
&lt;p&gt;不開心&lt;br&gt;就不會難過&lt;br&gt;平心靜氣的投資才是最好的方式&lt;br&gt;（果然文章還沒寫完，就跌了1
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(8)：如何投資(投機) 加密貨幣</title>
    <link href="https://www.finlab.tw/btc-deposit-how/"/>
    <id>https://www.finlab.tw/btc-deposit-how/</id>
    <published>2020-05-04T20:23:13.000Z</published>
    <updated>2020-06-05T07:29:50.055Z</updated>
    
    <content type="html"><![CDATA[<p>自從本blog開始介紹 BTC 以來，<br>BTC已經上漲了約25％！<br>我是有稍微選一下發文時機的，<br>很想說自己未卜先知，但世界上沒有這種事情，<br>只能說是個美麗的巧合吧！</p><center><img src="/btc-deposit-how/thumbnail.jpeg" title="thumbnail"></center><p>畢竟所有的指標都是參考用，<br>我們處在瞬息萬變的世界，<br>別想要預測市場<br>而是以最機械的方式來投資<br>才不會無所適從、舉棋不定</p><p>這個單元中，要來介紹，<br>我用哪些方法來投資比特幣，<br>最主要是兩種<br>只是分享，非建議喔！</p><h2 id="1-長線投資"><a href="#1-長線投資" class="headerlink" title="1. 長線投資"></a>1. 長線投資</h2><p>記得在2013年的時候，</p><p>有一個大學生問<br>「我現在有1萬元，要投資什麼比較好？」</p><p>有人回答<br>「買入比特幣，不要管它，等你畢業了再換成現金」</p><p>要是當時真的照這個方法操作，<br>畢業後，基本上就已經財富自由了</p><p>這個故事告訴我們，有時候<br>挑好商品，買了放著，不要亂動，<br>其實也滿好的</p><h3 id="買入的原因"><a href="#買入的原因" class="headerlink" title="買入的原因"></a>買入的原因</h3><p>買 BTC<br>一定是有價格以外的原因，<br>就像是去菜市場買菜，<br>為什麼買這顆蘋果？<br>因為它顏色鮮豔、比較大顆、看起來比較甜，等<br>而不是因為這顆蘋果最近上漲<br>（沒人這樣買蘋果吧？）</p><p>買 BTC 一樣要有理由<br>而不是覺得大家都在買，就跟著買<br>不然，大家都再賣，就跟著賣，<br>很容易就賠錢了</p><h3 id="我的買入原因"><a href="#我的買入原因" class="headerlink" title="我的買入原因"></a>我的買入原因</h3><p>我的買入理由，就是<br>BTC市值當時跟黃金比<br>不到1/50<br>BTC 有著優越的貨幣的特性，<br>理論上應該是很有潛力的</p><p>設定一個出場條件，然後嚴格執行，</p><h3 id="出場條件"><a href="#出場條件" class="headerlink" title="出場條件"></a>出場條件</h3><p>例如我的出場條件就是：<br>BTC 到達跟 黃金市值平起平坐，<br>不過世界上哪有一定準確的預言？<br>所以保險起見可以設定<br>「比特幣：黃金」<br>「市值 1：10」<br>「市值 1：5」<br>「市值 1：2」<br>「市值 1：1」<br>分別出場，這並不是投資建議，<br>只是我自己的規劃而已<br>一定要做賣出條件，因為<br>「不要愛上任何投資的標的」<br>「沒有永遠都上漲的商品」</p><p>達成這個條件之前，<br>我是分批慢慢買入，</p><h3 id="買入條件"><a href="#買入條件" class="headerlink" title="買入條件"></a>買入條件</h3><p>直到金額到達自己投資「單項商品的上限」為止<br>不要壓身家，不要壓身家，不要壓身家！</p><p>畢竟這種超長線，最怕的就是買在高點！<br>而很少人可以準確預測未來股價<br>所以平均分攤風險，是比較建議的</p><p>用以上的方法，<br>價格高高低低，<br>心情也會受影響，<br>所以為何不用「量化投資」來幫助我們獲利呢？</p><h2 id="2-量化投資"><a href="#2-量化投資" class="headerlink" title="2. 量化投資"></a>2. 量化投資</h2><p>量化投資<br>也就是利用程式機械式的操作<br>來避免不必要的風險</p><p>例如<a href="/btc-backtesting-optimization/">前一篇文章所介紹的策略</a></p><p>回測跑得好，<br>策略得開始運轉吧？</p><p>但架設server，<br>還是有一定的難度，<br>為了幫助大家做一個簡單的自動化交易系統，</p><p>接下來的文章，<br>首先我們會介紹 BTC 如何入金，<br>也就是正式開始投資 BTC，</p><p>然後呢，<br>我們會用AWS，也就是Amazon推出的雲端伺服器<br>將<a href="/btc-backtesting-optimization/">前一篇文章所介紹的策略</a>真實上線使用<br>重點是：成本為0，完全免費！</p><p>敬請期待！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自從本blog開始介紹 BTC 以來，&lt;br&gt;BTC已經上漲了約25％！&lt;br&gt;我是有稍微選一下發文時機的，&lt;br&gt;很想說自己未卜先知，但世界上沒有這種事情，&lt;br&gt;只能說是個美麗的巧合吧！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/btc-deposit-how/th
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(7)：三年20倍的策略參數最佳化</title>
    <link href="https://www.finlab.tw/btc-backtesting-optimization/"/>
    <id>https://www.finlab.tw/btc-backtesting-optimization/</id>
    <published>2020-04-26T20:23:13.000Z</published>
    <updated>2020-06-05T07:29:49.945Z</updated>
    
    <content type="html"><![CDATA[<p>這篇文章中，<br>我們將承接著之前的單元，<br>來教大家怎麼做最佳化，</p><center><img src="/btc-backtesting-optimization/thumbnail.jpeg" title="thumbnail"></center><a id="more"></a><p>必備的單元提要：</p><ol><li>環境設定：<a href="/btc-crawler-py/">使用 colab 並且安裝相關 packages</a></li><li>簡單回測：<a href="/btc-simple-sma-backtesting/">利用均線相交產生買賣訊號回測</a></li></ol><p>要執行完上述兩個單元的程式碼<br>才能繼續接下來的單元喔！</p><p>我們將上次的回測程式改成以下的樣子<br>請大家來比較一下有什麼不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> backtesting <span class="keyword">import</span> Backtest</span><br><span class="line"><span class="keyword">from</span> backtesting.lib <span class="keyword">import</span> SignalStrategy</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy</span><span class="params">(SignalStrategy)</span>:</span></span><br><span class="line">    </span><br><span class="line">    n1 = <span class="number">20</span></span><br><span class="line">    n2 = <span class="number">60</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().init()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Precompute the two moving averages</span></span><br><span class="line">        close = pd.Series(self.data.Close)</span><br><span class="line">        sma1 = close.rolling(self.n1).mean()</span><br><span class="line">        sma2 = close.rolling(self.n2).mean()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Precompute signal</span></span><br><span class="line">        signal_long = (sma1 &gt; sma2) &amp; (sma1.shift() &lt; sma2.shift())</span><br><span class="line">        signal_short = (sma1 &lt; sma2) &amp; (sma1.shift() &gt; sma2.shift())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># combine signal</span></span><br><span class="line">        signal = signal_long</span><br><span class="line">        signal[signal_short] = <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># add signal</span></span><br><span class="line">        self.set_signal(signal)</span><br><span class="line"></span><br><span class="line">bt = Backtest(df, Strategy)</span><br><span class="line">result1 = bt.run()</span><br><span class="line">bt.plot()</span><br></pre></td></tr></table></figure><p>沒錯，<br>我們新增了7、8行的物件參數，<br>分別代表兩條均線的參數<br>並且在15、16行，<br>製作均線時，使用該參數來製作均線</p><p>另外我們也在倒數第二行，<br>將回測結果存到 <code>result1</code><br>等等可以做比較</p><p>你應該會看到跟上次一樣的結果：</p><center><img src="/btc-backtesting-optimization/before.png" title="優化前的回測結果"></center><p>接下來就可以自動最佳化了</p><h3 id="暴力枚舉"><a href="#暴力枚舉" class="headerlink" title="暴力枚舉"></a>暴力枚舉</h3><p>你可能以為要寫for迴圈，但其實 backtesting 已經幫你寫好了<br>我們只要將參數範圍傳入 <code>bt.optimize</code><br>就可以了，非常方便：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result2 = bt.optimize(n1=range(<span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>),</span><br><span class="line">                      n2=range(<span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure></p><h3 id="優化後的結果"><a href="#優化後的結果" class="headerlink" title="優化後的結果"></a>優化後的結果</h3><p>由於策略優化完後，參數會自動更新<br>所以我們可以用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bt.plot()</span><br></pre></td></tr></table></figure><br>來看優化後的績效就可以了！</p><center><img src="/btc-backtesting-optimization/after.png" title="優化後的回測結果"></center><p>三年半 20 倍，是不是很夢幻呀！而且還多空都賺<br>拿量化交易的方式交易比特幣，<br>就像是拿大砲對付刀劍一樣</p><p>我們可以將優化前後的績效比對一下，<br>真的差很多呢！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result1._trade_data.Equity.plot()</span><br><span class="line">result2._trade_data.Equity.plot()</span><br></pre></td></tr></table></figure><center><img src="/btc-backtesting-optimization/compare.png" title="比較不同的績效"></center><p>但隨著期貨市場的開放<br>這樣的績效，或許沒辦法重現，<br>或許市場已經慢慢走向效率化，<br>可以看到2019年以後，賺得比較少</p><p>但是加密貨幣又不是只有 BTC，<br>一定有很多未開發的地帶，<br>等著量化交易去開拓的！<br>所以也不用太擔心！</p><p>這些單元的用意<br>就是在你在開江闢土時<br>提供你豐富的資源，<br>讓你在開發策略事半功倍！</p><p>更新：很多人都躍躍欲試呢！<br>我幫大家寫好完整的代碼，可以在線上直接運行喔！<br><a href="https://colab.research.google.com/drive/1ESztR0DvBGQNRml_hpPWMkgXNJ2dmdUa?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">請點此</a></p><p>你可以到<a href="https://www.facebook.com/finlab.python/" rel="external nofollow noopener noreferrer" target="_blank">FinLab粉專</a><br>點選追蹤，或點讚，就可以收到我們的新單元囉！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這篇文章中，&lt;br&gt;我們將承接著之前的單元，&lt;br&gt;來教大家怎麼做最佳化，&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/btc-backtesting-optimization/thumbnail.jpeg&quot; title=&quot;thumbnail&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(6)：比特幣操作最強指標(看盤篇)</title>
    <link href="https://www.finlab.tw/btc-tradingview-intro/"/>
    <id>https://www.finlab.tw/btc-tradingview-intro/</id>
    <published>2020-04-26T03:44:58.000Z</published>
    <updated>2020-06-05T07:29:49.223Z</updated>
    
    <content type="html"><![CDATA[<p>我們當然可以用 Python 來幫我們做分析<br>但是人都是懶惰的，<br>假如有好用的工具，<br>即使不是 Python 也沒關係</p><p>這篇文章接續前一篇，將來一探究竟<br>究竟這個好用的指標怎麼看</p><center><img src="/btc-tradingview-intro/ind.png" title="thumbnail"></center><h3 id="TradingView"><a href="#TradingView" class="headerlink" title="TradingView"></a>TradingView</h3><p>介紹一款我覺得很好用的平台，<a href="https://tw.tradingview.com/" rel="external nofollow noopener noreferrer" target="_blank">TradingView</a><br>這並不是業配，只是真的滿好用的<br>以加密貨幣來說，我都會用它來看盤</p><p>可以在商品代碼中，輸入「BTCUSDT」來搜尋比特幣的價格</p><center><img src="/btc-tradingview-intro/search.png" title="search"></center><br>並且按一下全功能圖表<br><center><img src="/btc-tradingview-intro/panel.png" title="search"></center><p>這時候就會跳出這檔商品的技術分析圖表<br>然後我們再上方功能列表，可以點選「fx」來添加技術指標</p><center><img src="/btc-tradingview-intro/bar.png" title="bar"></center><br>這些是別人已經寫好<br>並且開源的技術指標<br>可以直接拿來用<br><br># <strong>Hash Ribbons 指標</strong><br><br>接下來，搜尋並點選「Hash Ribbon」就可以看到這個指標了！<br>你應該會看到以下的圖表<br><center><img src="/btc-tradingview-intro/ind.png" title="indicator"></center><p>可以看到「Hash Ribbon」這張圖表中<br>綠色像是階梯狀的數值，就是「Hash rate」<br>也就是「所有的挖礦機」的算力總和<br>也就是每秒可以暴力解多少次<br>可以參考<a href>之前的文章</a><br>瞭解更多原理的部分</p><p>另外有兩條均線，分別是淺綠色，跟灰色，<br>分別是30日和60日均線，<br>這些數字我們不用調整，用它預設的即可</p><p>另外有紅色的區域，<br>從均線的死亡交叉開始出現<br>代表 Miner Capitulation 發生的時刻<br>此時比特幣會進入超跌的狀態，</p><p>最後當紅色區域的末稍，<br>也就是均線黃金交叉時<br>代表礦工恢復運作，<br>通常在這個時候買入<br>近三年的平均來說，會有約5000％的報酬</p><p>當然歷史不代表未來<br>不論部落格提供怎麼樣的訊息<br>你還是得自己做決定</p><p>比特幣波動是非常大的<br>起床發現突然下跌 30％<br>都是可能的</p><p>以長期投資而言，<br>注重風險的讀者，<br>真的不能下注太大呀！</p><p>注：<br>另外假如要看 BTC 的長期價格，<br>可以用 tradingview 搜尋 「BLX」<br>就可以找到了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我們當然可以用 Python 來幫我們做分析&lt;br&gt;但是人都是懶惰的，&lt;br&gt;假如有好用的工具，&lt;br&gt;即使不是 Python 也沒關係&lt;/p&gt;
&lt;p&gt;這篇文章接續前一篇，將來一探究竟&lt;br&gt;究竟這個好用的指標怎麼看&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/btc-t
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(5)：比特幣操作最強指標(原理篇)</title>
    <link href="https://www.finlab.tw/best-indicator-bitcoin/"/>
    <id>https://www.finlab.tw/best-indicator-bitcoin/</id>
    <published>2020-04-25T07:36:15.000Z</published>
    <updated>2020-06-05T07:29:51.633Z</updated>
    
    <content type="html"><![CDATA[<p>這是臨時加開的一篇文章<br>主要是因為<br><strong>就在今天</strong><br>有個非常準的比特幣上漲指標<br>發生了罕見的重磅訊號！</p><center><img src="/best-indicator-bitcoin/thumbnail.jpeg" title="thumbnail"></center><p>近三年，只要這個指標產生買入訊號，<br>平均來說，<strong>比特幣上漲幅度為 5000％</strong></p><p>這個指標的原理是什麼呢？<br>首先我們要介紹幾個名詞：</p><h3 id="1-Miner-挖礦機"><a href="#1-Miner-挖礦機" class="headerlink" title="1. Miner 挖礦機"></a>1. Miner 挖礦機</h3><p>比特幣的運作機制，<br>是讓所有的電腦互相競爭，看誰最快產生一串隨機字串 s，<br>使得以下公式<br><code>hash = sha256(phash + leger + s)</code><br>中 hash 的開頭「 n 個 0 」，</p><p>其中 <code>phash</code> 就是前一個 block（區塊）的 hash<br><code>leger</code> 是待驗證的 BTC 交易帳本，<br><code>sha256</code> 是一個<strong>不可逆的加密函數</strong></p><p>不可逆函數意味著<br>我們不可能反推s是多少，<br>而是必需要用暴力法，硬猜 s 是多少，<br>一個個嘗試，直到成功為止</p><p>專門在嘗試暴力法枚舉的電腦，我們就稱為「挖礦機」</p><h3 id="2-為何要找-s-？-感覺很沒意義"><a href="#2-為何要找-s-？-感覺很沒意義" class="headerlink" title="2. 為何要找 s ？ 感覺很沒意義"></a>2. 為何要找 s ？ 感覺很沒意義</h3><p>因為這樣子，我們就可以驗證此帳本是真的<br>這種驗證機智叫做 <strong>proof-of-work</strong><br>也就是用電腦的勞力<br>來確保紀錄的資料不受串改，</p><p>舉個例子，假如今天某駭客想上傳一個假的block，<br>這個時候，他必須先解出 上述 <code>s</code> 是多少，<br>還必須將下一個block的 <code>s</code> 也算出來，<br>和下下個 block 的 <code>s</code><br>和下下下個 block 的 <code>s</code><br>…等<br>直到其他電腦承認他的那條「假區塊鏈」為止，</p><p>也就是這個駭客的電腦算力，<br>必須跟其他正規礦機的算力總和披敵，<br>並且持續非常長的一段時間都能戰勝<strong>正規礦機的總和</strong><br>才有辦法將假的block驗證成功，</p><h3 id="3-Miner-Capitulation-礦機的投降"><a href="#3-Miner-Capitulation-礦機的投降" class="headerlink" title="3. Miner Capitulation 礦機的投降"></a>3. Miner Capitulation 礦機的投降</h3><p>為什麼會有人想挖礦？<br>因為辛苦挖礦<br>可以獲得新發行的比特幣</p><p>但當今天比特幣價格下降，<br>導致挖礦獲利減少時，<br>礦工挖礦成本 大於 挖到的比特幣價值<br>有些礦工乾脆就不運轉，<br>或是賣掉BTC去添購新的挖礦機型<br>也就是 Miner Capitulation</p><h3 id="4-Miner-Capitulation-是好的買入機會"><a href="#4-Miner-Capitulation-是好的買入機會" class="headerlink" title="4. Miner Capitulation 是好的買入機會"></a>4. Miner Capitulation 是好的買入機會</h3><p>Miner Capitulation<br>通常發生在 BTC 價格下跌時<br>BTC 的價格跌破了挖礦成本開始</p><p>很多的礦機持有者，<br>在這個時候</p><ol><li>賣掉已經挖到的 BTC 來購買新的礦機</li><li>乾脆機器收一收，BTC賣一賣了結出場</li></ol><p>就會引發一系列超賣</p><h3 id="5-如何判斷-Miner-Capitulation？"><a href="#5-如何判斷-Miner-Capitulation？" class="headerlink" title="5. 如何判斷 Miner Capitulation？"></a>5. 如何判斷 Miner Capitulation？</h3><p>我們可以從BTC調整「挖礦的困難程度」<br>來當成 Miner Capitulation 的延遲指標</p><p>因為這個「挖礦難易程度」會動態調整的：<br>根據比特幣白皮書<br>一個 block 的出產時間<br>必須在約10分鐘左右</p><p>所以當礦機很多時，算力上升，<br>這樣用暴力法找 <code>s</code> 的速度就會變快<br>所以找 <code>s</code> 難度也必須提升才行</p><p>還記得 hash 開頭必須包含 n 個 0 嗎？<br>這個 n 就可以用來控制難度，<br>當 n 越大，代表要產生越多開頭為 0 的 hash<br>而難度也會跟著加大</p><h3 id="6-我們可以藉由-n-來推算-hash-rate"><a href="#6-我們可以藉由-n-來推算-hash-rate" class="headerlink" title="6. 我們可以藉由 n 來推算 hash rate"></a>6. 我們可以藉由 n 來推算 hash rate</h3><p>hash rate 就是比特幣網路的算力，<br>每秒可以暴力解 x 次<br>這個 hash rate 降低，也代表著礦工的退出，<br>礦工退出，就會將 BTC 兌現<br>BTC 就會有比較大的跌幅</p><p>而當 hash rate 反轉升高時<br>就代表礦機更新完畢、礦場被整併，新礦機上線<br>近三年，這樣子的狀況，比特幣都有不錯的報酬<br>如今這個訊號也發生了，<br>就不知道接下來歷史會不會重演呢？</p><p>下一集將分享怎麼用 trading view 來開啟<br>hash  rate 訊號買賣點！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這是臨時加開的一篇文章&lt;br&gt;主要是因為&lt;br&gt;&lt;strong&gt;就在今天&lt;/strong&gt;&lt;br&gt;有個非常準的比特幣上漲指標&lt;br&gt;發生了罕見的重磅訊號！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/best-indicator-bitcoin/thumbnail.jpe
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(4)：實做回測策略</title>
    <link href="https://www.finlab.tw/btc-simple-sma-backtesting/"/>
    <id>https://www.finlab.tw/btc-simple-sma-backtesting/</id>
    <published>2020-04-25T00:54:09.000Z</published>
    <updated>2020-06-05T07:29:49.546Z</updated>
    
    <content type="html"><![CDATA[<p>接下來我們廢話不多說，<br>結合前一篇的買賣訊號<br>來建構一個加密貨幣的策略吧！</p><center><img src="/btc-simple-sma-backtesting/thumbnail.jpeg" title="info"></center><h3 id="複習前幾篇的知識"><a href="#複習前幾篇的知識" class="headerlink" title="複習前幾篇的知識"></a>複習前幾篇的知識</h3><p>這篇文章，將接續著之前的單元，<br>假如還沒看過前面的部分<br>可以參考以下的連結喔！</p><ol><li><a href="/python-bitcoin-trading-why-bitcoin/">為什麼要投資加密貨幣</a></li><li><a href="/btc-crawler-py/">加密貨幣爬蟲</a></li><li><a href="/btc-trading-signal/">策略訊號建立</a></li></ol><p>這篇我寫的比較仔細一點，所以文章稍長，但程式碼很短，先給大家聞香一下</p><center><img src="/btc-simple-sma-backtesting/result.png" title="回測結果統計"></center><br>想知道怎麼做出來，要看到最後喔！<br><br>將上一篇的程式碼統整，我們可以得到<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal_long = (sma1 &gt; sma2) &amp; (sma1.shift() &lt; sma2.shift())</span><br><span class="line">signal_short = (sma1 &lt; sma2) &amp; (sma1.shift() &gt; sma2.shift())</span><br></pre></td></tr></table></figure><br><br>接下來，我們將 <code>signal_long</code> 跟 <code>signal_short</code> 整合在一起<br>這邊的 <code>signal_long</code> 跟 <code>signal_short</code><br>是進場訊號，一個做多、一個是做空 的時間序列<br>當訊號為 True 時代表入場<br><br><strong> 多空訊號結合 </strong><br><br>接下來為了配合 backtesting 函式庫<br>我們想將 <code>signal_long</code> 跟 <code>signal_short</code> 合併起來<br>產生一個翻轉策略：<br>當 <code>signal_long</code> 為 True 時，不論目前有什麼部位，都翻多<br>當 <code>signal_short</code> 為 True 時，不論目前什麼部位，一律翻空<br>我們想要做出一個新的訊號 叫做 <code>signal</code><br>其做多訊號為 1，做空訊號為 -1 ，維持不變則為0<br><br>可以用以下的寫法，首先copy <code>signal_long</code> 序列，<br>並且將 <code>signal_short</code> 為 True 的部分改成 <code>-1</code><br>這樣就可以了！<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># combine long and short signal</span></span><br><span class="line">signal = signal_long.copy()</span><br><span class="line">signal[signal_short] = <span class="number">-1</span></span><br></pre></td></tr></table></figure><br><br><center><img src="/btc-simple-sma-backtesting/signal.png" title="交易訊號"></center><p>完整總和來說，我們目前已經有以下的程式碼，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> finlab <span class="keyword">import</span> crypto</span><br><span class="line"></span><br><span class="line"><span class="comment"># geth the historical price</span></span><br><span class="line">df = crypto.get_all_binance(<span class="string">'BTCUSDT'</span>, <span class="string">'4h'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate moving averages</span></span><br><span class="line">sma1 = df.Close.rolling(<span class="number">20</span>).mean()</span><br><span class="line">sma2 = df.Close.rolling(<span class="number">60</span>).mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># create long and short signal</span></span><br><span class="line">signal_long = (sma1 &gt; sma2) &amp; (sma1.shift() &lt; sma2.shift())</span><br><span class="line">signal_short = (sma1 &lt; sma2) &amp; (sma1.shift() &gt; sma2.shift())</span><br><span class="line"></span><br><span class="line"><span class="comment"># combine long and short signal</span></span><br><span class="line">signal = signal_long.copy()</span><br><span class="line">signal[signal_short] = <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>接下來我們直接比對一下，回測的程式碼，<br>橘色部分比較特別，會逐一介紹</p><center><img src="/btc-simple-sma-backtesting/code.png" title="程式碼的部分"></center><br>(先不急著抄寫，文末會附上完整代碼)<br><br>首先，上圖中第一二行，我們將 Backtest 和 SignalStrategy 匯入<br>Backtest 是一個幫我們回測的 interface，<br>而 <code>SignalStrategy</code> 是一個 class<br>我們可以繼承 <code>SignalStrategy</code> (第5行)<br>就能把剛剛的訊號 <code>signal</code> 匯入來回測<br>這邊會用到物件導向的概念，可以參考<br><a href="https://www.w3schools.com/python/python_classes.asp" rel="external nofollow noopener noreferrer" target="_blank">w3c提供的簡單 python 物件導向教學</a><br><br>有了一個strategy空殼，接下來就可以實做內部功能了<br><br>第7行中，我們覆寫一個parent 方法，叫做 <code>init</code>，<br>在 <code>init</code> 這個方法中，我們可以計算回測要用的訊號<br>這個方法會在<strong>回測開始前執行一次</strong><br>所以當我們先把訊號計算好<br>這樣回測的時候就不用計算，速度上會比較快<br><br><code>init</code>中大部分的程式碼，<br>跟我們開頭所述的非常雷同，<br>有幾點不一樣而已：<br><br>首先，在第8行中<br>parent class 會先執行他的 <code>init</code><br>你可以想像，父母先吃飯，小孩再吃飯的道理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super().init()</span><br></pre></td></tr></table></figure><br><br>然後，第11行，也做了一點修正，從原本的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原本的</span></span><br><span class="line">df = crypto.get_all_binance(<span class="string">'BTCUSDT'</span>, <span class="string">'4h'</span>)</span><br></pre></td></tr></table></figure><br>變成<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新的</span></span><br><span class="line">close = pd.Series(self.data.Close)</span><br></pre></td></tr></table></figure><br><br>我們可以用 <code>self.data.Close</code> 來獲取「開高低收」的歷史價格<br>這是繼承 <code>SignalStrategy</code> 附加的功能<br>可以讓程式碼中的「策略」跟「價格」解耦<br>讓策略不只交易 <code>BTCUSDT</code><br>還能交易其他加密貨幣，甚至是股票！<br><br>最後12～21行，都跟之前一樣，所以就略過囉！<br><br>最後的24行，就是將我們產生的 <code>signal</code> 給匯入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elf.set_signal(signal)</span><br></pre></td></tr></table></figure><br>這樣子 <code>SignalStrategy</code> 裡面就會根據 <code>signal</code><br>來進行翻多翻空的交易囉！<br><br>上述 1～26 行，都是一個策略藍圖，我們只是規劃，並沒有真正執行這些程式碼<br>所以我們還要額外家三行，建構出規劃好的策略，並且回測、統計回測結果：<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bt = Backtest(df, Strategy)</span><br><span class="line">bt.run()</span><br><span class="line">bt.plot()</span><br></pre></td></tr></table></figure><br><br><center><img src="/btc-simple-sma-backtesting/result.png" title="回測結果統計"></center><p>執行後會顯示出非常詳細的買賣點，<br>這個就是所謂 <del>窮人版</del> python 版的 multicharts 了吧！<br>不過看起來策略的 <code>performnace</code> 不太好，賺不到什麼 $$<br>所以下一個單元，我們就來使用內建的 optimize 方法，<br>找尋最優的均線交叉策略！優化後的績效，先給大家聞香一下</p><p><center><img src="/btc-simple-sma-backtesting/opt.png" title="回測結果統計優化後"></center><br>敬請期待！</p><p>以下是完整的程式碼：<br>另外也可以參考完整的 <a href="https://colab.research.google.com/drive/1ZUst2gJfBSxrdhw2aBdr_OJn6uMdDabi" rel="external nofollow noopener noreferrer" target="_blank">colab notebook 範例</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> finlab <span class="keyword">import</span> crypto</span><br><span class="line"><span class="keyword">from</span> backtesting <span class="keyword">import</span> Backtest</span><br><span class="line"><span class="keyword">from</span> backtesting.lib <span class="keyword">import</span> SignalStrategy</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = crypto.get_all_binance(<span class="string">'BTCUSDT'</span>, <span class="string">'4h'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy</span><span class="params">(SignalStrategy)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().init()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Precompute the two moving averages</span></span><br><span class="line">        close = pd.Series(self.data.Close)</span><br><span class="line">        sma1 = close.rolling(<span class="number">20</span>).mean()</span><br><span class="line">        sma2 = close.rolling(<span class="number">60</span>).mean()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Precompute signal</span></span><br><span class="line">        signal_long = (sma1 &gt; sma2) &amp; (sma1.shift() &lt; sma2.shift())</span><br><span class="line">        signal_short = (sma1 &lt; sma2) &amp; (sma1.shift() &gt; sma2.shift())</span><br><span class="line">        </span><br><span class="line">        signal = signal_long</span><br><span class="line">        signal[signal_short] = <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        self.set_signal(signal)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().next()</span><br><span class="line"></span><br><span class="line">bt = Backtest(df, Strategy)</span><br><span class="line">bt.run()</span><br><span class="line">bt.plot()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接下來我們廢話不多說，&lt;br&gt;結合前一篇的買賣訊號&lt;br&gt;來建構一個加密貨幣的策略吧！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/btc-simple-sma-backtesting/thumbnail.jpeg&quot; title=&quot;info&quot;&gt;&lt;/center&gt;

&lt;h3
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(3)：交易策略訊號實做</title>
    <link href="https://www.finlab.tw/btc-trading-signal/"/>
    <id>https://www.finlab.tw/btc-trading-signal/</id>
    <published>2020-04-23T20:20:56.000Z</published>
    <updated>2020-06-07T16:02:10.914Z</updated>
    
    <content type="html"><![CDATA[<p>這篇文章中，我們將用 pandas 來做一個簡易的交易訊號，</p><p>Pandas 是一個資料處理用的 Package<br>專門用來做資料處理，<br>你可以想像它是 python 裡面的 excel，<br>可以產生並且處理各式各樣的表格</p><h3 id="Pandas-操作介紹"><a href="#Pandas-操作介紹" class="headerlink" title="Pandas 操作介紹"></a>Pandas 操作介紹</h3><p>承接著<a href="/btc-crawler-py/">上一篇文章</a>，<br>我們繼續在 <a href="https://colab.research.google.com/" rel="external nofollow noopener noreferrer" target="_blank">google colab</a> 上進行程式的實驗<br>此時的 <code>df</code> 已經是歷史資料</p><center><img src="/btc-trading-signal/df.png" title="dataframe"></center><p>就是一個 <code>pandas.DataFrame</code> 物件<br>這個物件就像是 excel 表格一樣<br>有很多的行跟列</p><p>每一個列都可以簡單的呼叫出來，<br>以我們的例子，每一列都是一個時間序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.Close</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/series.png" title="時間序列"></center><p>由上圖可知，每一列也是一種物件<br>叫做 <code>pd.Series</code>，<br>這種物件，就是一條序列，<br>可以想像是excel的單一一列的意思</p><h3 id="製作簡易的均線策略"><a href="#製作簡易的均線策略" class="headerlink" title="製作簡易的均線策略"></a>製作簡易的均線策略</h3><p><code>pd.Series</code>有很多特別的功能<br>例如計算移動窗格，我們可以用<br><code>pd.Series.rolling()</code><br>來產生移動窗格，並且用<br><code>pd.Series.rolling().mean()</code><br>來產生這個移動窗格的平均數<br>從時間序列的角度<br>這個就是「均線」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sma1 = df.Close.rolling(<span class="number">20</span>).mean()</span><br><span class="line">sma2 = df.Close.rolling(<span class="number">60</span>).mean()</span><br><span class="line"></span><br><span class="line">df.Close.plot()</span><br><span class="line">sma1.plot()</span><br><span class="line">sma2.plot()</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/sma_plot.png" title="SMA"></center><p>上圖中，我們將<code>BTCUSDT</code>的歷史紀錄 與兩條均線畫出來<br>會發現，時間跨度太大，導致價格跟均線看不清楚，<br>我們可以額外 zoom in 選取「某年」來觀察，<br>可以使用中括號來選取時間範圍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.Close[<span class="string">'2020'</span>].plot()</span><br><span class="line">sma1[<span class="string">'2020'</span>].plot()</span><br><span class="line">sma2[<span class="string">'2020'</span>].plot()</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/sma_plot2019.png" title="2019SMA"></center><p>接下來，我們來設計交易訊號<br>我們希望做一個簡單的均線策略：</p><p>假如短週期均線 <code>sma1</code> 超過 長週期 <code>sma2</code> -&gt; 做多<br>反之做空</p><p>要怎麼做出這樣的訊號呢？我們可以用不等式來進行，</p><h3 id="不等式條件"><a href="#不等式條件" class="headerlink" title="不等式條件"></a>不等式條件</h3><p>不等式，就是所謂的「大於等於小於」，<br>我們假如將兩條時間序列做不等式運算，</p><p>在這兩條時間序列中，每一個元素會被一一拿出來比對，<br>並且產生出新的「布林」時間序列：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">condition = sma1 &gt; sma2</span><br><span class="line">condition</span><br></pre></td></tr></table></figure></p><center><img src="/btc-trading-signal/condition.png" title="布林序列"></center><p>上圖中就是布林時間序列，每個時間點對映到「Ture」或是「False」<br>假如今天條件成立，也就是「sma1 &gt; sma2」的話<br>該時間點對映到的就會是 True<br>反之則是 False</p><p>因為我們是均線突破策略，<br>要怎麼結合不等式，來產生均線突破條件呢？我們還需要<br><code>pd.Series.shift</code><br>這個功能</p><h3 id="調用「昨天」的價格-pd-Series-shift"><a href="#調用「昨天」的價格-pd-Series-shift" class="headerlink" title="調用「昨天」的價格 pd.Series.shift"></a>調用「昨天」的價格 pd.Series.shift</h3><p><code>pd.Series.shift</code>是一個好用的function，<br>可以將時間序列全部都往後延遲一天，例如以下的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(df.Close)</span><br><span class="line">print(df.Close.shift(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><center><img src="/btc-trading-signal/shift.png" title="shift範例"></center><p>你會發現兩者相差一天，<br>所以在做策略時，我會傾向於，將<code>pd.Series.shift(n)</code><br>當作是「n個時間單位前的價格」，<br>這邊我們用的是 ‘4h’ 4小時的歷史價格<br>所以<br><code>pd.Series.shift(1)</code><br>就是4小時前，<br>而<br><code>pd.Series.shift(2)</code><br>就是8小時前<br>以此類推</p><p>假如我們只使用<br><code>pd.Series.shift()</code><br>n 不設定參數的話<br>pandas 會預設 <code>n=1</code> 喔！</p><h3 id="結合上述的範例，產生策略訊號"><a href="#結合上述的範例，產生策略訊號" class="headerlink" title="結合上述的範例，產生策略訊號"></a>結合上述的範例，產生策略訊號</h3><p>我們希望的做出來的邏輯：<br>做多: 當(今天短週期均線 &gt; 今天長週期均線) 且 (昨天短週期均線 &lt; 昨天長週期均線)<br>做空: 當(今天短週期均線 &lt; 今天長週期均線) 且 (昨天短週期均線 &gt; 昨天長週期均線)</p><p>我們可以將上述中文，對映到以下的程式碼：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal_long = (sma1 &gt; sma2) &amp; (sma1.shift() &lt; sma2.shift())</span><br><span class="line">signal_short = (sma1 &lt; sma2) &amp; (sma1.shift() &gt; sma2.shift())</span><br></pre></td></tr></table></figure></p><p>上述程式碼中的 <code>&amp;</code> 就是「且」的意思</p><p>我們可以將訊號繪製出來：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal_long.astype(int).plot()</span><br><span class="line">(-signal_short.astype(int)).plot()</span><br></pre></td></tr></table></figure></p><center><img src="/btc-trading-signal/signal.png" title="交易訊號"></center><p>以上這張圖我用 -1 顯示 賣出訊號，而 1 是買進訊號<br>當我們將 True False 轉換成 int 時，<br>會轉換成「1」跟「0」的數值</p><h3 id="製作策略"><a href="#製作策略" class="headerlink" title="製作策略"></a>製作策略</h3><p>然而我們怎麼知道<br>照著這個交易訊號操作<br>實際的績效是怎麼樣呢？<br>下一個單元中，會教大家怎麼用 <a href="https://github.com/kernc/backtesting.py" rel="external nofollow noopener noreferrer" target="_blank">backtesting</a> 這個 package<br>來實做回測，<br>模擬這個策略的績效<br>敬請期待！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這篇文章中，我們將用 pandas 來做一個簡易的交易訊號，&lt;/p&gt;
&lt;p&gt;Pandas 是一個資料處理用的 Package&lt;br&gt;專門用來做資料處理，&lt;br&gt;你可以想像它是 python 裡面的 excel，&lt;br&gt;可以產生並且處理各式各樣的表格&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(2)：爬蟲下載歷史數據</title>
    <link href="https://www.finlab.tw/btc-crawler-py/"/>
    <id>https://www.finlab.tw/btc-crawler-py/</id>
    <published>2020-04-22T20:42:33.000Z</published>
    <updated>2020-06-05T07:29:49.313Z</updated>
    
    <content type="html"><![CDATA[<p>這個單元，<br>分享如何獲取比特幣歷史價格</p><p>可以打開<a href="https://colab.research.google.com/" rel="external nofollow noopener noreferrer" target="_blank">colab</a>線上編輯python跟我們一起做實驗吧！<br>colab 是 google 提供，線上運行 python 的平台<br>打開後，新增一個notebook<br>直接一步步貼上下面的代碼<br>程式就會順利運行了</p><center><img src="/btc-crawler-py/thumbnail.png" title="info"></center><h3 id="獲取-python-函式庫"><a href="#獲取-python-函式庫" class="headerlink" title="獲取 python 函式庫"></a>獲取 python 函式庫</h3><p>首先，我們要先獲取幫大家寫好的 package 可以到github上下載<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!git clone https://github.com/koreal6803/crypto_backtrader.git</span><br><span class="line">%cd crypto_backtrader</span><br></pre></td></tr></table></figure></p><p>上面的指令，會先將預先寫好的程式從 github 上下載下來<br>並且將目錄切換到 crypto_backtrader<br>也就是下載下來的資料夾中</p><h3 id="安裝一些必要的packages"><a href="#安裝一些必要的packages" class="headerlink" title="安裝一些必要的packages"></a>安裝一些必要的packages</h3><p>接下來我們來安裝一些必要的 dependencies<br>這樣等會才能順利執行程式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!pip install python-binance</span><br><span class="line">!pip install bitmex</span><br><span class="line">!pip install Backtesting</span><br><span class="line">!pip install backtrader</span><br></pre></td></tr></table></figure><h3 id="加密貨幣命名方法"><a href="#加密貨幣命名方法" class="headerlink" title="加密貨幣命名方法"></a>加密貨幣命名方法</h3><p>這篇文章中，我們爬取 <code>BTCUSDT</code> 的價格<br><code>BTCUSDT</code> 這個 symbol 可以拆逞兩個部分<br>一個是 <code>BTC</code>、另一個是 <code>USDT</code><br><code>BTCUSDT</code> 代表，<code>BTC</code> 的價格，以 <code>USDT</code> 為單位，<br>這邊為什麼我們要用 <code>USDT</code> 呢？因為他是跟 <code>USD</code> 是美元是表兄弟，<br><code>USDT</code> 是一種跟 <code>USD</code> 約略 1:1 兌換的穩定虛擬貨幣<br><code>USDT</code> 的好處是</p><p>在交易時，假如用 加密貨幣 和 法定貨幣（美元）來回交易<br>這種方式交易，手續費會非常高昂<br>例如我們以 Maicoin 買入跟賣出手續費約高達 1%，</p><p>今天我們假如使用 <code>BTCUSDT</code> pair 來交易<br>由於同樣是加密貨幣，所以手續費算是大幅的降低，<br>目前手續費在各平台，一般的標準是0.1%，根據平台的優惠、交易量可以打折，<br>成本算是低很多，</p><p><a href="http://blog.udn.com/mashmoro980727/121661372" rel="external nofollow noopener noreferrer" target="_blank">交易對(trading pair)的相關介紹</a></p><p>那廢話不多說，趕快來下載歷史資料吧！</p><h3 id="使用幫大家寫好的函式庫"><a href="#使用幫大家寫好的函式庫" class="headerlink" title="使用幫大家寫好的函式庫"></a>使用幫大家寫好的函式庫</h3><p>我們可以使用<br><code>from finlab import crypto</code><br>將一些好用的 function 給叫進來</p><p>然後用<br><code>crypto.get_all_binance</code> 這個 function<br>來獲取交易對(trading pair)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from finlab import crypto</span><br><span class="line">df = crypto.get_all_binance(&apos;BTCUSDT&apos;, &apos;4h&apos;)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><center><img src="/btc-crawler-py/df.png" title="dataframe 結果"></center><p>上述這個 <code>get_all_binance</code><br>除了幫你整理好下載資料外，<br>還會將這些資料資料，存在 <code>crypto_backtrader/history/crypto/</code> 當中<br>以 <code>csv</code> 的方式存起來<br>方便你用 <code>excel</code>、<code>multicharts</code> 等程式來打開</p><p>你也可以輸入不同的 trading pair 名稱，可以<a href="https://www.binance.com/tw/markets" rel="external nofollow noopener noreferrer" target="_blank">binance官網</a>查找</p><p>下一步，我們會分享<br>怎麼用 Python 回測一個簡單的 <code>BTCUSDT</code> 交易策略！<br>敬請期待！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這個單元，&lt;br&gt;分享如何獲取比特幣歷史價格&lt;/p&gt;
&lt;p&gt;可以打開&lt;a href=&quot;https://colab.research.google.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>用Python投資加密貨幣(1)：為什麼是比特幣？</title>
    <link href="https://www.finlab.tw/python-bitcoin-trading-why-bitcoin/"/>
    <id>https://www.finlab.tw/python-bitcoin-trading-why-bitcoin/</id>
    <published>2020-04-20T06:09:14.000Z</published>
    <updated>2020-04-25T02:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>原本想說開一個課程<br>介紹加密貨幣做portfolio selection<br>不過因為種種因素<br>決定還是寫成免費一系列的文章<br>介紹用 Python 建置 比特幣 交易系統</p><p>新科技<br>如 machine learning、blockchain，<br>或許可以說「有缺點」、「不成熟」、「尚未完善」<br>但同時也是<strong>充滿機會</strong>的地方！<br>不論這是投資還是投機<br>我都會想要試試看<br>這可以說是<br>我對於<strong>程式和科技的執著</strong>吧！</p><p>我想研究比特幣 可以分成三個原因：</p><h3 id="1-隨著時間推移"><a href="#1-隨著時間推移" class="headerlink" title="1. 隨著時間推移"></a>1. 隨著時間推移</h3><h3 id="科技的進步是很可怕的！"><a href="#科技的進步是很可怕的！" class="headerlink" title="科技的進步是很可怕的！"></a>科技的進步是很可怕的！</h3><p>你絕對沒辦法想像<br>30年前，大家對個人電腦嗤之以鼻：<br>「翻書1秒鐘，開機卻要3分鐘！」<br>「書 比 電腦 要方便太多了！」<br>「沒有理由大家需要電腦呀！」</p><p>今天，每個人口袋都有一台…</p><p><strong>加密貨幣，會不會就是30年前的筆電呢？</strong><br>可能會，可能不會，</p><p>不過可以當作是買保險，因為</p><h3 id="2-我們生活在安逸的年代"><a href="#2-我們生活在安逸的年代" class="headerlink" title="2. 我們生活在安逸的年代"></a>2. 我們生活在安逸的年代</h3><h3 id="居安思危是很重要的"><a href="#居安思危是很重要的" class="headerlink" title="居安思危是很重要的"></a>居安思危是很重要的</h3><p>人類的歷史，充滿戰爭，<br>很多人因此顛沛流離，<br>這80年以來，是世界上最和平的一段日子，<br>究竟是人類越來越文明？<br>還是說世界的動盪 就像是經濟一樣會循環，<br>我們剛好處在和平的週期？</p><p>設想你最糟糕的狀況：<br>房子被強制徵收、國家貨幣大幅貶值、<br>臨時離開住所，輕裝逃往其他國家，</p><p>要是這些事情都發生了，<br>你可以什麼都沒有 什麼都不帶<br><strong>只要腦海中有比特幣的公鑰私鑰(帳號密碼)，</strong><br><strong>一切都能卷土重來</strong></p><p>一百年後 國家會興亡 貨幣會貶值<br>但不論如何 只要人類文明尚在<br>比特幣也會一直存在</p><h3 id="3-比特幣的特性"><a href="#3-比特幣的特性" class="headerlink" title="3. 比特幣的特性"></a>3. 比特幣的特性</h3><p>可以舉貨幣的四種特徵<br>「易於辨識」、「易於分割且品質一致」、「易於儲存運送」、「普遍接受性」</p><h4 id="易於辨識"><a href="#易於辨識" class="headerlink" title="易於辨識"></a>易於辨識</h4><p>做偽鈔用於便利商店很難<br>但破解人類最先進的密碼學 更難</p><h4 id="易於分割且品質一致"><a href="#易於分割且品質一致" class="headerlink" title="易於分割且品質一致"></a>易於分割且品質一致</h4><p>比特幣支援「億」分之一</p><h4 id="易於儲存運送"><a href="#易於儲存運送" class="headerlink" title="易於儲存運送"></a>易於儲存運送</h4><p>只要有公私鑰在腦中，世界上任何地方都能使用，<br>轉帳費用非常低廉</p><h4 id="普遍接受性"><a href="#普遍接受性" class="headerlink" title="普遍接受性"></a>普遍接受性</h4><p>比特幣最為人詬病的點<br>就是大家認為 法定貨幣、黃金的特性已經足夠<br>加密貨幣只是多此一舉</p><p>另外，因為比特幣難監管，<br>導致各國剛開始時非常排斥<br>（但最近變成是愛恨交織就是了XD）<br>加密貨幣存在的意義<br>就是要等時間來慢慢證明了</p><h3 id="究竟時間要等多久？"><a href="#究竟時間要等多久？" class="headerlink" title="究竟時間要等多久？"></a>究竟時間要等多久？</h3><p>我粗淺認為<br>從微觀的角度 比特幣是可以被取代的<br>但是從鴻觀的角度 也就是100年為跨度<br>考慮了國家的興亡 和世界的動盪<br>它的價值會慢慢被體現<br>這邊的價值 比較著重在<br>應用於日常生活的價值！</p><p>在或近或遠的未來<br>比特幣應該存在著某種地位</p><p>以這樣的角度思考<br>則目前市值約為黃金的 1/50 倍<br>有點太低了</p><p>所以以個人濁見 是有一些投資的機會的<br>但投資跟投機往往一線之間<br>當前比特幣的波動非常大！<br>持有時加密貨幣一定要</p><ol><li>少部位</li><li>用量化分析降低風險</li></ol><p>要怎麼知道資金要投入多少呢？<br>簡單的方式：想像，你「單一天」可以承受最大虧損？</p><p>差不多就投資這麼多吧XDD<br>因為比特幣下跌個70％ 80％都是有發生過的！</p><p>接下來就來建置 Python 交易系統<br>讓我們投資的風險 可防可控！</p><p>歡迎追蹤<a href="https://www.facebook.com/finlab.python/" rel="external nofollow noopener noreferrer" target="_blank">粉專</a><br>來訂閱最新的教學分享喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原本想說開一個課程&lt;br&gt;介紹加密貨幣做portfolio selection&lt;br&gt;不過因為種種因素&lt;br&gt;決定還是寫成免費一系列的文章&lt;br&gt;介紹用 Python 建置 比特幣 交易系統&lt;/p&gt;
&lt;p&gt;新科技&lt;br&gt;如 machine learning、blockcha
      
    
    </summary>
    
      <category term="加密貨幣" scheme="https://www.finlab.tw/categories/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="比特幣" scheme="https://www.finlab.tw/tags/%E6%AF%94%E7%89%B9%E5%B9%A3/"/>
    
      <category term="BTC" scheme="https://www.finlab.tw/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>台北最抗跌公寓在哪？ Python 告訴你 (Part 3)</title>
    <link href="https://www.finlab.tw/real-state-best-district-old-buildings-taipei/"/>
    <id>https://www.finlab.tw/real-state-best-district-old-buildings-taipei/</id>
    <published>2019-11-28T07:24:28.000Z</published>
    <updated>2020-06-05T07:29:51.984Z</updated>
    
    <content type="html"><![CDATA[<p>文末告訴你買哪裡？多少年齡的公寓？比較好<br>（結果滿出乎意料）</p><center><img src="/real-state-best-district-old-buildings-taipei/thumbnail.png" title="投資房產"></center><p>根據專家的說法，<br>由於人口老化的關係，<br>房價未來比較悲觀，<br>假如我們要自住買房怎麼辦？</p><p>有一個家的好處是<br>畢竟每個人生活習慣不同<br>要客制化專屬的生活空間<br>只有擁有房子才辦得到</p><p>但是，房子保值的年代已經過去了<br>幾年前台北的房價被炒的很高<br>有些地方明顯就是太貴了<br>這幾年慢慢的顯現出來</p><p>假如你因為工作需求，<br>需要再台北買一個自己的家<br>要買在哪裡比較保值？<br>對，保值而已，不求上漲，<br>只求不要跌太多</p><p>打開實價登錄，<br>不論是<a href="https://price.houseprice.tw/" rel="external nofollow noopener noreferrer" target="_blank">實價網</a>、<a href="https://www.rakuya.com.tw/realprice/result" rel="external nofollow noopener noreferrer" target="_blank">樂屋網</a>、或其他的網站<br>在功能上，都有很多進步的空間！</p><p>原因在於這些網站，都只提供進幾年的數據，<br>而且無法統計以及繪圖功能，<br>大部分都只提供近一兩年的比較，<br>但一般人自住買房，關心的是10年後的房價，<br>而不只是短期的上漲下跌，</p><p>所以只好來用 Python 做一點功課了</p><p>首先，我們根據之前的介紹，我們可以</p><ul><li><a href="/real-estate-analysis1/">爬到實價登錄歷史資料</a></li><li><a href="/real-estate-analasys-histograms/">將資料整理成 dataframe</a><br>可以先進行以上兩個步驟，然後就可以接著來寫 code 囉！</li></ul><p>這次的主題是「公寓」<br>我們假設某個人想買台北的房子<br>但是由於金錢考量，只能選擇公寓，</p><p>「究竟要怎麼選呢？」</p><h3 id="1-用區域來選"><a href="#1-用區域來選" class="headerlink" title="1. 用區域來選"></a>1. 用區域來選</h3><p>首先我們想要算出，台北市「公寓」的歷史走勢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># plt.rcParams['font.sans-serif'] = ['Noto Sans TC Regular'] # 有支援中文的字體</span></span><br><span class="line"><span class="comment"># plt.rcParams['axes.unicode_minus']=False</span></span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> dis <span class="keyword">in</span> set(df[<span class="string">'鄉鎮市區'</span>]):</span><br><span class="line"></span><br><span class="line">    condition1 = df[<span class="string">'土地區段位置/建物區段門牌'</span>].notna()</span><br><span class="line">    condition2 = df[<span class="string">'建物型態'</span>] == <span class="string">'公寓(5樓含以下無電梯)'</span></span><br><span class="line">    condition3 = (df[<span class="string">'鄉鎮市區'</span>] == dis)</span><br><span class="line">    </span><br><span class="line">    df_local = df[condition3 &amp; condition2]</span><br><span class="line">    result[dis] = df_local[<span class="string">'單價元坪'</span>].groupby(df_local.index.year).mean()</span><br><span class="line"></span><br><span class="line">k = pd.DataFrame(result).loc[<span class="number">2012</span>:]</span><br><span class="line">k.plot()</span><br></pre></td></tr></table></figure><center><img src="/real-state-best-district-old-buildings-taipei/dis-price.png" title="投資房產"></center><p>這張圖可以看出很多端倪，<br>自從政府調整法令後，<br>炒房投資客有明顯減少，<br>所以貴的地區房價下跌，</p><p>另外也因為台北交通便利，<br>（ubike、公車、捷運）<br>所以不論房價高低，<br>其實生活便利程度相差無幾<br>使得便宜的區域房價上漲，</p><p>房價差距越來越小，<br>平均來說，各區房價都越來越往 50～60W/坪 的價格趨近。</p><p>另外，除了肉眼來判別外，<br>我們也可以由價格標準差得知，<br>台北市各區，房價差異慢慢縮小，</p><center><img src="/real-state-best-district-old-buildings-taipei/std.png" title="投資房產"></center><p>由上面的分析，我們可以得到一個結論<br>對於「公寓」而言，我們應該選擇<br>「房價目前較低的地區」<br>因為這些地區的房價，會慢慢往平均（50～60W/坪）移動</p><p>所以假如是買公寓的話，要選哪裡呢？<br>以條件來分析的話，可以這樣選</p><ol><li>2019年房價 &lt; 平均的區域（價格低的）</li><li>2019年房價 &gt; 2018年的區域（看近期有漲的）</li></ol><p>以下就是程式碼以及選出來的區域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p2019 = k.loc[<span class="number">2019</span>]</span><br><span class="line">p2018 = k.loc[<span class="number">2018</span>]</span><br><span class="line"></span><br><span class="line">good_district = (p2019 &gt; p2018) &amp; (p2019 &lt; p2019.mean())</span><br><span class="line">p2019[good_district].sort_values()</span><br></pre></td></tr></table></figure><center><img src="/real-state-best-district-old-buildings-taipei/ranking.png" title="投資房產"></center><p>2. 用屋齡來判斷</p><p>大家都說越老的房子會折舊，<br>越老的房子應該要越便宜，<br>然而事情真的是這樣嗎？</p><p>實價登錄的資料令人跌破眼鏡！<br>根據數據的分析，每個區域都適用：<br>在屋齡「40～50」年的房子，竟然還會往上漲！？<br>不論哪一個區域，哪一年，都可以觀察到這個現象！</p><p>舉個例子，以下我們來繪圖「中山區」房價</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2012</span>, <span class="number">2020</span>):</span><br><span class="line">    df_local = df[(df[<span class="string">'鄉鎮市區'</span>] == <span class="string">'中山區'</span>) &amp; (df[<span class="string">'year'</span>] == i)]</span><br><span class="line">    df_local[<span class="string">'房屋年齡'</span>] = ((<span class="number">2019</span> - pd.to_numeric(df_local[<span class="string">'建築完成年月'</span>].str[:<span class="number">3</span>]) - <span class="number">1911</span>)).astype(int, errors=<span class="string">'ignore'</span>)</span><br><span class="line">    df_local[<span class="string">'房屋年齡'</span>] = pd.to_numeric(df_local[<span class="string">'房屋年齡'</span>] /<span class="number">10</span>).round()</span><br><span class="line">    df_local[<span class="string">'單價元坪'</span>].groupby(df_local[<span class="string">'房屋年齡'</span>]).mean().plot()</span><br></pre></td></tr></table></figure><center><img src="/real-state-best-district-old-buildings-taipei/age.png" title="投資房產"></center><p>上圖每一條線的意思是<br>每一年「不同屋齡的公寓價格」<br>我們可以觀察到幾個現象：</p><ol><li>年輕的公寓下跌的比較快</li><li>老公寓在40～50歲時，還會往上漲</li></ol><p>第二點尤其的詭異，<br>可能是因為都更的關係？<br>不只是中山區，<br>台北的任一區都可以觀察到這個現象<br>大家可以回去跑跑看</p><p>總之，至少老公寓折舊的速度，<br>是比想像中還要慢的，<br>（或可能是老公寓都賣不出去，除<br>非特別地段、特別地點，導致樣本有偏差？<br>還需要再研究）</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>這邊還是要提醒大家，<br>這個是針對「老公寓」做的研究，<br>假如是「新成屋」、「華廈」等屋型，<br>還需要額外去研究才能更清楚。</p><p>數據只是一部分的幫助，<br>買到好房子還是必需要做很多其他功課<br>例如：附近的捷運、生活機能、嫌惡設施 等等<br>都很重要<br>另外，看房技巧、談價格 也不能忽略，</p><p>不過以統計的觀點來說</p><p>保值地區首選順序：<br>「萬華區、文山區、內湖區、南港區」</p><p>保值屋齡首選：<br>「20～40歲以上」公寓</p><p>假如你要在台北買房，<br>而且想要買舊公寓重新裝潢，<br>希望這篇文章可以幫助到你！</p><p>也歡迎分享給有在看房的朋友哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文末告訴你買哪裡？多少年齡的公寓？比較好&lt;br&gt;（結果滿出乎意料）&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/real-state-best-district-old-buildings-taipei/thumbnail.png&quot; title=&quot;投資房產&quot;&gt;&lt;/cent
      
    
    </summary>
    
      <category term="實價登入" scheme="https://www.finlab.tw/categories/%E5%AF%A6%E5%83%B9%E7%99%BB%E5%85%A5/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="房地產" scheme="https://www.finlab.tw/tags/%E6%88%BF%E5%9C%B0%E7%94%A2/"/>
    
  </entry>
  
  <entry>
    <title>機器學習無法預測股價！</title>
    <link href="https://www.finlab.tw/ml-can-not-predict-price/"/>
    <id>https://www.finlab.tw/ml-can-not-predict-price/</id>
    <published>2019-11-06T19:57:11.000Z</published>
    <updated>2020-06-05T07:29:48.574Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/ml-can-not-predict-price/thumbnail.png" title="delay"></center><p>很多我非常尊敬的前輩，說機器學習有一些缺點，拿來投資很危險，<br>這些我都認同，畢竟要做出好的模型是很有挑戰的，<br>且回測模擬跟實際投資的狀況不一樣，非常認同！</p><h3 id="但有時候真的稍微有那麼一點激烈"><a href="#但有時候真的稍微有那麼一點激烈" class="headerlink" title="但有時候真的稍微有那麼一點激烈"></a>但有時候真的稍微有那麼一點激烈</h3><p>另一位我很尊敬的前輩，暗指用AI投資的人：<br>「他們的想像力都消失了，他們只是在耗著老天爺給他們的天賦，<br>  或是青春給他們能犯錯的空間，在那邊浪費生命。」<br>「很多人都被工具綁架邏輯，沒有一點想像力」<br>「做出來的只是垃圾，臭不可聞」</p><h3 id="嗯…"><a href="#嗯…" class="headerlink" title="嗯…"></a>嗯…</h3><p>「究竟跟AI有多深的怨念？」XD<br>我不知道是不是哪裡有不小心得罪或冒犯，<br>才讓他對於使用 AI 投資的人這麼嗤之以鼻<br>以我來說，我最早之前，是做價值投資的研究，後來加入了點技術指標，價量，到現在研究機器學習，</p><p>我覺得<br>每個人投資方法不同，<br>有價值型投資，技術指標，短線、極短線、中長線、存股<br>不論是哪些方法，都有很多人賺錢，更多人賠錢</p><p>不論如何</p><h4 id="可以長期穩定獲利的就是好工具。"><a href="#可以長期穩定獲利的就是好工具。" class="headerlink" title="可以長期穩定獲利的就是好工具。"></a>可以長期穩定獲利的就是好工具。</h4><p>這些對 AI 不屑前輩的口中，總是有著這麼一句話：</p><h3 id="機器學習無法預測價格"><a href="#機器學習無法預測價格" class="headerlink" title="機器學習無法預測價格"></a>機器學習無法預測價格</h3><p>這句話，以我自己的經驗來說，是舉雙手認同的，<br>但就算是認同，我也絕對不敢斷定，或直接了當的大肆宣揚，<br>畢竟這個世界有太多東西要學習了，</p><p>不過我們就先「假設」機器學習無法預測股價好了</p><h4 id="難道想獲利一定要預測股價嗎？"><a href="#難道想獲利一定要預測股價嗎？" class="headerlink" title="難道想獲利一定要預測股價嗎？"></a>難道想獲利一定要預測股價嗎？</h4><p>你不需要懂機器學習，也知道：</p><h4 id="通常撰寫策略，從來不用預測股價"><a href="#通常撰寫策略，從來不用預測股價" class="headerlink" title="通常撰寫策略，從來不用預測股價"></a>通常撰寫策略，從來不用預測股價</h4><p>只要產生的交易訊號，也就是買賣時機點就可以了，<br>照著操作，被動的投資，而不是主動的預測，<br>對於機器學習也是同樣的道理。</p><p>所以正確的使用機器學習的方法是：</p><h3 id="不要用機器學習預測股價，而是用來直接產生交易訊號！"><a href="#不要用機器學習預測股價，而是用來直接產生交易訊號！" class="headerlink" title="不要用機器學習預測股價，而是用來直接產生交易訊號！"></a>不要用機器學習預測股價，而是用來直接產生交易訊號！</h3><p>既然大家都有這樣的知識，為何還要執著於「機器學習無法預測股價」所以「機器學習沒有用」這件事情上呢？<br>就像是你測量羽毛跟保齡球落下，時間不一樣，難道就說牛頓第二運動定律是錯的了嗎？<br>比較有可能是實驗做錯了啦～</p><p>為何大家都說機器學習無法預測股價，先簡單的說明一下</p><h3 id="最為人所知的機器學習障礙-預測延遲"><a href="#最為人所知的機器學習障礙-預測延遲" class="headerlink" title="最為人所知的機器學習障礙 - 預測延遲"></a>最為人所知的機器學習障礙 - 預測延遲</h3><p>簡單來說，就是下圖中，藍色的為股價，而紅色的是機器學習預測的數值，<br>可以看到紅色永遠比藍色線慢半拍，晚一步才轉折<br>雖然藍色跟紅色非常接近，但離「預測」其實差得很遠，回測後就會發現，是不能拿來交易的，</p><p><center><img src="/ml-can-not-predict-price/delay.png" title="delay"></center><br>這個就是大家所說，機器學習的預測延遲<br>說真的，這類有小瑕疵的文章或論文是真的滿多的，<br>例如 <a href="https://towardsdatascience.com/predicting-stock-price-with-lstm-13af86a74944" rel="external nofollow noopener noreferrer" target="_blank">這篇</a><br>就連我們的部落格，也有<a href="https://www.finlab.tw/%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E5%B9%AB%E4%BD%A0%E8%A7%A3%E6%9E%90K%E7%B7%9A%E5%9C%96%EF%BC%81/">這類的文章</a></p><p>你只要搜尋「machine learning predict stock price」<br>就可以找到滿坑滿谷的文章，都有這個缺點</p><p>之所以會有這樣的問題，不難理解，因為股價並不是stationary time series，所以機器學習直接預測股價很容易失真<br>導致最後落入 overfitting 的窘境，且預測結果常常會有 bias</p><p>所以</p><h3 id="我自己寫的文章，沒有任何一篇是教大家預測股價的"><a href="#我自己寫的文章，沒有任何一篇是教大家預測股價的" class="headerlink" title="我自己寫的文章，沒有任何一篇是教大家預測股價的"></a>我自己寫的文章，沒有任何一篇是教大家預測股價的</h3><p>我想提供大家真的能夠獲利的程式碼，<br>用來展示機器學習真的可以用來投資，<br>我不是蹭AI的熱潮，東拼西湊，只求程式可以跑，<br>而是盡力做出一個希望能夠獲利的模型，又讓大家可以學到新的演算法<br>並把這個模型分享給大家，然而AI不是神，沒有一個策略保證一定賺錢，<br>但我至少做到問心無愧，目前績效看起來也還OK，</p><h3 id="機器學習策略-我認為有效的方法"><a href="#機器學習策略-我認為有效的方法" class="headerlink" title="機器學習策略 - 我認為有效的方法"></a>機器學習策略 - 我認為有效的方法</h3><p>接下來舉一個，我認為有用的方法，<br>首先利用<br>Integrating a Piecewise Linear Representation Method and a Neural Network Model for Stock Trading Points Prediction<br>這篇 paper 當中的方式產生交易訊號<br>並且讓機器學習模型模仿，找出轉折點，以下是簡略的數據：</p><ul><li>商品：台股加權指數，取每15分鐘的收盤價</li><li>製作特徵：利用各種技術指標當作features</li><li>預測訊號：利用上述的 paper 產生交易訊號</li><li>利用2015年以前的資料產生模型，</li></ul><p>用一個最普通的神經網路，就可以有不錯的效果，以下是2019年5月的範例圖，<br>其中</p><ul><li>紅色為股價</li><li>藍色為多方轉折的發生機率</li><li>紫色為空方轉折的發生機率（負值）</li></ul><p>可以看出來，當藍色飆高時，通常是底部的多方轉折<br>而紫色飆高時，則是相反，是頭部的空方轉折</p><p><center><img src="/ml-can-not-predict-price/better.png" title="better"></center><br>2019年五月</p><p><center><img src="/ml-can-not-predict-price/better2.png" title="better2"></center><br>2019年六月<br>看不出有延遲，幾乎都是直接實時反應，<br>看起來還抓的算滿OK的，可以用來逆勢操作</p><p>雖然看似有用，但</p><h3 id="機器學習不適用於所有人，因為很難很複雜"><a href="#機器學習不適用於所有人，因為很難很複雜" class="headerlink" title="機器學習不適用於所有人，因為很難很複雜"></a>機器學習不適用於所有人，因為很難很複雜</h3><h3 id="付出與收穫可能不成正比"><a href="#付出與收穫可能不成正比" class="headerlink" title="付出與收穫可能不成正比"></a>付出與收穫可能不成正比</h3><p>假如你不喜歡折磨自己<br>其實簡單的策略也可以賺錢的，<br>所以說你不一定要用機器學習來投資，</p><h3 id="然而每個人各有喜好，"><a href="#然而每個人各有喜好，" class="headerlink" title="然而每個人各有喜好，"></a>然而每個人各有喜好，</h3><p>以我而言，我喜歡<strong>追求和分享新的科技</strong>，<br>並且幫助大家學習新知識之餘，幸運的話還可以賺點錢，<br>然而走在科技的前沿，特立獨行，本來就是會有很多的支持和反對<br>我不敢說這條路走的正確，但我們能走多遠是多遠，<br>這一切紛擾，只能用對帳單來證明了（XDD努力生產中）<br>（雖然我們早在一年前開始就把模擬結果<a href="https://ai.finlab.tw/strategy/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%20-%20%E8%B2%A1%E5%8B%99%E5%A0%B1%E8%A1%A8%E9%81%B8%E8%82%A1" rel="external nofollow noopener noreferrer" target="_blank">每天都放上網</a>，但看來對帳單還是必須的呀！）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/ml-can-not-predict-price/thumbnail.png&quot; title=&quot;delay&quot;&gt;&lt;/center&gt;

&lt;p&gt;很多我非常尊敬的前輩，說機器學習有一些缺點，拿來投資很危險，&lt;br&gt;這些我都認同，畢竟要做出好的模型是很有
      
    
    </summary>
    
      <category term="AI看股票" scheme="https://www.finlab.tw/categories/AI%E7%9C%8B%E8%82%A1%E7%A5%A8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Machine Learning" scheme="https://www.finlab.tw/tags/Machine-Learning/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="量化投資" scheme="https://www.finlab.tw/tags/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B3%87/"/>
    
  </entry>
  
  <entry>
    <title>投資組合 Paper Trading 1分鐘就上手（Cmoney 大富翁股票 API）</title>
    <link href="https://www.finlab.tw/cmoney-paper-trading/"/>
    <id>https://www.finlab.tw/cmoney-paper-trading/</id>
    <published>2019-11-02T05:07:19.000Z</published>
    <updated>2020-06-05T07:29:51.186Z</updated>
    
    <content type="html"><![CDATA[<p>沒有錢投資嗎？想要鍛鍊投資技巧又不虧錢嗎？<br>除了回測外，想要有接近真實情況的投資模擬嗎？<br>那你一定要試試看我寫的這個小程式：CmoneyVirtualAccount<br>他可以幫你模擬股票買賣的獲利狀況，讓你在沒有錢的時候，可以拿來做練習。</p><center><img src="/cmoney-paper-trading/thumbnail.png" title="thumbnail"></center><h3 id="為什麼要用-Paper-Trading"><a href="#為什麼要用-Paper-Trading" class="headerlink" title="為什麼要用 Paper Trading"></a>為什麼要用 Paper Trading</h3><p>Paper Trading 可以幫助我們更理解市場上投資的真實狀況，<br>顯示我們「假如」持有某種資產組合的報酬率，<br>我們可以自行設定投資金額，例如100萬，並且測試看看，自己精心研發的策略有沒有用</p><h3 id="為什麼不用回測就好了？"><a href="#為什麼不用回測就好了？" class="headerlink" title="為什麼不用回測就好了？"></a>為什麼不用回測就好了？</h3><p>簡單講，大部分寫Python的人，回測框架要達到非常嚴謹，是非常困難的，<br>所以通常我們都「大概測一測」，比較少考慮的部分有：</p><ol><li>胃納量（有些股票根本沒成交量，怎麼可能買很多張？）</li><li>不小心使用到未來數據（財報、月營收）</li><li>摩擦成本（手續費、證交稅）</li><li>忘記把已下市股票給納入回測中</li><li>太多了…以後再整理給大家</li></ol><p>除了更精密的模擬外，Paper Trading還能夠</p><h3 id="幫助投資人檢視策略的「微觀效果」"><a href="#幫助投資人檢視策略的「微觀效果」" class="headerlink" title="幫助投資人檢視策略的「微觀效果」"></a>幫助投資人檢視策略的「微觀效果」</h3><p>Paper Trading 可以讓你對於投資更有感覺，回測只是看長年下來的獲利績效，<br>雖然你可能覺得長期績效很好，但是這是個宏觀角度（好幾年），也就是最後得到的總報酬率，<br>然而我們真正投資的時候，是深處於微觀的世界（每天），會覺得每天的起伏都很劇烈！<br>有時候會讓你疑神疑鬼，想要調整策略，覺得這個策略可能失效了，<br>變得說常常在優化策略，但是都是無謂的優化<br>Paper Trading 另一個關鍵是，你要把它當成真的$（雖然很難），<br>這樣操作的時候，除了模擬獲利，也模擬自己面對報酬率的心態，</p><p>接下來我們就進行三個步驟來做 Paper Trading 吧！</p><h3 id="1-安裝"><a href="#1-安裝" class="headerlink" title="1. 安裝"></a>1. 安裝</h3><p>這個程式沒什麼特別的安裝方法，可以打開anaconda prompt 輸入以下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/koreal6803/CmoneyVirtualAccount.git</span><br><span class="line"></span><br><span class="line"># mac 使用的指令</span><br><span class="line">mv CmoneyVirtualAccount/cmoneyVirtualAccount ./cmoney</span><br><span class="line"></span><br><span class="line"># windows 使用的指令</span><br><span class="line">move CmoneyVirtualAccount/cmoneyVirtualAccount ./cmoney</span><br></pre></td></tr></table></figure></p><h3 id="2-申請帳號"><a href="#2-申請帳號" class="headerlink" title="2. 申請帳號"></a>2. 申請帳號</h3><p>我們要到 Cmoney 的平台來申請帳號密碼：<br><a href="https://www.cmoney.tw/vt/" rel="external nofollow noopener noreferrer" target="_blank">https://www.cmoney.tw/vt/</a><br>這邊值得注意的是，假如你有用FB登入，請還是要設定一個密碼，這樣等等才可以使用 Python 操控 Cmoney 的模擬平台喔！(右上角使用者名稱-&gt;基本資料)</p><h3 id="3-用程式操控"><a href="#3-用程式操控" class="headerlink" title="3. 用程式操控"></a>3. 用程式操控</h3><p>然後就可以在此資料夾中，使用 Python 來做 Paper trading 囉！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cmoney.stock <span class="keyword">import</span> VirtualStockAccount</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登入</span></span><br><span class="line">vs = VirtualStockAccount(<span class="string">'your_account'</span>, <span class="string">'your_password'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切換子帳號</span></span><br><span class="line">vs.aid = <span class="string">'123456'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ #</span></span><br><span class="line"><span class="comment"># 查看帳戶</span></span><br><span class="line"><span class="comment"># ------ # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到某檔股票的資料：</span></span><br><span class="line">vs.get_price(<span class="string">'2330'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目前帳戶持有的股票</span></span><br><span class="line">vs.status()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看現有資金</span></span><br><span class="line">vs.info()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ #</span></span><br><span class="line"><span class="comment"># 操作帳戶</span></span><br><span class="line"><span class="comment"># ------ # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 買一張台積電（強迫現價或開盤價買入）</span></span><br><span class="line">vs.buy(<span class="string">'2330'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 賣出一張台積電（強迫現價或開盤賣出）</span></span><br><span class="line">vs.sell(<span class="string">'2330'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ #</span></span><br><span class="line"><span class="comment"># 批次操作</span></span><br><span class="line"><span class="comment"># ------ # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 買一張台積電、一張聯發科</span></span><br><span class="line">vs.buy(&#123;<span class="string">'2330'</span>: <span class="number">1</span>, <span class="string">'2454'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出清所有股票</span></span><br><span class="line">vs.sell_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將所有帳戶持股設定成：「一張台積電」、「一張聯發科」</span></span><br><span class="line"><span class="comment"># （會先賣出股票，並且買「一張台積電」、「一張聯發科」)</span></span><br><span class="line">vs.rebalance(&#123;<span class="string">'2330'</span>: <span class="number">1</span>, <span class="string">'2454'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自動分配持股（平均分散總資產）（通常我會用這個）</span></span><br><span class="line">vs.sync([<span class="string">'1101'</span>, <span class="string">'2330'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------ #</span></span><br><span class="line"><span class="comment"># 委託操作</span></span><br><span class="line"><span class="comment"># ------ # </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目前的委託單</span></span><br><span class="line">vs.get_orders()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除所有委託單</span></span><br><span class="line">vs.cancel_all_orders()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="課程同學-Bonus"><a href="#課程同學-Bonus" class="headerlink" title="課程同學 Bonus!"></a>課程同學 Bonus!</h3><p>假如有上<a href="https://hahow.in/cr/python-finance" rel="external nofollow noopener noreferrer" target="_blank">「小資族選股策略」</a>的同學，想要paper trade你的策略，配合最後的優等生策略，可以直接使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.sync(strategy(data))</span><br></pre></td></tr></table></figure><p>來 paper trade 任何選股策略喔！</p><p>這支程式放在倉庫裡很久了，最近想要用又把它拿出來，想說修理一下分享給大家！<br>也歡迎大家來 push 新功能喔～（缺 unit test 呀XD）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;沒有錢投資嗎？想要鍛鍊投資技巧又不虧錢嗎？&lt;br&gt;除了回測外，想要有接近真實情況的投資模擬嗎？&lt;br&gt;那你一定要試試看我寫的這個小程式：CmoneyVirtualAccount&lt;br&gt;他可以幫你模擬股票買賣的獲利狀況，讓你在沒有錢的時候，可以拿來做練習。&lt;/p&gt;
&lt;cent
      
    
    </summary>
    
      <category term="財經Python教" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>只用一行程式碼分析數據!?（實用的 Python Package）</title>
    <link href="https://www.finlab.tw/one-line-info-dataframe/"/>
    <id>https://www.finlab.tw/one-line-info-dataframe/</id>
    <published>2019-09-30T13:46:49.000Z</published>
    <updated>2020-06-05T07:29:50.751Z</updated>
    
    <content type="html"><![CDATA[<p>這篇文章介紹一個好用的 package，只要一行，就可以做出精美、詳細的圖表分析<br>還可以幫你查看資料是否有缺漏和錯誤的情況！</p><center><img src="/one-line-info-dataframe/thumbnail.jpeg" title="thumbnail"></center><p>今天的程式碼成果：</p><center><img src="/one-line-info-dataframe/profile_df.gif" title="profile_df"></center><h1 id="先取得要分析之資料"><a href="#先取得要分析之資料" class="headerlink" title="先取得要分析之資料"></a>先取得要分析之資料</h1><p>今天我們來分析一下股票的本益比、股價淨值比和殖利率，<br>先提供給大家一個爬蟲，讓大家可以直接把資料爬下來：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">import</span> pandas_profiling</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawler</span><span class="params">(date)</span>:</span></span><br><span class="line">    datestr = date.strftime(<span class="string">'%Y%m%d'</span>)</span><br><span class="line">    url = <span class="string">'https://www.twse.com.tw/exchangeReport/BWIBBU_d?response=csv&amp;date='</span>+datestr+<span class="string">'&amp;selectType=ALL'</span></span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    df = pd.read_csv(StringIO(res.text), header=<span class="number">1</span>)</span><br><span class="line">    df[<span class="string">'本益比'</span>] = pd.to_numeric(df[<span class="string">'本益比'</span>], errors=<span class="string">'coerce'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> df.dropna(thresh=<span class="number">3</span>).dropna(thresh=<span class="number">0.8</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>接下來我們就呼叫 <code>crawler</code> 這個函式，就可以將財務數據資料都爬取下來囉！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = crawler(datetime.date(<span class="number">2019</span>,<span class="number">10</span>,<span class="number">7</span>))</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><center><img src="/one-line-info-dataframe/head.png" title="df_head"></center><h3 id="1-用舊的方法來分析資料"><a href="#1-用舊的方法來分析資料" class="headerlink" title="1. 用舊的方法來分析資料"></a>1. 用舊的方法來分析資料</h3><p>最簡單的方式，假如有用過 <code>pandas</code> 的大家應該都知道，<br>可以使用 <code>df.describe()</code> 來大致上觀察數據的樣貌<br>假如你對 pandas 不太熟悉，它有點像是拿來處理表格的資料，<br>就像是 python 界的 excel 一樣，雖然它非常好用，但是有點太古老（無聊）了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.describe()</span><br></pre></td></tr></table></figure><center><img src="/one-line-info-dataframe/describe.png" title="df_describe"></center><h3 id="2-酷炫的方法資料分析"><a href="#2-酷炫的方法資料分析" class="headerlink" title="2. 酷炫的方法資料分析"></a>2. 酷炫的方法資料分析</h3><p>首先我們可以安裝 pandas_profiling</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas_profiling</span><br></pre></td></tr></table></figure><p>接下來就可以直接來使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_profiling</span><br><span class="line">df = crawler(datetime.date(<span class="number">2019</span>,<span class="number">10</span>,<span class="number">7</span>))</span><br><span class="line">df.profile_report()</span><br></pre></td></tr></table></figure><p>然後我們就會看到超精美的圖表！</p><h4 id="找出資料的缺漏或問題"><a href="#找出資料的缺漏或問題" class="headerlink" title="找出資料的缺漏或問題"></a>找出資料的缺漏或問題</h4><p>我覺得 <code>pandas_profiling</code> 很棒的地方在於，<br>可以將資料一口氣全部統整給我們，方便我們去做資料前處理，<br>例如下圖中的左下角，就可以看到每一個column有哪些警告，</p><center><img src="/one-line-info-dataframe/profile.png" title="profile"></center><ul><li>本益比有 20.4 % 是缺漏的：這是正常情況，因為本益比小於零不顯示</li><li>殖利率有 20.0 % 是 0：這也是正常情況，因為公司不一定有發股利股息</li><li>財報都是用第 2 季的財報：這也是正常的！</li></ul><p>有了這種檢驗，更能夠讓我們知道資料的可靠程度，真的非常非常棒！<br>除了上述的檢驗外，我們還可以</p><h4 id="輕鬆檢視每一個-column-的資料"><a href="#輕鬆檢視每一個-column-的資料" class="headerlink" title="輕鬆檢視每一個 column 的資料"></a>輕鬆檢視每一個 column 的資料</h4><p>這邊可以看到每一種資料的分佈，可以讓我們更好的掌握數據分佈型態</p><center><img src="/one-line-info-dataframe/hist.png" title="histogram"></center><h4 id="檢視資料相關性"><a href="#檢視資料相關性" class="headerlink" title="檢視資料相關性"></a>檢視資料相關性</h4><p>這邊還可以檢視資料的相關性，這邊有些複雜的名詞，哪天再來跟各位介紹</p><center><img src="/one-line-info-dataframe/corr.png" title="correlation"></center><p><code>pandas_profiling</code> 真的是很不錯的 package，<br>可以幫我們進一步的認識資料，<br>假如你也覺得這個 package 很實用，<br>也歡迎你分享給大家喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這篇文章介紹一個好用的 package，只要一行，就可以做出精美、詳細的圖表分析&lt;br&gt;還可以幫你查看資料是否有缺漏和錯誤的情況！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/one-line-info-dataframe/thumbnail.jpeg&quot; title=&quot;t
      
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Python" scheme="https://www.finlab.tw/tags/Python/"/>
    
      <category term="dataframe" scheme="https://www.finlab.tw/tags/dataframe/"/>
    
      <category term="資料分析" scheme="https://www.finlab.tw/tags/%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>用程式分析房地產可行嗎（2）房價分析</title>
    <link href="https://www.finlab.tw/real-estate-analasys-histograms/"/>
    <id>https://www.finlab.tw/real-estate-analasys-histograms/</id>
    <published>2019-08-29T00:58:05.000Z</published>
    <updated>2020-06-05T07:29:48.078Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/real-estate-analasys-histograms/fb11.png" title="distribution"></center><p>大家都在說房價市場恢復景氣，然而真的是這樣子嗎？<br>你有沒有覺得，怎麼每個人說的話都不一樣？<br>數據雖然都是實價登錄，但有些人就是看到漲，有些人就是看跌？<br>究竟誰說的對，還是必須要親自研究一下數據，才會知道</p><h1 id="數據是拿來「調整」的？！"><a href="#數據是拿來「調整」的？！" class="headerlink" title="數據是拿來「調整」的？！"></a>數據是拿來「調整」的？！</h1><p>身為一個「曾經」產出學術文章寫手，就會知道這些數據是有很多「可以操作空間」<br>（這樣講對嗎？XD）<br>不要相信任何人幫你統計的數據<br>因為任何人的數據都有可能想達成某種目的<br>例如某人要增加流量和公信力，就可以危言聳聽一點，用數據製作房價都在下跌的結論<br>某房仲想要刺激房地產，就會製作止跌回升的訊號，</p><h1 id="難道數據造假？！"><a href="#難道數據造假？！" class="headerlink" title="難道數據造假？！"></a>難道數據造假？！</h1><p>不論上漲下跌，相信這些數據都是對的，<br>都是從政府的實價登錄而得到<br>但分析方式不同，就會產生不同的結果！</p><p>所以數據是用來「感覺」的，而不是單看少數「專家」的結論<br>只能多做一點實驗，盡量讓實驗客觀公正，</p><p>這篇文章總共分成三個部分：</p><ol><li>獲取實價登錄</li><li>房價歷史走勢圖</li><li>房價分佈圖</li></ol><p>所以接下來我們就用 Python 來跟大家一起分析實價登錄的資料吧！</p><h1 id="取得實價登錄資料"><a href="#取得實價登錄資料" class="headerlink" title="取得實價登錄資料"></a>取得實價登錄資料</h1><p>首先跟上次一樣，<br><a href="/real-estate-analysis1/">爬取了實價登入所有歷史數據</a>，這次我們爬取csv檔：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">real_estate_crawler</span><span class="params">(year, season)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> year &gt; <span class="number">1000</span>:</span><br><span class="line">        year -= <span class="number">1911</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># download real estate zip file</span></span><br><span class="line">    res = requests.get(<span class="string">"https://plvr.land.moi.gov.tw//DownloadSeason?season="</span>+str(year)+<span class="string">"S"</span>+str(season)+<span class="string">"&amp;type=zip&amp;fileName=lvr_landcsv.zip"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># save content to file</span></span><br><span class="line">    fname = str(year)+str(season)+<span class="string">'.zip'</span></span><br><span class="line">    open(fname, <span class="string">'wb'</span>).write(res.content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make additional folder for files to extract</span></span><br><span class="line">    folder = <span class="string">'real_estate'</span> + str(year) + str(season)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(folder):</span><br><span class="line">        os.mkdir(folder)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># extract files to the folder</span></span><br><span class="line">    <span class="keyword">with</span> zipfile.ZipFile(fname, <span class="string">'r'</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">        zip_ref.extractall(folder)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>有了上述這個 function 我們可以將實價登錄資訊全部爬取下來：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">real_estate_crawler(<span class="number">101</span>, <span class="number">3</span>)</span><br><span class="line">real_estate_crawler(<span class="number">101</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> range(<span class="number">102</span>, <span class="number">108</span>):</span><br><span class="line">    <span class="keyword">for</span> season <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        print(year, season)</span><br><span class="line">        real_estate_crawler(year, season)</span><br><span class="line"></span><br><span class="line">real_estate_crawler(<span class="number">108</span>, <span class="number">1</span>)</span><br><span class="line">real_estate_crawler(<span class="number">108</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>下載完後，會看到每一年每一季的實價登錄資料夾<br>裡面有很多檔案，主要可以分成以下三種：</p><ul><li>x_lvr_land_a：房屋買賣交易</li><li>x_lvr_land_b：新成屋交易</li><li>x_lvr_land_c：租房交易</li></ul><p>其中 x 是一個英文字母，代表每個縣市，也就是你身份證字號的開頭<br>例如台北，就是「a」，新北市就是「f」，以此類推</p><h1 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h1><p>接下來我們以台北市為例子，看看能不能找到台北市便宜的好房子，<br>首先我們將歷年資料都讀進來：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 歷年資料夾</span></span><br><span class="line">dirs = [d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir() <span class="keyword">if</span> d[:<span class="number">4</span>] == <span class="string">'real'</span>]</span><br><span class="line"></span><br><span class="line">dfs = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> dirs:</span><br><span class="line">    print(d)</span><br><span class="line">    df = pd.read_csv(os.path.join(d,<span class="string">'a_lvr_land_a.csv'</span>), index_col=<span class="literal">False</span>)</span><br><span class="line">    df[<span class="string">'Q'</span>] = d[<span class="number">-1</span>]</span><br><span class="line">    dfs.append(df.iloc[<span class="number">1</span>:])</span><br><span class="line">    </span><br><span class="line">df = pd.concat(dfs, sort=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/dfhead.png" title="dataframe"></center><p>然而這些資訊還必須再經過處理，才會讓我們待會的資料分析更好下手</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增交易年份</span></span><br><span class="line">df[<span class="string">'year'</span>] = df[<span class="string">'交易年月日'</span>].str[:<span class="number">-4</span>].astype(int) + <span class="number">1911</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同名稱同項目資料合併</span></span><br><span class="line">df[<span class="string">'單價元平方公尺'</span>].fillna(df[<span class="string">'單價元/平方公尺'</span>], inplace=<span class="literal">True</span>)</span><br><span class="line">df.drop(columns=<span class="string">'單價元/平方公尺'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平方公尺換成坪</span></span><br><span class="line">df[<span class="string">'單價元平方公尺'</span>] = df[<span class="string">'單價元平方公尺'</span>].astype(float)</span><br><span class="line">df[<span class="string">'單價元坪'</span>] = df[<span class="string">'單價元平方公尺'</span>] * <span class="number">3.30579</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建物型態</span></span><br><span class="line">df[<span class="string">'建物型態2'</span>] = df[<span class="string">'建物型態'</span>].str.split(<span class="string">'('</span>).str[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除有備註之交易（多為親友交易、價格不正常之交易）</span></span><br><span class="line">df = df[df[<span class="string">'備註'</span>].isnull()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將index改成年月日</span></span><br><span class="line">df.index = pd.to_datetime((df[<span class="string">'交易年月日'</span>].str[:<span class="number">-4</span>].astype(int) + <span class="number">1911</span>).astype(str) + df[<span class="string">'交易年月日'</span>].str[<span class="number">-4</span>:] ,errors=<span class="string">'coerce'</span>)</span><br></pre></td></tr></table></figure><p>接下來我們可以來看一下這些資料有哪些欄位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.columns</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/dfcolumn.png" title="columns"></center><p>上圖我們比較在意的是：</p><ul><li>單價元坪：每坪房價是多少</li><li>物件型態：<code>住宅大樓</code>, <code>倉庫</code>, <code>公寓</code>, <code>套房</code>…等</li><li>鄉鎮市區：<code>中山區</code>, <code>中正區</code>, <code>信義區</code>, <code>內湖區</code>…等</li><li>每年房價的變化</li></ul><p>接下來我們就來將上述這些數據，變化成一些圖表，<br>方便我們以視覺化的方式來理解資料</p><h1 id="圖表分析"><a href="#圖表分析" class="headerlink" title="圖表分析"></a>圖表分析</h1><p>老實說，每個建商給的房價走勢圖好像都不太一樣，<br>我不知道他們是怎麼處理這些數據，有時候走勢都好棒棒的感覺<br>至少finlab的處理的方式，是完全透明，攤在陽光下讓大家知道<br>我覺得「公佈程式」就是一種比較公正、透明、公開的方式<br>讓大家檢驗這樣的計算是否公正，<br>假如哪裡可以再改進，也可以跟我說！</p><h2 id="每年房價走勢圖"><a href="#每年房價走勢圖" class="headerlink" title="每年房價走勢圖"></a>每年房價走勢圖</h2><p>下圖我們就來計算歷年房價的走勢圖，我們希望每一區可以分開畫<br>方便我們瞭解<code>地區</code>、<code>時間</code>這兩個因子對於房價的差異</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">prices = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> district <span class="keyword">in</span> set(df[<span class="string">'鄉鎮市區'</span>]):</span><br><span class="line">    cond = (</span><br><span class="line">        (df[<span class="string">'主要用途'</span>] == <span class="string">'住家用'</span>)</span><br><span class="line">        &amp; (df[<span class="string">'鄉鎮市區'</span>] == district)</span><br><span class="line">        &amp; (df[<span class="string">'單價元坪'</span>] &lt; df[<span class="string">"單價元坪"</span>].quantile(<span class="number">0.95</span>))</span><br><span class="line">        &amp; (df[<span class="string">'單價元坪'</span>] &gt; df[<span class="string">"單價元坪"</span>].quantile(<span class="number">0.05</span>))</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    groups = df[cond][<span class="string">'year'</span>]</span><br><span class="line">    </span><br><span class="line">    prices[district] = df[cond][<span class="string">'單價元坪'</span>].astype(float).groupby(groups).mean().loc[<span class="number">2012</span>:]</span><br><span class="line">    </span><br><span class="line">price_history = pd.DataFrame(prices)</span><br><span class="line">price_history.plot()</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/dts.png" title="房價走勢圖"></center><p>上圖中我們可以看出來，雖然房價會隨著時間波動，但地段的優勢還是非常的明顯，<br>例如大安區還是很可怕的，一坪最高可以到90萬元（平均後的數字）<br>然而以2019年來說，可以發現，</p><p>高價位地段 -&gt; 稍微下跌<br>低價位地段 -&gt; 稍微上漲</p><p>畢竟台北的大眾交通工具也算是還OK，住哪裡應該都不至於太不方便<br>所以在幾乎沒有炒作空間的狀況下，不同地區的差異性慢慢降低，感覺是合理的</p><h2 id="那總體來說呢？"><a href="#那總體來說呢？" class="headerlink" title="那總體來說呢？"></a>那總體來說呢？</h2><p>我們可以粗略的用簡單的「平均」的方式，將所有地區的房價平均起來：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price_history.mean(axis=<span class="number">1</span>).plot()</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/dtsm.png" title="平均房價"></center><p>就會看到2014年高峰後，台北市房價就處於下跌的狀態</p><h2 id="不是有人說2019年房價回升了嗎？"><a href="#不是有人說2019年房價回升了嗎？" class="headerlink" title="不是有人說2019年房價回升了嗎？"></a>不是有人說2019年房價回升了嗎？</h2><p>刪除outlier的方式不同，可以得出不同的結論，<br>也是有一些實驗中 2019 年平均房價比 2018 年高，<br>所以目前也有很多人說止跌回升是有可能的</p><h2 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h2><p>整體的大趨勢來說，從2014年以後開始下跌至今，似乎跌幅沒有像當初這麼重，<br>甚至有止跌的跡象，但究竟房價有沒有回升，還需要謹慎評估</p><p>甚至還有報導說，某些地段回到了2014、2015高點，這都是拿單一區段來當結論，見樹不見林的方式，背後居心自然是眾人皆知。</p><p>思考一下，為何現在都在推新建案？有很多節目，專家們都宣導，買公寓（舊房子）比較可能選到有壁癌、排水系統不好、貸款成數較低…等等，鼓吹大家買新建案。</p><p>當然他們很有可能是為了消費者著想，這些都是實話，不過也有可能是因為新房子比起公寓，更能賣出好價錢，進而維持房價不衰退，所以接下來我們就來分析一下</p><h1 id="建物型態"><a href="#建物型態" class="headerlink" title="建物型態"></a>建物型態</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">building_type_prices = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> building_type <span class="keyword">in</span> set(df[<span class="string">'建物型態2'</span>]):</span><br><span class="line">    cond = (</span><br><span class="line">        (df[<span class="string">'主要用途'</span>] == <span class="string">'住家用'</span>)</span><br><span class="line">        &amp; (df[<span class="string">'單價元坪'</span>] &lt; df[<span class="string">"單價元坪"</span>].quantile(<span class="number">0.8</span>))</span><br><span class="line">        &amp; (df[<span class="string">'單價元坪'</span>] &gt; df[<span class="string">"單價元坪"</span>].quantile(<span class="number">0.2</span>))</span><br><span class="line">        &amp; (df[<span class="string">'建物型態2'</span>] == building_type)</span><br><span class="line">        )</span><br><span class="line">    building_type_prices[building_type] = df[cond][<span class="string">'單價元坪'</span>].groupby(df[cond][<span class="string">'year'</span>]).mean().loc[<span class="number">2012</span>:]</span><br><span class="line">pd.DataFrame(building_type_prices)[[<span class="string">'公寓'</span>, <span class="string">'住宅大樓'</span>, <span class="string">'套房'</span>, <span class="string">'華廈'</span>]].plot()</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/tts.png" title="types_real_estate"></center><p>上圖中我們可以發現，老舊公寓的價格真的會不太理想，比起一般的大樓住宅或是住宅，近年價差越來越明顯，當價差到達一定的程度，買新房不一定比較好，舊房不一定這麼一無是處。</p><p>但是以平均來當作指標，其實也不是這麼精確，我們還是用分佈圖用眼睛來感受一下，才是最好瞭解房價的方法：</p><h2 id="分佈圖"><a href="#分佈圖" class="headerlink" title="分佈圖"></a>分佈圖</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'font.size'</span>] = <span class="number">20</span></span><br><span class="line"><span class="keyword">for</span> district <span class="keyword">in</span> set(df[<span class="string">'鄉鎮市區'</span>]):</span><br><span class="line">    dfdistrict = df[df[<span class="string">'鄉鎮市區'</span>] == district]</span><br><span class="line">    dfdistrict[<span class="string">'單價元坪'</span>][dfdistrict[<span class="string">'單價元坪'</span>] &lt; <span class="number">2000000</span>].hist(bins=<span class="number">120</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">2000000</span>)</span><br><span class="line">plt.legend(set(df[<span class="string">'鄉鎮市區'</span>]))</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/dhis.png" title="distribution"></center><p>上圖中可以明顯感受到，不同地區房價的差異性，例如最右邊的分佈（大安區），大部分單價都比較貴，同時我們也可以看到一些低的詭譎的房價（每坪0萬？！），當然也有很多高的咋舌的單價，<br>甚至一坪200萬都有，只能說富人的世界跟我們一般人還是差距很大呀！</p><p>我們取平均的時候無法將這些怪房價給濾除，但好在人眼可以<br>這就是分佈圖的重要性</p><h2 id="買房使用-Python-簡單的範例"><a href="#買房使用-Python-簡單的範例" class="headerlink" title="買房使用 Python 簡單的範例"></a>買房使用 Python 簡單的範例</h2><p>假如今天我們想在北投買房子，可以將北投的房價單獨拿出來看，並且按照建案型態製作分佈圖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dfdistrict = df[(df[<span class="string">'鄉鎮市區'</span>] == <span class="string">'北投區'</span>) &amp; (df[<span class="string">'year'</span>] &gt;= <span class="number">2018</span>) &amp; (</span><br><span class="line">    (df[<span class="string">'建物型態2'</span>] == <span class="string">'住宅大樓'</span>) | (df[<span class="string">'建物型態2'</span>] == <span class="string">'公寓'</span>) | (df[<span class="string">'建物型態2'</span>] == <span class="string">'套房'</span>)</span><br><span class="line">)]</span><br><span class="line">dfdistrict = dfdistrict[dfdistrict[<span class="string">'單價元坪'</span>] &lt; <span class="number">2000000</span>]</span><br><span class="line"></span><br><span class="line">dfdistrict[<span class="string">'單價元坪'</span>].groupby(dfdistrict[<span class="string">'建物型態2'</span>]).hist(bins=<span class="number">50</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">plt.legend(set(dfdistrict[<span class="string">'建物型態2'</span>]))</span><br></pre></td></tr></table></figure><center><img src="/real-estate-analasys-histograms/bhis.png" title="distribution2"></center><p>這樣我們就可以一眼看出來，究竟公寓跟電梯大樓有什麼不一樣<br>方便我們在選擇的時候，多一些考慮<br>讓我們在買房談價格時，可以有更全面的概念！</p><p>有時候買房不是為了投資，而是生活所需而不得不，<br>在這個時代，我們已經無法買的精妙，炒房產呱呱叫，<br>但至少在面對這種重大抉擇時，<br>能有多一份數據輔佐，盡量不要「虧太多」，買到與價格相符的好房！</p><p>假如希望我們未來可以多多發佈類似的文章，<br>可以到<a href="https://www.facebook.com/finlab.python/" rel="external nofollow noopener noreferrer" target="_blank">粉絲團</a><br>幫我們按個讚～！</p><p><a href="https://colab.research.google.com/drive/1MyWsmtsfTakVR3EDtX2B-ZV4WdHtnpt6" rel="external nofollow noopener noreferrer" target="_blank">colab線上編寫此範例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/real-estate-analasys-histograms/fb11.png&quot; title=&quot;distribution&quot;&gt;&lt;/center&gt;

&lt;p&gt;大家都在說房價市場恢復景氣，然而真的是這樣子嗎？&lt;br&gt;你有沒有覺得，怎麼每個人說的話都
      
    
    </summary>
    
      <category term="實價登入" scheme="https://www.finlab.tw/categories/%E5%AF%A6%E5%83%B9%E7%99%BB%E5%85%A5/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="房地產" scheme="https://www.finlab.tw/tags/%E6%88%BF%E5%9C%B0%E7%94%A2/"/>
    
  </entry>
  
  <entry>
    <title>用程式分析房地產可行嗎（1）房地產爬蟲</title>
    <link href="https://www.finlab.tw/real-estate-analysis1/"/>
    <id>https://www.finlab.tw/real-estate-analysis1/</id>
    <published>2019-08-21T02:10:05.000Z</published>
    <updated>2020-06-05T07:29:47.618Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/real-estate-analysis1/thumbnail.png" title="投資房產"></center><p>賺了一輩子的錢，還不如買對一戶房！<br>非常誇張，但又滿有道理的<br>假如一定要買房子，要買在哪裡呢？<br>如何找到抗跌的地段？<br>隨著屋齡不同，房價應該要如何變化呢？</p><p>這些問題，可能只有房地產專家一一為你解惑，<br>但一般人要買房，除了相信專家以外，還能怎麼辦呢？</p><p>利用程式來研究，自己當專家<br>現在台灣有實價登入的法規，這些資訊都是公開透明的<br>（雖然實價不等於真的成交價，但應該還是有正相關）</p><p>要爬取這些資訊，只要很短的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">real_estate_crawler</span><span class="params">(year, season)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> year &gt; <span class="number">1000</span>:</span><br><span class="line">    year -= <span class="number">1911</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># download real estate zip content</span></span><br><span class="line">  res = requests.get(<span class="string">"https://plvr.land.moi.gov.tw//DownloadSeason?season="</span>+str(year)+<span class="string">"S"</span>+str(season)+<span class="string">"&amp;type=zip&amp;fileName=lvr_landcsv.zip"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># save content to file</span></span><br><span class="line">  fname = str(year)+str(season)+<span class="string">'.zip'</span></span><br><span class="line">  open(fname, <span class="string">'wb'</span>).write(res.content)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># make additional folder for files to extract</span></span><br><span class="line">  folder = <span class="string">'real_estate'</span> + str(year) + str(season)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(folder):</span><br><span class="line">    os.mkdir(folder)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># extract files to the folder</span></span><br><span class="line">  <span class="keyword">with</span> zipfile.ZipFile(fname, <span class="string">'r'</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">      zip_ref.extractall(folder)</span><br><span class="line"></span><br><span class="line">  time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>然後我們再寫個 for 迴圈，就可以將近 8 年的房價買賣資訊都爬下來</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">real_estate_crawler(<span class="number">101</span>, <span class="number">3</span>)</span><br><span class="line">real_estate_crawler(<span class="number">101</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> range(<span class="number">102</span>, <span class="number">108</span>):</span><br><span class="line">  <span class="keyword">for</span> season <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    print(year, season)</span><br><span class="line">    real_estate_crawler(year, season)</span><br><span class="line"></span><br><span class="line">real_estate_crawler(<span class="number">108</span>, <span class="number">1</span>)</span><br><span class="line">real_estate_crawler(<span class="number">108</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>這邊就先簡單的放上爬蟲，也有<a href="https://colab.research.google.com/drive/1uDVzXC9e9hXKxoGPK5mryj-B3NSRxNVl" rel="external nofollow noopener noreferrer" target="_blank">線上colab範例直接運行</a></p><p>之後我們會來研究，<br>究竟那邊的房價衰退的比較快？<br>哪裡是比較抗跌的區域？<br>哪裡的房子最便宜又最抗跌？</p><p>假如你對這系列有興趣的話，<br>可以到<a href="https://www.facebook.com/finlab.python/" rel="external nofollow noopener noreferrer" target="_blank">粉絲團</a>的這篇文章按個讚<br>這樣我才知道這是大家想看的<br>才會繼續往下寫喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;/real-estate-analysis1/thumbnail.png&quot; title=&quot;投資房產&quot;&gt;&lt;/center&gt;

&lt;p&gt;賺了一輩子的錢，還不如買對一戶房！&lt;br&gt;非常誇張，但又滿有道理的&lt;br&gt;假如一定要買房子，要買在哪裡呢？&lt;br&gt;
      
    
    </summary>
    
      <category term="實價登入" scheme="https://www.finlab.tw/categories/%E5%AF%A6%E5%83%B9%E7%99%BB%E5%85%A5/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="房地產" scheme="https://www.finlab.tw/tags/%E6%88%BF%E5%9C%B0%E7%94%A2/"/>
    
  </entry>
  
</feed>
